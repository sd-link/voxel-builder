<!--
    Aug 2019
    4.0.1 RC 2023
    @nimadez

    # Voxel Builder
    # Voxel-based 3D modeling application

    [ Code Map ]
    01. Initialize
    02. Scene
    03. Camera
    04. HDRI and Skybox
    05. Pipeline (post-process)
    06. Material
    07. Builder (SPS particles)
    08. Palette (color palette)
    09. Helper (overlays)
    10. Tool, ToolBakery
    11. Symmetry
    12. Voxelizer
    13. Generator
    14. Bakery
    15. Snapshot
    16. Memory
    17. Project
    18. UserInterface
    19. UserInterfaceAdvanced
    20. Preferences
    21. Events
    22. Utils
    23. Documentation
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="description" content="Voxel-based 3D modeling application for desktop and mobile browsers">
    <meta name="author" content="@nimadez">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="@nimadez">
    <meta name="twitter:creator" content="@nimadez">
    <meta name="twitter:title" content="Voxel Builder">
    <meta name="twitter:description" content="Voxel-based 3D modeling application for desktop and mobile browsers">
    <meta name="twitter:image" content="https://nimadez.github.io/voxel-builder/media/logo.jpg?314746">
    <title>Voxel Builder</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAiJJREFUWEdjZBhgwDjA9jMMTgfkNm38zsjAwIEROv8Z2ifV+1cRCrW8po3/samZVOeP4WEMAVyaYQYyMjL6Tqz124LLEYT0ozsCpwPqpCIx7Gh6thwshs0nIPG8po0ZDAwM09NE2hgk2C6j6MelF9MBjRvWMDAyBheKlzLwMj8hyhCYIpjvSXE81kSIy6CXv7UZZr6uYfjPwFA7uc6/BT2IcOnDF3IkOQBkIS7Dchs3RjMyMiyJFZrIoMhxguiQw+qAjJbN0mz//j3R4rjCECLUSpRh5AQ/yGCc5QAuA3/942XoeDGLgYHh/9pJdQEhhOKfUMIl2QHYoiG/ZaPd/38MB4ME5jDocO0lKsTg2RpfoUJsoiI3+PFGATRfg0s0XNnqP8P/h5PrAhSIdSg2z+KtC4jxGcM/Zl0Gpr+XPfhWMpjxbCAp+AmGAL5QgCUumI3oofTxjzzDxFcdDP///185uT4gAldUE6wNiQoFLNFEKPUTlQiJSQcgNbY82xkc+RaRHPxERQEx0YAe/Cvf1jPc/KnB8O0Hg8ScNv+X+HIawSggJhTQHUBs8JMQAps2MTD89y0WL2TgZn6B4qFtH3IYvASmkBX8RDuAUCgg206K74eWA3KaNyky/f9/T4/zAkOAYCfOdEWzECAmGki1nKQoGBQOIOQImocAsgNwJQJcLWay6wJsGnG1/f/9YlSa0uJ3H1/Jhy5HVElIioGkqh11AACQYjUw+9rFtwAAAABJRU5ErkJggg==">
    <link rel="manifest" href="manifest.webmanifest">
    <script src="libs/babylon.js"></script>
    <script src="libs/babylonjs.materials.min.js"></script>
    <script src="libs/babylonjs.loaders.min.js"></script>
    <script src="libs/babylonjs.serializers.min.js"></script>
    <script src="libs/babylon.gui.min.js"></script>
    <style>
        @font-face {
            font-family: 'DroidSans';
            src: url(data:font/truetype;charset=utf-8;base64,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FSERIQEhESMGVv0I/iXLugKPA8n9wwIW/eoCPft1AZNsAcX+OwW2pP48ov34AcYCqAAAAP//AH3+FASYBcsSJgAmAAARBwB6AfwAAAALtgFPKiQYICUBKzUAAAD//wDHAAADvgdzEiYAKAAAEQcAQ/+3AVIAFbQBDAUmAbj/wrQSDAEAJQErNQArNQD//wDHAAADvgdzEiYAKAAAEQcAdgA/AVIAE0ALARgFJgFKDBIBACUBKzUAKzUAAAD//wDHAAADvgdzEiYAKAAAEQcAw//xAVIAFbQBDAUmAbj//bQUDAEAJQErNQArNQD//wDHAAADvgcrEiYAKAAAEQcAav/1AVIAF0ANAgEVBSYCAQEMIAEAJQErNTUAKzU1AAAA//8APgAAAmQHcxImACwAABEHAEP+tQFSABW0AQwFJgG4/6i0EgwBACUBKzUAKzUA//8AUgAAAooHcxImACwAABEHAHb/eAFSABNACwEYBSYBagwSAQAlASs1ACs1AAAA//8AEQAAAqkHcxImACwAABEHAMP/DwFSABNACwEMBSYBAhQMAQAlASs1ACs1AAAA//8AQAAAAncHKxImACwAABEHAGr/DQFSABdADQIBFQUmAgEADCABACUBKzU1ACs1NQAAAAACAC8AAAT8BbYAEAAfAF1AOhoaDhFbCGchICEBGBxaDhAQAQ5kIBsQXxgPAAEPAD8AbwCvAN8A/wAGCABAGh1IAAACHGAOEhdgAgMAP+E/4RE5LyteXXEz4TIBEOYyMi8Q4TJdEPbhETkvMTATMxEhMh4BEhUUAgYEIyERIyU0LgIrAREhFSERMyAAL5gBl5n4rl9gtv73qP6SmAQIQn64dckBUP6wogEIAQwDJQKRXLX+9LC5/um7XgKDYJLVikP+DqL+HQEk//8AxwAABQ4HNRImADEAABEHAMUAiwFSABNACwEgBSYBCiEvCgAlASs1ACs1AAAA//8Aff/sBXEHcxImADIAABEHAEMAVAFSABW0AigFJgK4/6u0LigKACUBKzUAKzUA//8Aff/sBXEHcxImADIAABEHAHYBAgFSABNACwI0BSYCWCguCgAlASs1ACs1AAAA//8Aff/sBXEHcxImADIAABEHAMMArgFSABNACwIoBSYCBTAoCgAlASs1ACs1AAAA//8Aff/sBXEHNRImADIAABEHAMUAfQFS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b3B5cmlnaHQgqSAyMDA3LCBHb29nbGUgQ29ycG9yYXRpb24uAABEAHIAbwBpAGQAIABTAGEAbgBzAABEcm9pZCBTYW5zAABSAGUAZwB1AGwAYQByAABSZWd1bGFyAABBAHMAYwBlAG4AZABlAHIAIAAtACAARAByAG8AaQBkACAAUwBhAG4AcwAAQXNjZW5kZXIgLSBEcm9pZCBTYW5zAABEAHIAbwBpAGQAIABTAGEAbgBzAABEcm9pZCBTYW5zAABWAGUAcgBzAGkAbwBuACAAMQAuADAAMAAgAGIAdQBpAGwAZAAgADEAMQAzAABWZXJzaW9uIDEuMDAgYnVpbGQgMTEzAABEAHIAbwBpAGQAUwBhAG4AcwAARHJvaWRTYW5zAABEAHIAbwBpAGQAIABpAHMAIABhACAAdAByAGEAZABlAG0AYQByAGsAIABvAGYAIABHAG8AbwBnAGwAZQAgAGEAbgBkACAAbQBhAHkAIABiAGUAIAByAGUAZwBpAHMAdABlAHIAZQBkACAAaQBuACAAYwBlAHIAdABhAGkAbgAgAGoAdQByAGkAcwBkAGkAYwB0AGkAbwBuAHMALgAARHJvaWQgaXMgYSB0cmFkZW1hcmsgb2YgR29vZ2xlIGFuZCBtYXkgYmUgcmVnaXN0ZXJlZCBpbiBjZXJ0YWluIGp1cmlzZGljdGlvbnMuAABBAHMAYwBlAG4AZABlAHIAIABDAG8AcgBwAG8AcgBhAHQAaQBvAG4AAEFzY2VuZGVyIENvcnBvcmF0aW9uAABEAHIAbwBpAGQAIABTAGEAbgBzACAAaQBzACAAYQAgAGgAdQBtAGEAbgBpAHMAdAAgAHMAYQBuAHMAIABzAGUAcgBpAGYAIAB0AHkAcABlAGYAYQBjAGUAIABkAGUAcwBpAGcAbgBlAGQAIABmAG8AcgAgAHUAcwBlAHIAIABpAG4AdABlAHIAZgBhAGMAZQBzACAAYQBuAGQAIABlAGwAZQBjAHQAcgBvAG4AaQBjACAAYwBvAG0AbQB1AG4AaQBjAGEAdABpAG8AbgAuAABEcm9pZCBTYW5zIGlzIGEgaHVtYW5pc3Qgc2FucyBzZXJpZiB0eXBlZmFjZSBkZXNpZ25lZCBmb3IgdXNlciBpbnRlcmZhY2VzIGFuZCBlbGVjdHJvbmljIGNvbW11bmljYXRp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AEAAKQBgACkAif/XAJT/1wCV/9cAlv/XAJf/1wCY/9cAmv/XAMkAKQDMACkAFgAP/8MAEf/DACT/7AAs/+wAN//DADn/7AA6/+wAO//sADz/1wA9/+wAgv/sAIP/7ACE/+wAhf/sAIb/7ACH/+wAiP/DAI7/7ACP/+wAkP/sAJH/7ACf/9cAFgAFAD0ACgA9AAwAKQAP/5oAEf+aACIAKQAk/9cAOQAUADoAFAA8ABQAQAApAGAAKQCC/9cAg//XAIT/1wCF/9cAhv/XAIf/1wCI/8MAnwAUAMkAPQDMAD0ADwAFACkACgApACb/7AAq/+wAMv/sADT/7ACJ/+wAlP/sAJX/7ACW/+wAl//sAJj/7ACa/+wAyQApAMwAKQAPAAUAKQAKACkAJv/XACr/1wAy/9cANP/XAIn/1wCU/9cAlf/XAJb/1wCX/9cAmP/XAJr/1wDJACkAzAApABkABf+aAAr/mgAm/+wAKv/sADL/7AA0/+wAN/+FADj/7AA5/64AOv/DADz/mgCJ/+wAlP/sAJX/7ACW/+wAl//sAJj/7ACa/+wAm//sAJz/7ACd/+wAnv/sAJ//mgDJ/5oAzP+aABYAD//DABH/wwAk/+wALP/sADf/wwA5/9cAOv/sADv/1wA8/9cAPf/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/1wCO/+wAj//sAJD/7ACR/+wAn//XABAAD/8zABH/MwAk/64AJv/sADv/7AA8/+wAPf/XAIL/rgCD/64AhP+uAIX/rgCG/64Ah/+uAIj/cQCJ/+wAn//sABYAD//DABH/wwAk/+wALP/sADf/wwA5/9cAOv/sADv/1wA8/9cAPf/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/wwCO/+wAj//sAJD/7ACR/+wAn//XAAEAN//sAEoABQBSAAoAUgAP/5oAEP+aABH/mgAiACkAJP+FACb/wwAq/8MAMv/DADT/wwA2/+wANwAUAET/hQBG/4UAR/+FAEj/hQBK/5oAUP+uAFH/rgBS/4UAU/+uAFT/hQBV/64AVv+FAFj/rgBZ/8MAWv/DAFv/wwBc/8MAXf/DAIL/hQCD/4UAhP+FAIX/hQCG/4UAh/+FAIj/cQCJ/8MAlP/DAJX/wwCW/8MAl//DAJj/wwCa/8MAov+FAKP/hQCk/4UApf+FAKb/hQCn/4UAqP+FAKn/hQCq/4UAq/+FAKz/hQCt/4UAs/+uALT/hQC1/4UAtv+FALf/hQC4/4UAuv+FALv/rgC8/64Avf+uAL7/rgC//8MAwf/DAMb/rgDH/5oAyQBSAMwAUgAKAA//1wAR/9cAJP/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/1wA+AAUAUgAKAFIAD/+aABH/mgAiACkAJP/DACb/1wAq/9cAMv/XADT/1wBE/8MARv/DAEf/wwBI/8MASv/DAFD/1wBR/9cAUv/DAFP/1wBU/8MAVf/XAFb/1wBY/9cAgv/DAIP/wwCE/8MAhf/DAIb/wwCH/8MAiP+FAIn/1wCU/9cAlf/XAJb/1wCX/9cAmP/XAJr/1wCi/8MAo//DAKT/wwCl/8MApv/DAKf/wwCo/8MAqf/DAKr/wwCr/8MArP/DAK3/wwCz/9cAtP/DALX/wwC2/8MAt//DALj/wwC6/8MAu//XALz/1wC9/9cAvv/XAMkAUgDMAFIAPgAFAGYACgBmAA//rgAR/64AJP/XACb/7AAq/+wAMv/sADT/7ABE/9cARv/XAEf/1wBI/9cASv/sAFD/7ABR/+wAUv/XAFP/7ABU/9cAVf/sAFb/1wBY/+wAXf/sAIL/1wCD/9cAhP/XAIX/1wCG/9cAh//XAIj/rgCJ/+wAlP/sAJX/7ACW/+wAl//sAJj/7ACa/+wAov/XAKP/1wCk/9cApf/XAKb/1wCn/9cAqP/XAKn/1wCq/9cAq//XAKz/1wCt/9cAs//sALT/1wC1/9cAtv/XALf/1wC4/9cAuv/XALv/7AC8/+wAvf/sAL7/7ADJAGYAzABmACAABQApAAoAKQAm/9cAKv/XADL/1wA0/9cARv/sAEf/7ABI/+wAUv/sAFT/7ACJ/9cAlP/XAJX/1wCW/9cAl//XAJj/1wCa/9cAqP/sAKn/7ACq/+wAq//sAKz/7ACt/+wAtP/sALX/7AC2/+wAt//sALj/7AC6/+wAyQApAMwAKQBEAAUAUgAKAFIAD/+aABH/mgAiACkAJP+aACb/1wAq/9cAMv/XADT/1wA2/+wARP+aAEb/mgBH/5oASP+aAEr/mgBQ/8MAUf/DAFL/mgBT/8MAVP+aAFX/wwBW/64AWP/DAFv/1wBc/+wAXf/DAIL/mgCD/5oAhP+aAIX/mgCG/5oAh/+aAIj/cQCJ/9cAlP/XAJX/1wCW/9cAl//XAJj/1wCa/9cAov+aAKP/mgCk/5oApf+aAKb/mgCn/5oAqP+aAKn/mgCq/5oAq/+aAKz/mgCt/5oAs//DALT/mgC1/5oAtv+aALf/mgC4/5oAuv+aALv/wwC8/8MAvf/DAL7/wwC//+wAwf/sAMkAUgDMAFIAAQAK/9cABAAFAD0ACgA9AMkAPQDMAD0ACQAFAGYACgBmAFkAFABaABQAXAAUAL8AFADBABQAyQBmAMwAZgAFAAUAKQAKACkASgAUAMkAKQDMACkAAQAK/8MABAAFACkACgApAMkAKQDMACkAAgBb/9cAXf/sAAwABQBmAAoAZgBE/+wASv/sAKL/7ACj/+wApP/sAKX/7ACm/+wAp//sAMkAZgDMAGYABQAFAFIACgBSAFcAFADJAFIAzABSAAUABQBSAAoAUgBJABQAyQBSAMwAUgAMAAUAKQAKACkAUv/XAKj/1wC0/9cAtf/XALb/1wC3/9cAuP/XALr/1wDJACkAzAApAAUABQA9AAoAPQBJABQAyQA9AMwAPQAIAFL/7ACo/+wAtP/sALX/7AC2/+wAt//sALj/7AC6/+wAJwAF/64ACv+uAA3/hQAPAEQAHgBEACL/wwAm/+wAKv/sAC0AXgAy/+wANP/sADf/hQA4/+wAOf/DADr/1wA8/5oAPQA7AEn/7ABX/+wAWf/XAFr/7ABc/9cAgv/XAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//1wDB/9cAyf+uAMz/rgAlAAX/rgAK/64ADf+FAA8ARAAeAEQAIv/DACb/7AAq/+wAMv/sADT/7AA3/4UAOP/sADn/wwA6/9cAPP+aAD0AOwBJ/+wAV//sAFn/1wBa/+wAXP/XAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//1wDB/9cAyf+uAMz/rgAlAAX/rgAK/64ADf9/AA8ARAAeAEQAIv/XACb/7AAq/+wALQBeADL/7AA0/+wAN/+FADj/7AA5/8MAOv/XADz/mgA9ADsAV//lAFn/1QBa/+UAXP/bAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//2wDB/9sAyf+uAMz/rgAnAAX/ZgAK/2YADf9/AA8ARAAeAEQAIv/XACb/7AAq/+wALQBeADL/7AA0/+wAN/+FADj/7AA5/8MAOv/XADz/mgA9ADsAV//lAFn/1QBa/+UAXP/bAIn/7ACU/+wAlf/sAJb/7ACX/+wAmP/sAJr/7ACb/+wAnP/sAJ3/7ACe/+wAn/+aAL//2wDB/9sAyP9mAMn/rgDL/2YAzP+uABIABQApAAoAKQAQ/9cAJv/sADL/7AA0/+wAhP/sAIn/7ACK/+wAj//sAJT/7ACV/+wAlv/sAJf/7ACY/+wAmv/sAMkAKQDMACkAEAAFACkACgApABD/1wAm/+wAMv/sADT/7ACJ/+wAi//sAJT/7ACV/+wAlv/sAJf/7ACY/+wAmv/sAMkAKQDMACkABwAk/+wAgv/sAIP/7ACE/+wAhf/sAIb/7ACH/+wAGwAM/9cAD//DABH/wwAk/+wALP/sAC3/9gA2/+wAN//DADn/1wA6/+wAO//XADz/1wA9/+wAQP/XAGD/1wCC/+wAg//sAIT/7ACF/+wAhv/sAIf/7ACI/9cAjv/sAI//7ACQ/+wAkf/sAJ//1wATAA//1wAR/9cAJP/sADD/7AA9/+wARP/sAIL/7ACD/+wAhP/sAIX/7ACG/+wAh//sAIj/1wCi/+wAo//sAKT/7ACl/+wApv/sAKf/7ABSAAUAUgAJ/8MACgBSAAwAPQANACkAD/+aABD/mgAR/5oAIgApACT/mgAm/9cAKv/XAC3/vgAw/8MAMv/XADT/1wA2/+wANwAnADkAKQA6ABQAQAA9AET/mgBG/5oAR/+aAEj/mgBJ/+UASv+aAFD/wwBR/8MAUv+aAFP/wwBU/5oAVf/DAFb/rgBY/8MAWf/XAFr/7ABb/9cAXP/sAF3/wwBgAD0Agv+aAIP/mgCE/5oAhf+aAIb/mgCH/5oAiP9xAIn/1wCU/9cAlf/XAJb/1wCX/9cAmP/XAJr/1wCi/5oAo/+aAKT/mgCl/5oApv+aAKf/mgCo/5oAqf+aAKr/mgCr/5oArP+aAK3/mgCz/8MAtP+aALX/mgC2/5oAt/+aALj/mgC6/5oAu//DALz/wwC9/8MAvv/DAL//7ADB/+wAyQBSAMwAUgACAAX/mAAK/9cAAwAF/5gACv/XAMz/1wAFAAX/bwAK/28ASf/bAFv/1wBd/+wAAgAF/74ACv++AB4ABQA9AAoAPQAP/74AEf++ACL/tABG//YAR//2AEj/9gBJABQASv/2AFL/9gBU//YAVwAGAKj/9gCp//YAqv/2AKv/9gCs//YArf/2ALT/9gC1//YAtv/2ALf/9gC4//YAuv/2AMkAPQDK/40AzAA9AM3/jQDQAAwABwAFAD0ACgA9AA//vgAR/74ASQAUAMkAPQDMAD0AKQAk/64ALAApADcAUgA5AFIAOgBmADsAKQA8AFIAPQApAEb/wwBH/8MASP/DAEr/1wBS/8MAVP/DAFcAKQBZACkAWgAUAIL/rgCD/64AhP+uAIX/rgCG/64Ah/+uAIj/XACOACkAjwApAJAAKQCRACkAnwBSAKj/wwCp/8MAqv/DAKv/wwCs/8MArf/DALT/wwC1/8MAtv/DALf/wwC4/8MAuv/DAAIAGQAFAAUAAAAKAAsAAQAPABEAAwAkACcABgApACkACgAsACwACwAuAC8ADAAyADUADgA3AD4AEgBEAEYAGgBIAEsAHQBOAE4AIQBQAFIAIgBVAFcAJQBZAF4AKACCAIcALgCJAJIANACUAJgAPgCaAJ8AQwCiAK0ASQCzALgAVQC6AL8AWwDBAMEAYQDGAMgAYgDLAMsAZQABAAAACgAcAB4AAWxhdG4ACAAEAAAAAP//AAAAAAAA)
                format('truetype');
        }
        @font-face {
            font-family: 'Material Icons'; font-style: normal; font-weight: 400;
            src: url(assets/materialicons.woff2)
                format('woff2');
        }
        :root { /* orange, steelblue */
            --btn-color: #9aaabd;
            --btn-bg: #303947;
            --input-bg: #222833;
            --input-color: #96a2b8;
            --label: #7e899c;
            --cat-bg: #252833;
            --cat-color: #5e6777;
        }
        * { margin: 0; padding: 0; outline: none; }
        html, body { overscroll-behavior-y: contain; user-select: none; overflow: hidden; touch-action: pan-x; -webkit-tap-highlight-color: transparent; } /* prevent pull-down refresh and text selection on chrome mobile + prevent forced scroll + blue tap highlight on touch */
        body { background: white; font-family: 'DroidSans'; font-size: 11px; color: silver; position: fixed; width: 100%; height: 100%; cursor: default; }
        a { font-size: 11px; color: #6a8cad; text-decoration: none; }
        a:hover { color: orange; text-decoration: none; }
        input[type=number] { width: 50px; height: 10px; text-indent: 2px; margin: 0 0 2px 0; background: var(--input-bg); color: var(--input-color); padding: 3px; font-size: 11px; border: solid 1px #343c49; border-radius: 2px; text-align: left; }
        input[type=number]:hover { color: steelblue; border: solid 1px #43495a; }
        input[type=text] { width: 90px; background: var(--input-bg); color: var(--input-color); padding: 3px; font-size: 11px; text-indent: 1px; border: solid 1px #343c49; border-radius: 2px; text-align: left; }
        input[type=text]:hover { color: steelblue; border: solid 1px #43495a; cursor: text; }
        input[type=range] { accent-color: steelblue; width: 100%; height: 2px; margin: 0 0 8px 0; }
        input[type=range]::-webkit-slider-thumb { transform: scale(0.7); }
        input[type=range]::-webkit-slider-thumb:hover { cursor: pointer; }
        input[type=checkbox] { filter: brightness(0.7); transform: scale(0.8); margin: 3px 0 3px 0; vertical-align: -2px; }
        input[type=checkbox]:checked { accent-color: steelblue; filter: none; }
        input[type=checkbox]:disabled { opacity: 0.5; }
        input[type=color] { width: 28px; height: 28px; border-radius: 3px; background: none; outline: none; border: none; }
        input[type=color]::-webkit-color-swatch-wrapper { padding: 0; border: solid 1px #00000000; }
        input[type=color]::-webkit-color-swatch { border: none; border-radius: 3px; border: solid 1px #444; }
        input[type=color]:hover { background: orange; cursor: pointer; }
        ul { position: absolute; list-style-type: none; }
        ul li { background: var(--btn-bg); color: var(--btn-color); border: 1px solid #161a2096; border-radius: 3px; padding: 2px; text-align: center; }
        ul li:hover, .tool_selector, .tool_bakery_selector { background: orange; color: black; }
        button { background: var(--btn-bg); color: var(--btn-color); box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; border-radius: 3px; padding: 5px 0 5px 0; border: 1px solid #161a2080; }
        button:hover { background: orange; color: #222; cursor: pointer; }
        button:disabled { background: var(--btn-bg); opacity: 0.5; pointer-events: none; }
        label { color: var(--label); margin: 0; font-size: 11px; }
        select { width: 100%; background: var(--btn-bg); color: var(--btn-color); font-size: 11px; padding: 4px 0 4px 0; border: solid 1px #161a2080; border-radius: 3px; outline: none; text-align: center; vertical-align: middle; }
        select:hover { color: steelblue; cursor: pointer; }
        option { color: silver; background: var(--btn-bg); }
        #canvas_render { z-index: 0; position: absolute; width: 100%; height: 100%; background: linear-gradient(0deg, #333946 0%, #545c70 100%); }
        #canvas_palette { z-index: 1; position: relative; width: 100%; height: 64000px; }
        .menu_R { z-index: 1000; background: #2a2f3a; position: absolute; top: 0; right: 0; padding: 0 6px 6px 6px; width: 100px; height: fit-content; transform: translate(200px, 0); transition: transform 0.15s ease; box-shadow: -1px 1px 3px #404b58AA; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; }
        .menu_R li { background: none; text-align: left; border: none; padding: 0; cursor: default; }
        .menu_R li:hover { background: none; }
        .menu_R li div.flex { display: inline-flex; }
        .menu_R li div.flex button { width: 50px; }
        .menu_R button { width: 100%; font-size: 11px; padding: 6px 0 6px 0; border-radius: 2px; }
        .menu_R .category { color: var(--cat-color); background: var(--cat-bg); font-size: 10px; letter-spacing: 0.06em; text-align: center; margin: 3px 0 3px 0; padding: 2px 0 2px 0; border-radius: 0; }
        .menu_R .category:hover { color: var(--cat-color); background: var(--cat-bg); cursor: default; }
        .menu_R :first-child { cursor: pointer; }
        .menu_R :first-child span { color: var(--btn-color); letter-spacing: 0.08em; font-size: 9px; vertical-align: -4px; }
        .menu_R li i:first-child { color: var(--cat-color); margin-top: 6px; }
        .menu_R li:hover i:first-child { color: orange; }
        .menu_L { z-index: 1000; background: #2a2f3a; position: absolute; top: 0; left: 0; padding: 0 6px 6px 6px; width: 100px; height: fit-content; transform: translate(-200px, 0); transition: transform 0.15s ease; box-shadow: 1px 1px 3px #404b58AA; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; }
        .menu_L li { background: none; text-align: left; border: none; padding: 0; cursor: default; }
        .menu_L li:hover { background: none; }
        .menu_L li div.flex { display: inline-flex; }
        .menu_L li div.flex button { width: 50px; }
        .menu_L button { width: 100%; font-size: 11px; padding: 6px 0 6px 0; border-radius: 2px; }
        .menu_L .category { color: var(--cat-color); background: var(--cat-bg); font-size: 10px; letter-spacing: 0.06em; text-align: center; margin: 3px 0 3px 0; padding: 2px 0 2px 0; border-radius: 0; }
        .menu_L .category:hover { color: var(--cat-color); background: var(--cat-bg); cursor: default; }
        .menu_L :first-child { cursor: pointer; }
        .menu_L :first-child span { color: var(--btn-color); letter-spacing: 0.08em; font-size: 9px; vertical-align: -4px; }
        .menu_L li i:first-child { color: var(--cat-color); margin-top: 6px; transform: rotate(180deg); }
        .menu_L li:hover i:first-child { color: orange; }
        #toolbar_C { z-index: 500; width: 200px; left: 50%; margin-left: -100px; top: 1px; text-align: center; }
        #toolbar_C li { display: inline-block; color: var(--btn-color); width: 65px; letter-spacing: 0.06em; font-size: 10px; padding: 7px 0 7px 0; margin: 0 -2px 0 -2px; box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; border-radius: 0; cursor: pointer; }
        #toolbar_C li:hover { color: black; }
        #toolbar_C li:nth-child(1) { border-top-left-radius: 3px; border-bottom-left-radius: 3px; }
        #toolbar_C li:nth-child(3) { border-top-right-radius: 3px; border-bottom-right-radius: 3px; }
        #toolbar_C li.mode_select { background: var(--btn-bg); color: orange; }
        #toolbar_C_mem { z-index: 500; width: 200px; left: 50%; margin-left: -100px; top: 30px; text-align: center; }
        #toolbar_C_mem li { display: inline-block; width: 47px; font-size: 10px; color: var(--btn-color); padding: 6px 0 6px 0; margin: 0 -2px 0 -2px; box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; border-radius: 0; cursor: pointer; }
        #toolbar_C_mem li:hover { color: #222; }
        #toolbar_C_mem :nth-child(1) { font-weight: normal; border-top-left-radius: 3px; border-bottom-left-radius: 3px; }
        #toolbar_C_mem :nth-child(2) { font-weight: normal; border-top-right-radius: 3px; border-bottom-right-radius: 3px; }
        #toolbar_C_mem :nth-child(3) { margin-left: 4px; font-weight: normal; border-top-left-radius: 3px; border-bottom-left-radius: 3px; }
        #toolbar_C_mem :nth-child(4) { font-weight: normal; border-right: 1px solid #161a2096; border-top-right-radius: 3px; border-bottom-right-radius: 3px; }
        #toolbar_R { z-index: 500; width: 60px; position: absolute; right: 0; top: 0; }
        #toolbar_R li { display: unset; background: none; border: none; padding: 0; }
        #toolbar_R button { width: 100%; font-size: 9px; padding: 7px 5px 7px 5px; border-radius: 0; }
        #toolbar_L { z-index: 500; width: 60px; position: absolute; left: 0; top: 0; }
        #toolbar_L li { display: inline; background: none; border: none; padding: 0; }
        #toolbar_L li:nth-child(1) button { padding-top: 4px; padding-bottom: 4px; }
        #toolbar_L button { width: 100%; font-size: 9px; padding: 7px 5px 7px 5px; border-radius: 0; }
        #toolbar_L li:first-child :first-child { width: 50%; float: left; }
        #toolbar_L li:first-child :last-child { width: 50%; }
        #hover { z-index: 600; top: 25%; left: 30%; position: absolute; background: none; }
        #hover li { padding: 4px; margin: -1px; box-shadow: inset 1px 1px 1px #37414e, inset -1px -1px 1px #2f3742; cursor: pointer; }
        #hover li:nth-child(1) { transform: scale(1.1); cursor: move; box-shadow: none; }
        #hover li:nth-child(2) { position: absolute; top: -30px; left: 0%; }
        #hover li:nth-child(3) { position: absolute; top: 0;     left: 30px; }
        #hover li:nth-child(4) { position: absolute; top: 0;     left: -30px; }
        #hover li:nth-child(5) { position: absolute; top: 27px;  left: -27px; }
        #hover li:nth-child(6) { position: absolute; top: 27px;  left: 27px; }
        #hover li:nth-child(7) { position: absolute; top: -27px; left: -27px; }
        #hover li:nth-child(8) { position: absolute; top: -27px; left: 27px; }
        #hover li:nth-child(9) { position: absolute; top: 30px;  left: 0%; }
        #palette { z-index: 500; width: 41px; background: #31394b30; position: absolute; left: 3px; top: 135px; bottom: 135px; overflow-y: scroll; overflow-x: hidden; }
        #colorpicker0 { z-index: 500; position: absolute; width: 28px; left: 6px; bottom: 98px; }
        #colorpicker1 { z-index: 500; position: absolute; width: 28px; left: 6px; bottom: 98px; }
        #marquee { z-index: 500; display: none; background: #00ffff20; border: dotted 2px aqua; position: absolute; }
        #menu-about .about { font-size: 11px; line-height: 1.3em; background: #21262e; color: #98a1ac; padding: 5px 5px 0 5px; cursor: help; }
        #menu-about .about h1 { font-size: 12px; font-weight: normal; color: #98a1ac; letter-spacing: 1px; cursor: help; }
        #menu-texture li.img { display: inline-block; }
        #menu-texture li :hover { border-color: orange; }
        #menu-texture img { object-fit: fill; border: solid 1px #6b798d; width: 24px; height: 24px; margin: 0 5px 4px 2px; cursor: pointer; }
        #menu-storage img { object-fit: fill; border: dotted 1px #3c3f47; width: 95px; height: 60px; margin-left: 1px; cursor: pointer; }
        #menu-storage li div button { font-size: 10px; }
        #btn-symm-axis { color: orange; font-size: 12px; font-weight: bold; }
        #btn-symm-axis:hover { background: var(--input-bg); }
        #btn-helper-symmetry { z-index: 500; display: unset; font-size: 18px; font-weight: bold; text-shadow: 1px 1px 0 #14171b; width: 20px; padding: 5px; position: absolute; right: 3px; bottom: 90px; text-align: center; cursor: pointer; }
        #btn-helper-workplane { z-index: 500; display: unset; width: 20px; padding: 5px; text-shadow: 1px 1px 0 #14171b; position: absolute; right: 3px; bottom: 125px; text-align: center; cursor: pointer; }
        #btn-helper-workplane i { font-size: 18px; color: aqua; opacity: 0.8; }
        #input-env-background { width: 100%; height: 20px; }
        #input-env-lightcolor { width: 100%; height: 20px; }
        #input-material-emissive { width: 100%; height: 18px; }
        #reticle { z-index: 500; display: none; width: 100px; height: 100px; position: absolute; left: 50%; top: 50%; margin-left: -50px; margin-top: -50px; text-align: center; pointer-events: none; }
        #reticle :nth-child(1) { font-size: 12px; color: #00ffff80; line-height: 100px; grid-column: 1; grid-row: 1; }
        #reticle :nth-child(2) { border: solid 1px #cccccc15; margin: 25px; grid-column: 1; grid-row: 1; }
        #reticle :nth-child(3) { border: dashed 1px #cccccc20; border-radius: 50%; transform: scale(0.8); grid-column: 1; grid-row: 1; }
        #axisview-hitbox { z-index: 500; display: none; width: 40px; height: 40px; position: absolute; right: 30px; bottom: 30px; }
        #info { z-index: 10; background: #2c313a60; color: #97a5b880; font-size: 9px; position: absolute; padding: 2px; width: auto; bottom: 2px; left: 50%; transform: translate(-50%,0); text-align: center; pointer-events: none; }
        #info span { z-index: 10; color: #97a5b8; letter-spacing: 0.05em; }
        #confirm { z-index: 2500; display: none; background: #2a2f3aDD; width: 200px; position: absolute; left: 50%; top: 50%; margin-left: -110px; margin-top: -30px; padding: 8px; border-radius: 3px; text-transform: uppercase; box-shadow: 0 0 3px #000000AA; text-align: center; }
        #confirm span { width: 100%; margin-bottom: 5px; font-size: 11px; color: orange; display: block; }
        #confirm button { width: 48%; font-size: 11px; text-transform: uppercase; }
        #confirmblocker { z-index: 2400; display: none; opacity: 0.8; background: #181b22; position: absolute; width: 100%; height: 100%; }
        #notifier { z-index: 2000; display: none; background: #2a2f3aF1; color: aqua; border: solid 1px #222; box-shadow: 0 0 3px #21262e99; font-size: 11px; position: absolute; width: fit-content; left: 50%; bottom: 20%; margin-left: -200px; padding: 4px 6px 4px 6px; letter-spacing: 1px; text-align: center; border-radius: 3px; pointer-events: none; }
        #help { z-index: 5000; font-size: 12px; background: #181c22; border: solid 1px #2c333d; padding: 8px; position: absolute; width: 80%; height: 90%; left: 50%; bottom: -100%; margin-left: -42%; transition: 0.5s; overflow-y: scroll; overflow-x: hidden; border-radius: 5px; border-bottom-left-radius: 0; border-bottom-right-radius: 0; cursor: help; }
        #help h1 { font-size: 12px; color: orange; letter-spacing: 1px; display: inline; overflow: hidden; }
        #help b { color: #7ba3ca; font-weight: bold; font-style: normal; }
        #help i { color: #93a9c0; font-style: normal; }
        #help img { border-radius: 3px; }
        #help a b, #help a:visited b { color: orange; font-weight: normal; }
        #loadingscreen { z-index: 5000; opacity: 0.8; transition: opacity 1s ease-out; background: #181b22; position: absolute; width: 100%; height: 100%; }
        #loadingscreen .progress { color: slategray; font-size: 10px; letter-spacing: 0.2em; width: 200px; height: 20px; position: absolute; left: 50%; top: 50%; margin-left: -100px; margin-top: 40px; text-align: center; }
        #loadingscreen .logo { transform-style: preserve-3d; animation: bouncing 2s infinite; width: 30px; height: 30px; position: absolute; left: 50%; top: 50%; margin-left: -15px; margin-top: -30px; }
        #intro { z-index: 6000; display: none; opacity: 0; color: #97a5b8; font-size: 10px; line-height: 1.5em; letter-spacing: 0.1em; transition: opacity 0.5s; position: absolute; width: 200px; left: 50%; margin-left: -100px; bottom: 100px; text-transform: uppercase; text-align: center; }
        #intro button { font-size: 10px; font-weight: bold; width: 130px; margin-bottom: 5px; }
        .dropzone { width: 88px; padding: 5px; background: #22263090; color: #586474; border: dotted 1px #14171b; border-radius: 3px; font-size: 10px; text-align: center; }
        .dropzone:hover { background: #222630; color: #586474; }
        .spacer { height: 3px; }
        .material-icons { font-family: 'Material Icons'; font-weight: normal; font-style: normal; font-size: 16px; vertical-align: middle; text-align: center; line-height: 1; letter-spacing: normal; text-transform: none; display: inline-block; white-space: nowrap; word-wrap: normal; direction: ltr; pointer-events: none; font-feature-settings: 'liga'; -webkit-font-feature-settings: 'liga'; -webkit-font-smoothing: antialiased; }
        ::-webkit-scrollbar { width: 7px; }
        ::-webkit-scrollbar-track { background: none; }
        ::-webkit-scrollbar-thumb { background: steelblue; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: orange; }    
        /* source: https://www.rareprogrammer.com/bouncing-cube-css-loader */
        .cube { transform-style: preserve-3d; transform: rotateX(45deg) rotateZ(45deg); animation: rotation 2s infinite; }
        .cube-faces { transform-style: preserve-3d; height: 30px; width: 30px; position: relative; transform-origin: 0 0; transform: translateX(0) translateY(0) translateZ(-30px); }
        .cube-face { position: absolute; inset: 0; background: #ffa50020; border: solid 1px orange; }
        .cube-face.top { transform: translateZ(30px); }
        .cube-face.front { transform-origin: 0 50%; transform: rotateY(-90deg); }
        .cube-face.back { transform-origin: 0 50%; transform: rotateY(-90deg) translateZ(-30px); }
        .cube-face.right { transform-origin: 50% 0; transform: rotateX(-90deg) translateY(-30px); }
        .cube-face.left { transform-origin: 50% 0; transform: rotateX(-90deg) translateY(-30px) translateZ(30px); }
        @keyframes rotation {
            0% { transform: rotateX(45deg) rotateY(0) rotateZ(45deg); animation-timing-function: cubic-bezier(0.17, 0.84, 0.44, 1); }
            50% { transform: rotateX(45deg) rotateY(0) rotateZ(225deg); animation-timing-function: cubic-bezier(0.76, 0.05, 0.86, 0.06); }
            100% { transform: rotateX(45deg) rotateY(0) rotateZ(405deg); animation-timing-function: cubic-bezier(0.17, 0.84, 0.44, 1); }
        }
        @keyframes bouncing {
            0% { transform: translateY(-10px); animation-timing-function: cubic-bezier(0.76, 0.05, 0.86, 0.06); }
            45% { transform: translateY(10px); animation-timing-function: cubic-bezier(0.23, 1, 0.32, 1); }
            100% { transform: translateY(-10px); animation-timing-function: cubic-bezier(0.76, 0.05, 0.86, 0.06); }
        }
    </style>
</head>
<body>
    <canvas id="canvas_render" ondrop="dropHandler(event)" ondragover="dragHandler(event)" ondragleave="dragLeaveHandler(event)"></canvas>
    <ul id="toolbar_R">
        <li title="File"><button onclick="ui.toggleMenuFile()">FILE</button></li>
        <li title="Generator"><button onclick="ui.toggleMenuGenerator()">CREATE</button></li>
        <li title="Voxelizer"><button onclick="ui.toggleMenuVoxelizer()">VOXELIZE</button></li>
        <li title="Symmetry"><button onclick="ui.toggleMenuSymmetry()">SYMM.</button></li>
        <li title="Model"><button onclick="ui.toggleMenuModel()">MODEL</button></li>
        <li title="Paint"><button onclick="ui.toggleMenuPaint()">PAINT</button></li>
        <li title="Voxels"><button onclick="ui.toggleMenuVoxels()">VOXELS</button></li>
        <li title="Bakery"><button onclick="ui.toggleMenuBakery()">BAKERY</button></li>
        <li title="Bakes"><button onclick="ui.toggleMenuBakes()">BAKES</button></li>
    </ul>
    <ul id="toolbar_L">
        <li>
            <button title="About" onclick="ui.toggleMenuAbout()"><i class="material-icons" style="color:steelblue">help</i></button>
            <button title="Preferences" onclick="ui.toggleMenuPrefs()"><i class="material-icons">settings</i></button>
        </li>
        <li title="Camera"><button onclick="ui.toggleMenuCamera()">CAMERA</button></li>
        <li title="Environment"><button onclick="ui.toggleMenuEnv()">ENV.</button></li>
        <li title="Material"><button onclick="ui.toggleMenuMaterial()">MATERIAL</button></li>
        <li title="Texture"><button onclick="ui.toggleMenuTexture()">TEXTURE</button></li>
        <li title="Render"><button onclick="ui.toggleMenuRender()">RENDER</button></li>
        <li title="Storage"><button onclick="ui.toggleMenuStorage()">STORAGE</button></li>
        <li title="Color Groups"><button onclick="ui.toggleMenuGroups()">GROUPS</button></li>
    </ul>
    <ul id="toolbar_C">
        <li onclick="ui.setMode(0)" class="mode mode_select">MODEL</li>
        <li onclick="ui.setMode(1)" class="mode">BAKERY</li>
        <li onclick="ui.setMode(2)" class="mode">RENDER</li>
    </ul>
    <ul id="toolbar_C_mem">
        <li onclick=""><b>SAVE</b></li>
        <li onclick=""><b>LOAD</b></li>
        <li onclick="memory.undo()"><b>UNDO</b></li>
        <li onclick="memory.redo()"><b>REDO</b></li>
    </ul>
    <ul class="menu_R" id="menu-file">
        <li onclick="ui.toggleMenuFile()"><i class="material-icons">exit_to_app</i> <span>FILE</span></li>
        <li class="spacer"></li>
        <li class="category">PROJECT</li>
        <li><input id="input-project-name" type="text" value="null" minlength="3" maxlength="100" spellcheck="false" placeholder="Project Name"></li>
        <li class="spacer"></li>
        <li><button onclick="project.newBox()">New</button></li>
        <li class="spacer"></li>
        <li><button onclick="document.getElementById('openfile_vbx').click()">Load</button></li>
        <li><button onclick="project.save()">Save As...</button></li>
        <li><button onclick="document.getElementById('openfile_vbx_imp').click()">Import Bakes</button></li>
        <li class="spacer"></li>
        <li><button onclick="document.getElementById('openfile_vox').click()">Load<br>MagicaVoxel</button></li>
        <li class="category">EXPORT</li>
        <li><button onclick="createScreenshot()">Screenshot</button></li>
        <li class="spacer"></li>
        <li><button onclick="project.exportVoxels()">Export Voxels</button></li>
        <li><button onclick="project.exportBakes()">Export Bakes</button></li>
    </ul>
    <ul class="menu_R" id="menu-generator">
        <li onclick="ui.toggleMenuGenerator()"><i class="material-icons">exit_to_app</i> <span>GENERATOR</span></li>
        <li class="category">GRID</li>
        <li>
            <label>&nbsp;X&nbsp;</label> <input id="input-grid-x" type="number" value="10" min="4" max="100"><br>
            <label>&nbsp;Y&nbsp;</label> <input id="input-grid-y" type="number" value="10" min="1" max="100"><br>
            <label>&nbsp;Z&nbsp;</label> <input id="input-grid-z" type="number" value="10" min="4" max="100"><br>
            <input type="checkbox" id="input-grid-fill" checked> <label for="input-grid-fill">Fill Grid</label>
            <div class="flex">
                <button onclick="generator.createGrid()">Grid</button>
                <button onclick="generator.createGrid(true)">Plane</button>
            </div> <div class="flex">
                <button onclick="generator.createSphere()">Sphere</button>
                <button onclick="generator.createRandom()">Rand</button>
            </div>
        </li>
        <li class="category">ISOMETRIC</li>
        <li>
            <label>&nbsp;X Y Z&nbsp;</label> <input id="input-isometric-size" type="number" value="20" min="2" max="100"><br>
            <button onclick="generator.createIsometric()">Isometric</button>
        </li>
        <li class="category">TERRAIN</li>
        <li>
            <label>&nbsp;X&nbsp;</label> <input id="input-terrain-x" type="number" value="50" min="3" max="200"><br>
            <label>&nbsp;Y&nbsp;</label> <input id="input-terrain-y" type="number" value="10" min="1" max="50"><br>
            <label>&nbsp;Z&nbsp;</label> <input id="input-terrain-z" type="number" value="50" min="3" max="200"><br>
            <input type="checkbox" id="input-terrain-grad" checked> <label for="input-terrain-grad">Height Gradient</label>
            <button onclick="generator.createTerrain()">Terrain</button>
        </li>
    </ul>
    <ul class="menu_R" id="menu-voxelizer">
        <li onclick="ui.toggleMenuVoxelizer()"><i class="material-icons">exit_to_app</i> <span>VOXELIZER</span></li>
        <li class="category">3D VOXELIZER</li>
        <li><button onclick="document.getElementById('openfile_objglb').click()">Upload Model</button></li>
        <li><button onclick="voxelizer.pasteModelUrl()">Paste URL</button></li>
        <li><button onclick="voxelizer.pasteObjBase64()">Base64 OBJ</button></li>
        <li><label>Scale&nbsp;&nbsp;</label> <input type="number" id="input-voxelizer-scale" value="40" min="5" max="100"></li>
        <li><label>Dense</label> <input type="number" id="input-voxelizer-dense" value="20" min="1" max="200"></li>
        <li class="category">2D VOXELIZER</li>
        <li><button onclick="document.getElementById('openfile_img').click()">Upload Image</button></li>
        <li><button onclick="voxelizer.pasteBase64Image()">Base64 Image</button></li>
        <li><label>Ratio&nbsp;&nbsp;</label> <input type="number" id="input-voxelizer-ratio" value="5.0" min="0.1" max="20" step="0.1"></li>
        <li><input type="checkbox" id="input-voxelizer-zup" checked> <label for="input-voxelizer-zup">Z-Up</label></li>
    </ul>
    <ul class="menu_R" id="menu-symmetry">
        <li onclick="ui.toggleMenuSymmetry()"><i class="material-icons">exit_to_app</i> <span>SYMMETRY</span></li>
        <li class="category">AXIS</li>
        <li><button id="btn-symm-axis" onclick="symmetry.switchAxis()">None</button></li>
        <li class="category">SYMMETRIZE</li>
        <li onclick="symmetry.symmetrizeVoxelPositions(1)"><button>Pos (+) > Neg (-)</button></li>
        <li onclick="symmetry.symmetrizeVoxelPositions(-1)"><button>Neg (-) > Pos (+)</button></li>
        <li class="category">MIRROR</li>
        <li onclick="symmetry.mirrorVoxelPositions()"><button>Mirror</button></li>
        <li class="category">DELETE</li>
        <li onclick="symmetry.deleteHalfVoxels(-1)"><button>Pos (+) Half</button></li>
        <li onclick="symmetry.deleteHalfVoxels(1)"><button>Neg (-) Half</button></li>
        <li class="category">PIVOT CENTER</li>
        <li><input type="checkbox" id="input-symm-center" onclick="helper.setSymmPivot()"> <label for="input-symm-center">World Center</label></li>
    </ul>
    <ul class="menu_R" id="menu-model">
        <li onclick="ui.toggleMenuModel()"><i class="material-icons">exit_to_app</i> <span>MODELING</span></li>
        <li class="category">DRAW</li>
        <li><button onclick="tool.toolSelector('add')" class="tool_add">Add</button></li>
        <li><button onclick="tool.toolSelector('remove')" class="tool_remove">Remove</button></li>
        <li class="category">BOX</li>
        <li><button onclick="tool.toolSelector('boxadd')" class="tool_boxadd">Box Add</button></li>
        <li class="spacer"></li>
        <li><label>Height</label> <input id="input-boxtool-height" type="number" value="0" min="0" max="100"></li>
        <li><button onclick="tool.toolSelector('boxrem')" class="tool_boxrem">Box Remove</button></li>
        <li><button onclick="tool.toolSelector('fill')" class="tool_fill">Fill (slow)</button></li>
        <li class="category">TRANSFORM</li>
        <li><button onclick="tool.toolSelector('pull')" class="tool_pull">Pull Voxel</button></li>
        <li><button onclick="tool.toolSelector('pullcolor')" class="tool_pullcolor">Pull Color Group</button></li>
        <li class="category">WORKPLANE</li>
        <li><input type="checkbox" id="input-helper-workplane" onclick="helper.toggleWorkplane()"> <label for="input-helper-workplane">Use Workplane</label></li>
        <li><button onclick="helper.resetWorkplane()">Reset Workplane</button></li>
    </ul>
    <ul class="menu_R" id="menu-paint">
        <li onclick="ui.toggleMenuPaint()"><i class="material-icons">exit_to_app</i> <span>PAINTING</span></li>
        <li class="category">PAINT</li>
        <li><button onclick="tool.toolSelector('paint')" class="tool_paint">Paint</button></li>
        <li class="category">FILL</li>
        <li><button onclick="tool.toolSelector('boxpaint')" class="tool_boxpaint">Box Paint</button></li>
        <li><button onclick="tool.toolSelector('bucket')" class="tool_bucket">Bucket</button></li>
        <li class="category">PICK COLOR</li>
        <li><button onclick="tool.toolSelector('eyedrop')" class="tool_eyedrop">Eyedropper</button></li>
    </ul>
    <ul class="menu_R" id="menu-voxels">
        <li onclick="ui.toggleMenuVoxels()"><i class="material-icons">exit_to_app</i> <span>VOXELS</span></li>
        <li class="category">DISPLAY</li>
        <li><input type="checkbox" id="input-voxels-onion" onclick="builder.toggleOnionSkin()"> <label for="input-voxels-onion">Onion Skin</label></li>
        <li class="category">NORMALIZE</li>
        <li onclick="builder.normalizeVoxelPositions(true)"><button>Normalize<br>Voxel Positions</button></li>
        <li class="category">OPTIMIZE</li>
        <li onclick="builder.reduceVoxels()"><button>Reduce Voxels</button></li>
        <li onclick="builder.removeDuplicatesFunc()"><button>Kill Duplicates</button></li>
    </ul>
    <ul class="menu_R" id="menu-bakery">
        <li onclick="ui.toggleMenuBakery()"><i class="material-icons">exit_to_app</i> <span>BAKERY</span></li>
        <li class="category">ADD BAKE</li>
        <li><button onclick="bakery.newBake()">New Bake</button></li>
        <li><button onclick="tool.toolSelector('bakecolor')" class="tool_bakecolor">Bake Color</button></li>
        <li class="category">BATCH BAKE</li>
        <li><button onclick="bakery.bakeAllColors()">Bake All Colors</button></li>
        <li class="category">CLEAR</li>
        <li><button onclick="bakery.clearBakes(true)">Clear Bakes</button></li>
        <li class="category">OPTIONS<li>
        <li><input type="checkbox" id="input-bakery-uvs"> <label for="input-bakery-uvs">Per-Face UVs</label></li>
    </ul>
    <ul class="menu_R" id="menu-bakes">
        <li onclick="ui.toggleMenuBakes()"><i class="material-icons">exit_to_app</i> <span>BAKES</span></li>
        <li class="category">REPLICATE</li>
        <li><button onclick="bakery.cloneSelected()">Clone</button></li>
        <li><button onclick="bakery.instanceSelected()">Instance</button></li>
        <li class="category">MERGE TOOL</li>
        <li><button class="tool_merge" onclick="toolBakery.toolSelector('merge')">Pick</button></li>
        <li><button onclick="toolBakery.mergeBakes()">Merge Selected</button></li>
        <li><button onclick="toolBakery.cancelTools()">Cancel</button></li>
        <li class="category">DELETE</li>
        <li><button onclick="bakery.deleteSelected()">Delete Bake</button></li>
    </ul>
    <ul class="menu_L" id="menu-camera">
        <li onclick="ui.toggleMenuCamera()"><i class="material-icons">exit_to_app</i> <span>CAMERA</span></li>
        <li class="category">FOCUS</li>
        <li><button onclick="camera.frame()">Frame Camera</button></li>
        <li class="category">VIEW</li>
        <li><label>Field of View</label> <input id="input-camera-fov" oninput="camera.setFov(this)" type="range" value="0.8" min="0.1" max="1.0" step="0.01"></li>
        <li><button id="btn-ortho" onclick="camera.switchOrtho()">Perspective</button></li>
        <li class="category">CONTROLS</li>
        <li><input type="checkbox" id="input-autorotate" onclick="camera.toggleCameraAutoRotation()"> <label for="input-autorotate">Auto Rotate</label></li>
    </ul>
    <ul class="menu_L" id="menu-env">
        <li onclick="ui.toggleMenuEnv()"><i class="material-icons">exit_to_app</i> <span>ENVIRONMENT</span></li>
        <li class="category">BACKGROUND</li>
        <li><input type="checkbox" id="input-env-bgcheck" onclick="scene.autoClear = this.checked"> <label for="input-env-bgcheck">Enable</label></li>
        <li><input type="color" id="input-env-background" value="#6C6F7A"></li>
        <li class="category">HDRI</li>
        <select onchange="hdri.loadHDR(this.options[this.selectedIndex].value)">
            <option value="">Presets</option>
            <option value="assets/venice_sunset_1k.hdr">Venice Sunset (Default)</option>
            <option value="https://media.githubusercontent.com/media/KhronosGroup/glTF-Sample-Environments/master/footprint_court.hdr">Footprint Court</option>
            <option value="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/pedestrian_overpass_1k.hdr">Pedestrian Overpass</option>
            <option value="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/blouberg_sunrise_2_1k.hdr">Blouberg Sunrise</option>
            <option value="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/moonless_golf_1k.hdr">Moonless Golf</option>
            <option value="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/quarry_01_1k.hdr">Quarry</option>
            <option value="https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/equirectangular/royal_esplanade_1k.hdr">Royal Esplanade</option>
        </select>
        <li><button onclick="document.getElementById('openfile_hdr').click()">Load HDRI</button></li>
        <li><button onclick="hdri.unloadHDR(true)">Unload</button></li>
        <li><input type="checkbox" id="input-hdri-toggle" onclick="hdri.toggleSkybox(this.checked)"> <label for="input-hdri-toggle">Display</label></li>
        <li><input type="range" id="input-hdri-blur" value="0.08" min="0" max="1.0" step="0.01" oninput="hdri.setBlurAmount(this.value)"></li>
        <li class="category">LIGHT</li>
        <li><input type="color" id="input-env-lightcolor" value="#CCCCCC"></li>
        <li><label>Intensity</label><input type="range" value="0.4" min="0" max="1.0" step="0.01" oninput="updateLightIntensity(this.value)"></li>
        <li><label>Angle</label><input type="range" value="120" min="0" max="360" step="10" oninput="updateLightAngles(this.value)"></li>
        <li><input type="checkbox" id="input-display-shadows" onclick="enableShadows(this.checked)" checked> <label for="input-display-shadows">Shadows</label></li>
    </ul>
    <ul class="menu_L" id="menu-material">
        <li onclick="ui.toggleMenuMaterial()"><i class="material-icons">exit_to_app</i> <span>PBR MATERIAL</span></li>
        <li class="category">UPDATE</li>
        <li><input type="checkbox" id="input-material-autoupdate" checked> <label for="input-material-autoupdate">Auto Update</label></li>
        <li class="category">PROPERTIES</li>
        <li><label>Roughness</label><input id="input-material-roughness" oninput="bakery.setMaterial('roughness')" type="range" value="0.95" min="0" max="1.0" step="0.01"></li>
        <li><label>Metallic</label><input id="input-material-metallic" oninput="bakery.setMaterial('metallic')" type="range" value="0.4" min="0" max="1.0" step="0.01"></li>
        <li><label>Alpha</label><input id="input-material-alpha" oninput="bakery.setMaterial('alpha')" type="range" value="1.0" min="0.1" max="1.0" step="0.01"></li>
        <li><label>Emissive</label><input type="color" id="input-material-emissive" value="#000000"></li>
        <li class="category">REPLICATE</li>
        <li><button onclick="bakery.getMaterial()">Get Material</button>
        <li><button onclick="bakery.setMaterialAll()">Set Material</button>
        <li class="spacer"></li>
        <li><button onclick="bakery.updateVertexColors()">Set Vertex Colors</button></li>
    </ul>
    <ul class="menu_L" id="menu-texture">
        <li onclick="ui.toggleMenuTexture()"><i class="material-icons">exit_to_app</i> <span>TEXTURE</span></li>
        <li class="category">PATTERN</li>
        <li>
            <div class="flex">
                <button onclick="material.setPBRTexture(0); bakery.replaceTexture()">Solid</button>
                <button onclick="material.setPBRTexture(1); bakery.replaceTexture()">Outline</button>
            </div> <div class="flex">
                <button onclick="material.setPBRTexture(2); bakery.replaceTexture()">Grid</button>
                <button onclick="material.setPBRTexture(3); bakery.replaceTexture()">Check</button>
            </div>
        </li>
        <li class="category">IMPORT</li>
        <li><button onclick="document.getElementById('openfile_tex').click()">Add Texture</button></li>
        <li class="spacer"></li>
        <li id="texturepresets"></li>
        <li ondrop="material.deleteTexture(event)" ondragover="event.preventDefault()"><div class="dropzone"> drop here to delete</div></li>
        <li class="category">REPLICATE</li>
        <li><button onclick="bakery.replaceTextureAll()">Apply To All</button>
    </ul>
    <ul class="menu_L" id="menu-render">
        <li onclick="ui.toggleMenuRender()"><i class="material-icons">exit_to_app</i> <span>RENDER</span></li>
        <li class="category">POST PROCESS</li>
        <li><label>Contrast</label> <input id="input-pipeline-contrast" oninput="pipeline.updateProps()" type="range" value="1.0" min="0" max="3.0" step="0.01"></li>
        <li><label>Exposure</label> <input id="input-pipeline-exposure" oninput="pipeline.updateProps()" type="range" value="1.5" min="0" max="3.0" step="0.01"></li>
        <li><label>Hue</label> <input id="input-pipeline-hue" oninput="pipeline.updateProps()" type="range" value="180" min="0" max="360" step="1"></li>
        <li class="spacer"></li>
        <li><input type="checkbox" id="input-pipeline-bloom" onclick="pipeline.init()"> <label for="input-pipeline-bloom">Enable Bloom</label></li>
        <li><input type="checkbox" id="input-pipeline-dof" onclick="pipeline.init()"> <label for="input-pipeline-dof">Enable DOF</label></li>
        <li><input disabled id="input-pipeline-dofdist" oninput="pipeline.updateProps()" type="range" value="450" min="0" max="1000" step="1"></li>
        <li><label>Sharpen</label> <input id="input-pipeline-sharpen" oninput="pipeline.updateProps()" type="range" value="0.2" min="0" max="1.0" step="0.01"></li>
        <li><label>Film Grain</label> <input id="input-pipeline-grain" oninput="pipeline.updateProps()" type="range" value="5" min="0" max="10" step="1"></li>
        <li><label>Vignette</label> <input id="input-pipeline-vignette" oninput="pipeline.updateProps()" type="range" value="1" min="0" max="10" step="1"></li>
        <li><label>Chromatic Aberr.</label> <input id="input-pipeline-chromatic" oninput="pipeline.updateProps()" type="range" value="1" min="0" max="50" step="1"></li>
    </ul>
    <ul class="menu_L" id="menu-storage">
        <li onclick="ui.toggleMenuStorage()"><i class="material-icons">exit_to_app</i> <span>STORAGE</span></li>
        <li class="category">SNAPSHOTS</li>
        <li class="storage"><img><div class="flex"><button>CLEAR</button><button>SAVE</button></div></li>
        <li class="spacer"></li>
        <li class="storage"><img><div class="flex"><button>CLEAR</button><button>SAVE</button></div></li>
        <li class="spacer"></li>
        <li class="storage"><img><div class="flex"><button>CLEAR</button><button>SAVE</button></div></li>
        <li class="spacer"></li>
        <li class="storage"><img><div class="flex"><button>CLEAR</button><button>SAVE</button></div></li>
    </ul>
    <ul class="menu_L" id="menu-groups">
        <li onclick="ui.toggleMenuGroups()"><i class="material-icons">exit_to_app</i> <span>COLOR GROUPS</span></li>
        <li class="category">ISOLATE</li>
        <li><button onclick="tool.toolSelector('isolatecolor')" class="tool_isolatecolor">Isolate Color</button></li>
        <li><button onclick="builder.setVoxelsVisibilityAndUpdate(true)">Unisolate</button>
        <li class="category">HIDE</li>
        <li><button onclick="tool.toolSelector('hidecolor')" class="tool_hidecolor">Hide Color</button></li>
        <li><button onclick="tool.toolSelector('boxhide')" class="tool_boxhide">Box Hide</button></li>
        <li><button onclick="builder.setVoxelsVisibilityAndUpdate(true)">Unhide All</button>
        <li class="category">DELETE</li>
        <li><button onclick="builder.deleteHidden()">Delete Hidden</button>
    </ul>
    <ul class="menu_L" id="menu-prefs">
        <li onclick="ui.toggleMenuPrefs()"><i class="material-icons">exit_to_app</i> <span>PREFERENCES</span></li>
        <li class="category">GENERAL</li>
        <li><input type="checkbox" id="input-prefs-nointro" onclick="preferences.setNoIntro(this.checked)"> <label for="input-prefs-nointro">No Intro</label></li>
        <li><input type="checkbox" id="input-prefs-nohover" onclick="preferences.setNoHover(this.checked)"> <label for="input-prefs-nohover">No Hover Menu</label></li>
        <li><input type="checkbox" id="input-prefs-fullscreen" onclick="toggleFullscreen()"> <label for="input-prefs-fullscreen">Fullscreen</label></li>
        <li class="category">SCRIPTS</li>
        <li><button onclick="forceDownload('https://raw.githubusercontent.com/nimadez/voxel-builder/main/scripts/blender-importer.py')">Blender Importer</button></li>
        <li><button onclick="forceDownload('https://raw.githubusercontent.com/nimadez/voxel-builder/main/scripts/voxel-builder.py')">Desktop Installer</button></li>
        <li class="category">PERFORMANCE</li>
        <li><button onclick="clearCache()">Clear Cache</button></li>
    </ul>
    <ul class="menu_L" id="menu-about">
        <li onclick="ui.toggleMenuAbout()"><i class="material-icons">exit_to_app</i> <span>ABOUT</span></li>
        <li class="category">HELP</li>
        <li><button onclick="ui.toggleHelp()">Documentation</button></li>
        <li class="spacer"></li>
        <li class="about">
            <label>Version</label>
            <br>4.0.1 RC 2023
            <br>&#8627; <a href="https://github.com/nimadez/voxel-builder/">Repository</a>
            <br><label>Developer</label>
            <br>&#8627; <a href="https://nimadez.github.io/">Nima Dezfuli</a>
            <br>©2019
        </li>
        <li class="category">SAMPLES</li>
        <li>
            <select onchange="project.loadFromUrl(this.options[this.selectedIndex].value)">
                <option value="samples/startup.vbx">Startup</option>
                <option value="samples/test_archinterior.vbx">Arch Interior</option>
                <option value="samples/test_boxtool.vbx">Box Tool</option>
                <option value="samples/test_filltool.vbx">Fill Tool</option>
                <option value="samples/test_pulltools.vbx">Pull Tools</option>
                <option value="samples/test_visibility.vbx">Visibility</option>
                <option value="samples/test_symmetry.vbx">Symm Odd</option>
                <option value="samples/test_symmetry2.vbx">Symm Even</option>
                <option value="samples/test_voxelizer_2d.vbx">Voxelizer 2D</option>
                <option value="samples/test_pixelmonk.vbx">Pixel Monk 2D</option>
                <option value="samples/test_faceuv.vbx">Face UV</option>
                <option value="samples/test_texture.vbx">Texture (old startup)</option>
            </select>
            <select onchange="project.loadFromUrl(this.options[this.selectedIndex].value)">
                <option value="">MagicaVoxel</option>
                <option value="samples/mv_charactercat_ephtracy.vbx">Character Cat @ephtracy</option>
                <option value="samples/mv_tankdestroyer_arsgametm.vbx">Tank Destroyer @arsgametm</option>
                <option value="samples/mv_skyscraper_kluchek.vbx">Skyscraper @kluchek</option>
                <option value="samples/mv_odyssey_kluchek.vbx">Odyssey @kluchek</option>
            </select>
        </li>
        <li class="category">EXTRAS</li>
        <li><button onclick="window.open('https://nimadez.github.io/voxel-builder/extras/asset-viewer/', '_blank').focus();">Asset Viewer</button></li>
        <li><button onclick="window.open('https://nimadez.github.io/voxel-builder/extras/vi2xel/', '_blank').focus();">V I ² X E L</button></li>
        <li class="category">DEV STUFF</li>
        <li><button onclick="ui.toggleDebugMode()">Debug Layer [O]</button></li>
    </ul>
    <ul id="hover">
        <li title="Free camera" class="tool_camera" onclick="tool.toolSelector('camera')" onpointerdown="ui.dragElement(this)"><i class="material-icons">control_camera</i></li>
        <li title="Box Paint" class="tool_boxpaint" onclick="tool.toolSelector('boxpaint')"><i class="material-icons">imagesearch_roller</i></li>
        <li title="Box Add" class="tool_boxadd" onclick="tool.toolSelector('boxadd')"><i class="material-icons">add</i></li>
        <li title="Bucket" class="tool_bucket" onclick="tool.toolSelector('bucket')"><i class="material-icons">format_color_fill</i></li>
        <li title="Eyedropper" class="tool_eyedrop" onclick="tool.toolSelector('eyedrop')"><i class="material-icons">colorize</i></li>
        <li title="Box Remove" class="tool_boxrem" onclick="tool.toolSelector('boxrem')"><i class="material-icons">remove</i></li>
        <li title="Paint" class="tool_paint" onclick="tool.toolSelector('paint')"><i class="material-icons">brush</i></li>
        <li title="Add" class="tool_add" onclick="tool.toolSelector('add')"><i class="material-icons">create</i></li>
        <li title="Remove" class="tool_remove" onclick="tool.toolSelector('remove')"><i class="material-icons">clear</i></li>
    </ul>
    <div id="colorpicker0"><input type="color" id="input-color-0" value="#6B8EB6"></div>
    <div id="colorpicker1"><input type="color" id="input-color-1" value="#6B8EB6"></div>
    <div id="axisview-hitbox" onclick="camera.frame()"></div>
    <div id="btn-helper-symmetry" title="Symmetry" onclick="symmetry.switchAxis()">S</div>
    <div id="btn-helper-workplane" title="Workplane" onclick="helper.toggleWorkplane()"><i class="material-icons">border_inner</i></div>
    <!-- dynamic -->
    <div id="marquee"></div>
    <div id="palette"><canvas id="canvas_palette"></canvas></div>
    <div id="reticle"><i class="material-icons">add</i><span></span><span></span></div>
    <div id="info"><span>0</span> FPS | <span>0</span> | <span>0</span></div>
    <div id="loadingscreen"><div class="logo"><div class="cube"><div class="cube-faces"><div class="cube-face bottom"></div><div class="cube-face top"></div><div class="cube-face left"></div><div class="cube-face right"></div><div class="cube-face back"></div><div class="cube-face front"></div></div></div>
    </div><div class="progress">- PLEASE WAIT -</div></div>
    <div id="confirm"><span>title here</span> <button>Cancel</button> <button>Ok</button></div>
    <div id="confirmblocker"></div>
    <div id="notifier"></div>
    <div id="help"></div>
    <div id="intro"><button onclick="preferences.setNoIntro(true)">NO INTRO NEXT TIME?</button><br>VOXEL BUILDER<br>4.0.1 RC 2023</div>
    <!-- hidden -->
    <input style="display: none" type="file" id="openfile_vbx" accept=".vbx" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_vbx_imp" accept=".vbx" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_vox" accept=".vox" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_objglb" accept=".obj,.glb" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_img" accept=".jpg,.png,.svg" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_tex" accept=".jpg,.png" onclick="this.value = null">
    <input style="display: none" type="file" id="openfile_hdr" accept=".hdr" onclick="this.value = null">

<script>
// -------------------------------------------------------
// Initialize

const ENVMAP = "assets/venice_sunset_1k.hdr";
const PARTICLE = "data:image/png;base64,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";
const SNAPSHOT = 'data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 90%22><text x=%220.18em%22 y=%221.1em%22 font-size=%2260%22 style="filter: grayscale(); opacity: 0.1;">❌</text></svg>';
const TEX_PATTERNS = [
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAMAAABFaP0WAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo4ODg4NzQ1MjgxNEExMUVEQjVDQTlGMzY0ODY0NzdERiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo4ODg4NzQ1MzgxNEExMUVEQjVDQTlGMzY0ODY0NzdERiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjg4ODg3NDUwODE0QTExRURCNUNBOUYzNjQ4NjQ3N0RGIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjg4ODg3NDUxODE0QTExRURCNUNBOUYzNjQ4NjQ3N0RGIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+xCfx0wAAAAZQTFRF////AAAAVcLTfgAAAA5JREFUeNpiYAABgAADAAAGAAHgQhFOAAAAAElFTkSuQmCC",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAADwCAMAAACg0xNxAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MURGNUY4RDQ4MTRBMTFFRDg1OTZGOUQyMjQ2RDM0M0IiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MURGNUY4RDM4MTRBMTFFRDg1OTZGOUQyMjQ2RDM0M0IiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFlZjEwNWVjLTQxZTMtZDQ0NS04NjUzLTA4NTlhYmMzMmY4NSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7Mp3ODAAAABlBMVEXu7u7///8o06qaAAAAaElEQVR42uzZMQ0AAAjAMPBvGgc8cJDQCaiBRbws9wICgUAgEAgEAoFAIBAIBAKBQCAQOAflpwCBQCAQCAQCgUAgEAgEAoFAIBAI7EH5KUAgEAgEAoFAIBAIBAKBQCAQCAQCe/B2JcAAIghB7N/vJckAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAADwCAMAAACg0xNxAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NUE0MjE1NEY4MTRBMTFFRDgwMkJFMDA0NDAyMEZBMjQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NUE0MjE1NEU4MTRBMTFFRDgwMkJFMDA0NDAyMEZBMjQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjcyNzA3OTRhLTljOTgtNzM0ZC04MjgxLTZkNjBjOTljYTM5ZSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5nAPaYAAAAD1BMVEX6+vrw8PDv7+/u7u7////hEbC4AAAAhElEQVR42uzZsQ3AIAxFQRPYf2aUDSw5RcD3a+tq0Iv58eIIcCU2UlcLCAQCgUAgEAgEvu/sxJ7UVfgFAIFAIBAIBAKBPcGGtUJPAQKBQCAQCAQCu4F6ChAIBAKBQCAQCCyC8oeeAgQCgUAgEAgEXg/qKUAgEAgEAoFAILAI/jsubAEGAJbMGzlAxOE3AAAAAElFTkSuQmCC",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAADwCAMAAACg0xNxAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NkJEOEMzNzI4MTRBMTFFRDg4QTJGODA0OTc0NEY4OEQiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NkJEOEMzNzE4MTRBMTFFRDg4QTJGODA0OTc0NEY4OEQiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmM0YmQ5NDcyLWM2YWEtNjc0ZC05ODMzLTZjOGE1ZDhhYTg3MyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6Wa8daAAAACVBMVEXu7u7////19fVT5JFBAAAAc0lEQVR42uzZsREAMAgDMWD/oVnBTYokcs2JAb7qy02yjgYEAoFAIBAIBAJPgNFp9HWAQCAQCAQCgUDgFaDpKUAgEAgEAoFAIFBPAQKBQCAQCAQCgXqKngIEAoFAIBAIBAL1FCAQCAQCgUAgEPhuT1kBBgAiG2LjsAHS6QAAAABJRU5ErkJggg==",
];
const TEX_PRESETS = [
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6RDc0OUI1NzM1RkYxMTFFRDlENDNDMTVFMEE4NDM4N0QiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6RDc0OUI1NzI1RkYxMTFFRDlENDNDMTVFMEE4NDM4N0QiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjY2MjA4ZTcyLWY5NzctNDM0Mi05MDk0LTdkYWQwOTU3NDk2ZCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6/aB5VAAAAeFBMVEVvr0VhoTdoqD5pqT9trUNqqkB1tUtiojiHh4eKuVpsbGxrq0F0tEqDslN0WESQv2CTwmOcy2ySwWJ/v1VgoDaNvF1QkCaXxmdkpDqBsFFwsEZxsUdXly1mpjxnpz1fnzVzs0l+vlR2tkxsrEK5hVxZPSmWbEp5VTrV5Zr8AAABOElEQVR42tSPaXLDIAyFBXbiLE6T7iugxYL737ASzrS5QH907NEgwfveE4wkQ94wSYGUkDMcWQJaO8UBZS9bmBkkQRHiTR4Cj7AV5FOIXIgxSGYYGQZxBgIzcgTKZAJjyHQy1tZeDDcuheCYzSWn0xSFBX3Mpv1xmdxlLxRiKFSQJUdjhJXBPensDEAzOkdakxJToiuDr0klXaIVwr3IBAmREtDtLpSRIhVBDGQuM2P63fal53g/aZzK5ezbHuFZ798G/dD58eFVv54U9KD6qapFR22qDWqri9ZmZz20aoOm1WbW2qy1tsBidWeHxX+7Aj/bG3vUawWv9mnzvjmjutrlXWeS2vVVFzOru9Yl1W4OJjF7dds+aVeRS9qdE3VRU7qLLgbXnmK19Ri7tqZYGf81+l9AvwUYAFsRXgO8yBShAAAAAElFTkSuQmCC",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA21pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OTBBOTEyQTk2OTFDMTFFREJCQTQ4MEQxMEI3NzhFRUUiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTBBOTEyQTg2OTFDMTFFREJCQTQ4MEQxMEI3NzhFRUUiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjEyNGM5YzNiLTkzYzUtMTQ0OC1iNDhkLWQ5MjliMmE1NTI2NCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo2OEMyMEU3NjYwMzkxMUVEQkUwRjg5QzQ0NzlGMTcwNyIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PrymvYUAAAAwUExURTAgLEk8RbKqqmFVXYp9gv///x0dHSwsLC0tLS4uLi8vLzAwMDExMTIyMjMzMzk5OXQCvBgAAAAGdFJOU///////ALO/pL8AAADJSURBVHja1JIJFsMgCERHxyyatL3/bQuoaNJcoCjy/AZEAuJVEmK6CBWQpmoaSIvMyCX+HUjySJmm/H1tWdcyZC3IH5JBhq3YARIBIQTYyAJso0oIwsG2NRWWFTQoy3t2US04wwzkljyfq8s+n2tQi9FFY7w0H9QrZNmuMfSsiMJVXID5FmRsJ064lOOpHaQS1ghmDGhVUzMVeD85qP4daPnNX7/pv0EqxNF0Zm+g+ow8Oux5dODXsomDW6aWaGrmoR08QJOvAAMAz54JCo4zaZIAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1Rjk4MTlBNTY5MTkxMUVEODk0QUY2MTk2RkMzRkQ5QSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo1Rjk4MTlBNjY5MTkxMUVEODk0QUY2MTk2RkMzRkQ5QSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjVGOTgxOUEzNjkxOTExRUQ4OTRBRjYxOTZGQzNGRDlBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjVGOTgxOUE0NjkxOTExRUQ4OTRBRjYxOTZGQzNGRDlBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+kl/wtwAAABhQTFRFZSwoXSQkpmFFjkEwdTAsw4JVNBAcTRwgnCGS7gAAAKxJREFUeNrsklsSQyEIQ+Hy2v+OS0At3ukSmh/GY8TISO7swZHKGu7k+tjTQnUKffRIjAscg1gdOR4TC+ICZRHrI5bARLGEI9qBhb7B5TBrz24qKdtNax8CqBxSUpGdw44AvDeXCUfw6H5+Vv8JUhxEADWgnhjzF8QC4ROkaM0UOOaQUaiaDtBN68IJrhwdbOSYoK7NpneO7HHnqFtmjlew9R1Wjv//GN/hI8AAMpwNYRsTIbAAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozNDM5YTY3ZS1jZmQwLTBkNDAtYjcxZC02MDFjODZkYWYzZjYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjkwMjFBNjc2Q0Q3MTFFRDhFRTVGNjNCMTNBODJEMzkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjkwMjFBNjY2Q0Q3MTFFRDhFRTVGNjNCMTNBODJEMzkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjJlOTlkZGI4LWUxN2UtNjc0NC04YmIzLTQ1YWNhNjBmMTY2YiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozNDM5YTY3ZS1jZmQwLTBkNDAtYjcxZC02MDFjODZkYWYzZjYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4OtNUFAAAACVBMVEW77fCr3uajzNZQMo+CAAAAPklEQVR42mJgZGRCAoyMDExMDIwILpAHY8BIBpgcTCsDFjMYcZnBQJEZDKS4gwGfO0jwy2h4jIYHTB1AgAEATlgFNRLiuuEAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0VGMEM5QUU4MTRCMTFFREIxQzRBNTlENjVEQzFCRTYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0VGMEM5QUQ4MTRCMTFFREIxQzRBNTlENjVEQzFCRTYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmNjYmFmOTc0LWI2YWItZjg0OC04ZWZkLTQ1YmI1ZDM3Yjk2MyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5nyFTOAAABgFBMVEVNWTSSEgJWYUV5entiaVeUkpU8RS1xcXGXKxGlFQR0dHSFCwHkIhKtFQR0hlDaHgc2PShUV01UZj2CEQTXIgt8EQR6RCdiY19yCwN7DQNubW6EgYRtDAKBfoKkGASVCgBabTuNEQBcW1lidUOzGQtWAgF+fH5rfUyqGQRta21wc2uZFQZTUlN+Qzi4HAxwbnCIEQJqamqDRj1TXFGlEwmyFQVjBQFSXjyPEQWXFQFNTU2bFgeaFwKeFgWeFQKqFQlBQD9wBwBqa2KsHQliFQ1UaDhATSymEAJycHVrBgFOU0N0dnKRGAKJhoqNGQlxdHGMEgrfJhC/GQhua3CSj5Jna2ZfcEJGTzWYEwRYDwuZEAWWFAh+DQh3dnacDwKXlJdoCQBYXFNXWVehEgVOAABecD2RkJCpHRJ7fndnZ2ezGxB4eHh9f35UYzqNFAdvcHR3BwB9IA5+gIBsa21sbGxuaWxub2uKbldcZE9nfER3e3OuJQ2XGQe6FQXHJRNtCgADdoGmAAACvElEQVR42iyQC1PaQBSFb4oQSYg8ApIFEtny1IAEKwhCEERF8VXQAoIRBLSlCsWqrW1t89e7o97ZmZ37zd6z51ywu080zQtzfTp8aDQaT6HpfmTEG2+jP0ouJrSwBjB20wSM1x1j/yatPQE47hlG9HZtjsYm0xw3AK78D4QYi8njhKkRmYP3nm3/NsNcF3c99O1aYA5iDJ0Y3TPh4ihpCkTIi9j6a8XGPxgargIQS4je61PjYfHKT2s34RmAtV+Nk32xa/JH/EsGLUy+/RbRHhijzeGPLDVniI+l+/3Eiw/HDL1PRi7dD17DSOzafu+4GZv9O/Q9DK15RZN998unkcEEYH9kPKaq2OhrNG1rOgIAbk/C/uSO9J+q9uo7xxj67kXRsBju2o6JhumDgWRhGM3r3bncvU2ODM1tqN4zJyyIgb7Bc2zbyXIA2WTiD2va67tsRSWW46BmGQosP3SFSnovE7RYIMgOh+n0yykN02wJnCg0VNIhvafrvRBLDcCJeSXdIy0pgcq1wal0yqzvpWcxbnHgfJb/sXzpSPG5MKbyBKjtFl/qseWSwFM5qU6ARGGko48lpGAl8xdq+UKLEIyQQrXwxAy1tkrJLYwxomRpVa1AbVnKXljYVnbakaJliVhXCoWatWLmKlw0GpVS8HOeVHwlHo+Te2VlHs44rv6X4waDSqpi5bgKnJmj9Q11wsqyat4oy1nYMpejksy7fAhT6lGHgFRUymVcCPFI6QirA7irR2Uk+AQkCOi8HQzCLHeU4YXX9HtfJ1mYNZ8rb0DnMX6G2Quqdf4GplimCMhLOV7wTXXflCTKEw1zcJVkfXbpCqZklgCyD5dPR591RHUOnHDHlXNkH4jvlcjEVIati1wrlyH6yoRSByoLZ9ZUXhksU5ifqoVyQYWtzEF2w7qcVxcWJEnKL/wXYAD7zZrdqiCQKgAAAABJRU5ErkJggg==",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6ODY3RTRCNzY4MTUwMTFFRDlEQkNFRDhCQkNENDlBNkUiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6ODY3RTRCNzU4MTUwMTFFRDlEQkNFRDhCQkNENDlBNkUiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmE2MjNhNDkzLTgxYTMtZTY0NS1hNjkzLWIxMGJlN2ZkYTZiNyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz7ewuHUAAABgFBMVEXFWQCnKwBaAwP1tjrLewnuni7trSqzOwBxMjKrMgBmAgF2AQHlkh6JGACeKgCzVAC6PADekCSrSwDHSAfbiReWFhd3LCxHFBXkliWlMwDWhhXgjhrpliHtnCXysC5SGxvsmSKsOgDtmiRkKCiUJADejBm7RA1RFBO9MTFYISGzNACyTgCDQUHRgxGkNA3yszeXHgBeHR/qmCJsMjH2u0S+VQC9UgDztDitIyHUhBO8WACaJADsrzPpmyW6UQCpPA20XA2/YQ3ztDbgkB1kJyfnlB/omSrOgBPvri3ZiRi4VQDwsDHcihhtJCOpHyD0tDV2MC2NIACdKg3ikBvXix2vUABnJydnKilYDw5bDw+7TwBZHyF/AAHfjhyoIR9aIB/JeAdpJidoKSfRgBDCQACwUw2sQxpgHRysHx/llShwMDGzOw3nnDPHYg25Pw3Ofg7SfxGwQA2/RADYiBZ4LzCXKQCuLwBWGRm6LzCeMg3QWwDkkBy6YA3SgxXThhzqqiiIMcYWAAACuklEQVR42hyPCVvaQBCGJxs0mzugKQ1HQhIwHIrKWaQeFUFELSiCoiherUer1qrQVlv/ehd3n5nZne/Zd76F7253ZmRkNVOpXGXcO/8y4C64XOujeSuyMe7K07QF7rvjakgI0anm6nSgFNDh42jVEprjLp3WrchawQUj5RBtCXfTViBFv/97Nw2V8R+EsW6VIw8lXa9bUPEfT6fKZX2+6XsNBgQd8vVlokamXqvroabvmDAOBTpYKuWtVJAOHR5X4apwt6bX6eCz4C8s13XCeHBVrbJAp/y+aqocpCFD5j8/FHxDl8LDm4+yHvITRiigz+/s5ImPjSmiBp8PD306qTDSjOStoKVHzghD8OmEQQdD/g1XlaZLPt+ZC9TPZHePoqo6PEUvoaseRYcR/aD+il6qPHB8V+2qapfn+Wi3yyPgOX64uhynkkAIOmhYSHQ4nqQ9cJw91JlF6MJB5N6LgXNgc066d3IQQ52Lnp0G3OugwW4ad9BjG3GPbbCNk4ZtDDo818An3OY1oBM8iW0v2nx3irFDpsxiG+O2FzUmMR54vQPyBDVOB47XSLdJihng2A2EsO0YhoPta9uBA7zbeJzEpBFbITQHDMKaPDV6hpfouG2DYRDoYCV94DVWMLZt+JpM3kzcb78sTtwuJZPbL/CtKM5kE8BIVF8EqJnwWxT3FeVc1ijqD6OZHvji8TDxOCV65Nx5X9oSYYJVaoo2IzMsM2cWZ7KwGJ4Rc/stTZIkdsHTMmGREoHR2ISpSB5T03JwU8sy8ad40ZMAjaXEIUOrjbFMjWF+gsKKHkiGRSkHYEpSvw+1hAb3RTFHGC2tTyVY1mzBkpxg+pK01ZJlJR5+8xHPKdKTzDBKwgw/ZeFWkqhsbc6U+mx4YW7OhDFWAoU5zz0VqYSihPfhkywzSrxP/gIMRRj/BRgAnLOBpcDN0XwAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6NTc5N0IzNzNDRDgwMTFFREI0QjhDNTc1ODhEQ0U5QUEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6NTc5N0IzNzJDRDgwMTFFREI0QjhDNTc1ODhEQ0U5QUEiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmE2MjNhNDkzLTgxYTMtZTY0NS1hNjkzLWIxMGJlN2ZkYTZiNyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4AefvtAAAAOVBMVEWy1dV4VU2Hh4d+iWm4hXCVbF10WERsbGxsbH7X7+/w/f33/v5ZPSm5hVzu///2//+WbEr///95VTp2t8fQAAAA0klEQVR42sxP25bCMAikpq6Skgv8/8c6Q/ries66b0paLhNmINLdfQyn7zRx+gXQd+nMkI9scXawSluUFw10UWJ1pUaKjqUzup/AX1P67yn+PMX/MeXdW/x1SqUdpBz0VSoz5KiOWglUVmnZLKrAF3BoVRVRQURvVqg3KapMVexaZJfdtqJl2+9lv244EtHanBHT0k+hx7FgjSC4QsQf7I0JgLFNaw2kSyRl4uYGiuETeiJxkkiJHypaMzA5xRrEjYLnWK5xibUFNb51sc/s8RBgAPteK87jQ56VAAAAAElFTkSuQmCC",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjQ5NTY2QjBDRDgzMTFFRDlBMDVEQjdCQUJGNTMyQTUiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjQ5NTY2QUZDRDgzMTFFRDlBMDVEQjdCQUJGNTMyQTUiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkE4QTFCNzYzNUZBQTExRURBQTFEOEE4NUYzQkVDMDdDIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkE4QTFCNzY0NUZBQTExRURBQTFEOEE4NUYzQkVDMDdDIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+bcmsswAAAEtQTFRFrmJPd0czdDUgVjUia1VTjn13moeBY0QqhkkooFxKj0YwlH94jHJqg2VenV5NkXZubEQ4g0g3dEEthVE+mFVEfWBZajsphmtklEw4g+r2KQAAALdJREFUeNrskEu2wzAIQ3HS5tV/Azaw/5XWpB2/FZQBGkm6RwCRNQLEFrm3OBtYYhU0s4QqlgyGjPwniFvLCBJAa8+6Vq3F9aEQIU6eXNqcxpMUaNvtRSqUMKWjwGAWkvEcQohyduju7z0X3VpLBpi737/nwOaYuz94TiJFSxOC92+OOycQg979fl8Obs39tUVX7B8OQ8VbN8eGcI5+HkR0nBnKY9W19Ho6UL4u+O3x2+OfPd4CDABmSjAHS4WZHQAAAABJRU5ErkJggg==",
];

const COL_ORANGE = '#FFA500';
const COL_AQUA = '#00FFFF';
const COL_DELETE = '#FF0000';
const COL_HIDE = '#FFFF00';
const COL_STARTUP = '#6480B6';
const COL_AXIS_X = '#EA3751';
const COL_AXIS_Y = '#85D10C';
const COL_AXIS_Z = '#2F81DF';

const PI2 = Math.PI * 2;
const PIH = Math.PI / 2;
const MAXAMOUNT = 64000;
const FPS_TOOLMOVE = 1000 / 60;
const viewAxes = [];

let MODE = 0; // model|bake|render
let currentColor = document.getElementById('input-color-0').value.toUpperCase();
let currentColorBake = document.getElementById('input-color-1').value.toUpperCase();
let isRenderAxisView = true;
let azimuth = null;

const canvas = document.getElementById('canvas_render');
const canvasP = document.getElementById('canvas_palette');

const engine = new BABYLON.Engine(canvas, true, {});
engine.disablePerformanceMonitorInBackground = true;
engine.preserveDrawingBuffer = false;
engine.premultipliedAlpha = false;
engine.enableOfflineSupport = false;
engine.doNotHandleContextLost = true;
engine.loadingScreen = new CustomLoadingScreen();
engine.displayLoadingUI();

const camera = new Camera();
const scene = createScene(engine);
const sceneAxisView = createAxisViewScene(engine, scene);

const ui = new UserInterface(scene);
const uix = new UserInterfaceAdvanced(scene);

const hdri = new HDRI(scene);
const pipeline = new Pipeline(scene);
const material = new Material(scene);

const builder = new Builder(scene);
const bakery = new Bakery(scene);

const palette = new Palette();
const helper = new Helper(scene, sceneAxisView);
const tool = new Tool(scene);
const toolBakery = new ToolBakery(scene);
const symmetry = new Symmetry();

const preferences = new Preferences();
const project = new Project(scene);
const snapshot = new Snapshot();
const memory = new Memory();

const voxelizer = new Voxelizer();
const generator = new Generator();

// intro
scene.executeOnceBeforeRender(() => {
    preferences.init();
    hdri.initHDRI();
}, 0);

scene.executeWhenReady(() => {
    if (preferences.isNoIntro) {
        project.newBox(8, currentColor);
    } else {
        project.loadFromUrl('samples/startup.vbx');
    }
    engine.hideLoadingUI();
    preferences.finish();
}, 100);

// render loops
engine.runRenderLoop(() => {
    scene.render();
});

scene.registerAfterRender(() => {
    if (isRenderAxisView) {
        sceneAxisView.render();
        if (MODE !== 2) {
            sceneAxisView.activeCamera.alpha = scene.activeCamera.alpha;
            sceneAxisView.activeCamera.beta = scene.activeCamera.beta;
        } else {
            azimuth = BABYLON.Spherical.FromVector3(camera.camera2.position);
            sceneAxisView.activeCamera.alpha = azimuth.phi;
            sceneAxisView.activeCamera.beta = azimuth.theta;
        }
    }
    ui.updateStatus();
});


// -------------------------------------------------------
// Scene


function createScene(engine) {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
    scene.autoClear = false;
    scene.autoClearDepthAndStencil = false;
    scene.blockMaterialDirtyMechanism = true;
    scene.gravity = new BABYLON.Vector3(0, 0, 0);
    scene.collisionsEnabled = false;
    scene.useRightHandedSystem = true;

    camera.init(scene);

    const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), scene);
    ambient.diffuse = new BABYLON.Color3(0.8, 0.8, 0.8);
    ambient.specular = new BABYLON.Color3(0.8, 0.8, 0.8);
    ambient.groundColor = new BABYLON.Color3(0.4, 0.4, 0.4);
    ambient.intensity = 0.3;

    const light = new BABYLON.DirectionalLight("direct", new BABYLON.Vector3(0, -1, 0), scene);
    setLightPositionByAngle(light, 120, 50, 100);
    light.autoUpdateExtends = true; // to REFRESHRATE_RENDER_ONCE
    light.diffuse = new BABYLON.Color3(0.8, 0.8, 0.8);
    light.intensity = 0.5;
    light.shadowMaxZ = 2500;
    light.shadowMinZ = -2500;

    // shadows updated manually on mesh changes to save performance
    const shadowGen = new BABYLON.ShadowGenerator(512, light);
    shadowGen.getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
    shadowGen.filteringQuality = BABYLON.ShadowGenerator.QUALITY_MEDIUM; //overrided
    shadowGen.useExponentialShadowMap = true; //def: true
    shadowGen.usePercentageCloserFiltering = true; // webgl2 only, fallback -> usePoissonSampling
    shadowGen.forceBackFacesOnly = false;
    shadowGen.bias = 0.00005; //def: 0.00005
    shadowGen.setDarkness(0); //overrided
    
    const shadowcatcher = BABYLON.MeshBuilder.CreateGround("shadowcatcher", { width: 1000, height: 1000 }, scene);
    shadowcatcher.material = new BABYLON.ShadowOnlyMaterial('shadowcatcher', scene);
    shadowcatcher.material.shadowColor = BABYLON.Color3.FromHexString('#161a20');
    shadowcatcher.material.activeLight = light;
    shadowcatcher.material.backFaceCulling = true;
    shadowcatcher.material.alpha = 0.3;
    shadowcatcher.position.y = -0.5;
    shadowcatcher.receiveShadows = true;
    shadowcatcher.isPickable = false;
    shadowcatcher.doNotSyncBoundingInfo = true;
    shadowcatcher.doNotSerialize = true;
    shadowcatcher.convertToUnIndexedMesh();
    shadowcatcher.freezeWorldMatrix();
    shadowcatcher.freezeNormals();

    return scene;
}

function createAxisViewScene(engine, mainScene) {
    const scene = new BABYLON.Scene(engine);
    scene.autoClear = false;
    scene.autoClearDepthAndStencil = true;
    scene.blockMaterialDirtyMechanism = true;
    scene.useRightHandedSystem = true;

    const ambient = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, -1, 0), scene);
    ambient.diffuse = new BABYLON.Color3(1, 1, 1);
    ambient.groundColor = new BABYLON.Color3(1, 1, 1);
    ambient.intensity = 1;

    const cam = new BABYLON.ArcRotateCamera("camera", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
    cam.viewport = updateViewport(100, 100, 5, -5);
    cam.radius = 5.2;
    cam.fov = 0.5;
    cam.alpha = engine.scenes[0].activeCamera.alpha;
    cam.beta = engine.scenes[0].activeCamera.beta;

    const cube = BABYLON.MeshBuilder.CreateBox("viewcube", { size: 0.5 }, scene);
    cube.material = new BABYLON.NormalMaterial("viewcube", scene);
    cube.material.backFaceCulling = true;
    cube.material.freeze();
    cube.doNotSyncBoundingInfo = true;
    cube.doNotSerialize = true;
    cube.convertToUnIndexedMesh();
    cube.freezeWorldMatrix();
    cube.freezeNormals();

    const axisHelper = new BABYLON.AxesViewer(scene, 0.6, 0, null,null,null, 4);
    axisHelper.xAxis.parent = cube;
    axisHelper.yAxis.parent = cube;
    axisHelper.zAxis.parent = cube;

    let axis = BABYLON.MeshBuilder.CreateSphere("viewaxes", { diameter: 0.55, segments: 5 }, scene);
    for (let i = 0; i < 6; i++) {
        const a = axis.clone();
        a.renderOverlay = true;
        a.renderOutline = true;
        a.outlineWidth = 0.04;
        a.overlayAlpha = 0.9;
        a.doNotSyncBoundingInfo = true;
        a.doNotSerialize = true;
        a.convertToUnIndexedMesh();
        a.freezeNormals();
        viewAxes.push(a);
    }
    axis.dispose();
    axis = null;

    viewAxes[0].position.x = 0.85;
    viewAxes[0].renderOutline = false;
    viewAxes[0].overlayColor = BABYLON.Color3.FromHexString(COL_AXIS_X);
    viewAxes[1].position.x = -0.85;
    viewAxes[1].scaling.scaleInPlace(-0.9); // exclude border size
    viewAxes[1].overlayAlpha = 0.3;
    viewAxes[1].visibility = 0.01;
    viewAxes[1].overlayColor = viewAxes[0].overlayColor;
    viewAxes[1].outlineColor = viewAxes[0].overlayColor;
    viewAxes[2].position.y = 0.85;
    viewAxes[2].renderOutline = false;
    viewAxes[2].overlayColor = BABYLON.Color3.FromHexString(COL_AXIS_Y);
    viewAxes[3].position.y = -0.85;
    viewAxes[3].scaling.scaleInPlace(-0.9);
    viewAxes[3].overlayAlpha = 0.3;
    viewAxes[3].visibility = 0.01;
    viewAxes[3].overlayColor = viewAxes[2].overlayColor;
    viewAxes[3].outlineColor = viewAxes[2].overlayColor;
    viewAxes[4].position.z = 0.85;
    viewAxes[4].renderOutline = false;
    viewAxes[4].overlayColor = BABYLON.Color3.FromHexString(COL_AXIS_Z);
    viewAxes[5].position.z = -0.85;
    viewAxes[5].scaling.scaleInPlace(-0.9);
    viewAxes[5].overlayAlpha = 0.3;
    viewAxes[5].visibility = 0.01;
    viewAxes[5].overlayColor = viewAxes[4].overlayColor;
    viewAxes[5].outlineColor = viewAxes[4].overlayColor;

    const predicate = (mesh) => {
        return viewAxes.includes(mesh) || mesh == cube;
    };

    scene.onPointerObservable.add((pInfo) => {
        if (pInfo.type == BABYLON.PointerEventTypes.POINTERDOWN) {
            const pick = scene.pick(scene.pointerX, scene.pointerY, predicate);
            if (pick.hit) {
                if (pick.pickedMesh == cube) {
                    if (MODE == 1) { // solved picking conflict for camera.frame() (deselected bake)
                        bakery.selected = bakery.lastSelected;
                        bakery.lastSelected = null;
                    }
                    camera.frame();
                } else {
                    if (MODE !== 2) {
                        if (pick.pickedMesh == viewAxes[0]) camera.setView('x');
                        if (pick.pickedMesh == viewAxes[1]) camera.setView('-x');
                        if (pick.pickedMesh == viewAxes[2]) camera.setView('y');
                        if (pick.pickedMesh == viewAxes[3]) camera.setView('-y');
                        if (pick.pickedMesh == viewAxes[4]) camera.setView('z');
                        if (pick.pickedMesh == viewAxes[5]) camera.setView('-z');
                        mainScene.activeCamera.detachControl(canvas);
                        setTimeout(() => { // solved mainScene rotation conflict
                            mainScene.activeCamera.attachControl(canvas, true);
                        }, 100);
                    }
                }
            }
        }
    });

    return scene;
}


// -------------------------------------------------------
// Camera


function Camera() {
    const CAM2SPEED = 0.9;
    this.camera0 = null;    // model (startup)
    this.camera1 = null;    // bakery
    this.camera2 = null;    // render
    this.cameraView = '';
    let speedTimeout = null;
    
    this.init = function(scene) {
        this.camera0 = new BABYLON.ArcRotateCamera("camera_model", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
        this.camera1 = new BABYLON.ArcRotateCamera("camera_bakery", 0, 0, 10, BABYLON.Vector3.Zero(), scene);
        this.camera2 = new BABYLON.UniversalCamera("camera_render", new BABYLON.Vector3(30, 35, 30), scene);

        const fov = parseFloat(document.getElementById('input-camera-fov').value); //def: 0.8

        this.camera0.setPosition(new BABYLON.Vector3(10, 10, 10));
        this.camera0.setTarget(BABYLON.Vector3.Zero());
        this.camera0.lowerRadiusLimit = 2;
        this.camera0.upperRadiusLimit = 1000;
        this.camera0.wheelPrecision = 8; //def: 3
        this.camera0.pinchPrecision = 40; //def: 12
        this.camera0.panningSensibility = 300; //def: 1000
        this.camera0.minZ = 1;
        this.camera0.maxZ = 1000;
        this.camera0.fov = fov; //def: 0.8

        this.camera1.setPosition(new BABYLON.Vector3(15, 15, 15));
        this.camera1.setTarget(BABYLON.Vector3.Zero());
        this.camera1.lowerRadiusLimit = 2;
        this.camera1.upperRadiusLimit = 1000;
        this.camera1.wheelPrecision = 8;
        this.camera1.pinchPrecision = 40;
        this.camera1.panningSensibility = 300;
        this.camera1.minZ = 1;
        this.camera1.maxZ = 1000;
        this.camera1.fov = fov;

        this.camera2.setTarget(BABYLON.Vector3.Zero());
        this.camera2.checkCollisions = false;
        this.camera2.applyGravity = false;
        this.camera2.speed = CAM2SPEED; // overrided
        this.camera2.minZ = 1;
        this.camera2.maxZ = 1000;
        this.camera2.inertia = 0.85;
        this.camera2.fov = fov;
        this.camera2.angularSensibility = 5000;
        this.camera2.ellipsoid = new BABYLON.Vector3(0.5, 0.5, 0.5);
        this.camera2._needMoveForGravity = false;
        this.camera2.keysUp = ['W'.charCodeAt(0)];
        this.camera2.keysLeft = ['A'.charCodeAt(0)];
        this.camera2.keysDown = ['S'.charCodeAt(0)];
        this.camera2.keysRight = ['D'.charCodeAt(0)];
        this.camera2.keysUpward = ['E'.charCodeAt(0)];
        this.camera2.keysDownward = ['Q'.charCodeAt(0)];
        //this.camera2.onCollide = (mesh) => {};
    }

    this.switchCamera = function() {
        scene.activeCamera.detachControl(canvas);
        if (MODE == 0) {
            scene.activeCamera = this.camera0;
            this.camera0.attachControl(canvas, true);
        } else if (MODE == 1) {
            scene.activeCamera = this.camera1;
            this.camera1.attachControl(canvas, true);
        } else if (MODE == 2) {
            scene.activeCamera = this.camera2;
            this.camera2.attachControl(canvas, true);
        }
        ui.domCamFov.value = scene.activeCamera.fov;
    }

    this.frame = function(scale = 35) {
        if (MODE == 0) {
            this.setFramingBehavior(this.camera0, builder.SPS.mesh, scale);
        } else if (MODE == 1) {
            if (bakery.selected) { // zoom to selected mesh
                this.setFramingBehavior(this.camera1, bakery.selected, scale);
            } else {
                animator(this.camera1, 'position', this.camera1.position.clone(), this.camera0.position, 10,10);
                animator(this.camera1, 'target', this.camera1.target.clone(), this.camera0.target, 10,10);
            }
        } else if (MODE == 2) {
            if (pipeline.currentRenderMode == 'bake') {
                animator(this.camera2, 'position', this.camera2.position.clone(), this.camera1.position, 10,10);
                animator(this.camera2, 'target', this.camera2.target.clone(), this.camera1.target, 10,10);
            } else { // frame to camera0 if there is no bake
                animator(this.camera2, 'position', this.camera2.position.clone(), this.camera0.position, 10,10);
                animator(this.camera2, 'target', this.camera2.target.clone(), this.camera0.target, 10,10);
            }
        }
        if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
            this.setOrthoZoom();
    }

    this.setFramingBehavior = function(cam, target, scale) {
        target.computeWorldMatrix(true);
        const bounds = target.getBoundingInfo();
        const bbox = bounds.boundingBox;
        const radiusWorld = bbox.maximumWorld.subtract(bbox.minimumWorld).scale(0.5);
        const centerWorld = bbox.minimumWorld.add(radiusWorld);
        const zoomTargetY = bbox.minimumWorld.y + (bbox.maximumWorld.y - bbox.minimumWorld.y) * 0.5;
        const zoomTarget = new BABYLON.Vector3(centerWorld.x, zoomTargetY, centerWorld.z);
        const radius = bounds.boundingSphere.radiusWorld;
        //cam.lowerRadiusLimit = radiusWorld.length() + cam.minZ;
        //cam.upperRadiusLimit = radiusWorld.length() + cam.maxZ;
        animator(cam, 'radius', cam.radius, (radius + scale) / cam.fov, 5,5);
        animator(cam, 'target', cam.target.clone(), zoomTarget, 5,5);
    }

    this.toggleCameraAutoRotation = function() {
        scene.activeCamera.useAutoRotationBehavior = !scene.activeCamera.useAutoRotationBehavior;
        if (scene.activeCamera.useAutoRotationBehavior) {
            scene.activeCamera.autoRotationBehavior.idleRotationSpeed = 0.1; //-0.1 CCW
            scene.activeCamera.autoRotationBehavior.idleRotationWaitTime = 1;
            scene.activeCamera.autoRotationBehavior.idleRotationSpinupTime = 1;
        }
        ui.domAutoRotation.checked = scene.activeCamera.useAutoRotationBehavior;
    }

    this.switchOrtho = function() {
        if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA) {
            this.setView('persp');
        } else {
            this.setView('ortho');
        }
    }

    this.setView = function(name) {
        this.cameraView = name;
        builder.SPS.mesh.computeWorldMatrix(true);
        const bbox = builder.SPS.mesh.getBoundingInfo().boundingBox;
        const zoomTargetY = bbox.minimumWorld.y + (bbox.maximumWorld.y - bbox.minimumWorld.y) * 0.5;
        const zoomTarget = new BABYLON.Vector3(0, zoomTargetY, 0);
        let position = null;
        
        switch (name) {
            case 'x':
                position = new BABYLON.Vector3(1, 0, 0);
                break;
            case '-x':
                position = new BABYLON.Vector3(-1, 0, 0);
                break;
            case 'y':
                position = new BABYLON.Vector3(0, 1, 0);
                break;
            case '-y':
                position = new BABYLON.Vector3(0, -1, 0);
                break;
            case 'z':
                position = new BABYLON.Vector3(0, 0, 1);
                break;
            case '-z':
                position = new BABYLON.Vector3(0, 0, -1);
                break;
            case 'ortho':
                scene.activeCamera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
                ui.domOrthoBtn.innerHTML = 'Orthographic';
                this.setOrthoZoom();
                break;
            case 'persp':
                scene.activeCamera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
                ui.domOrthoBtn.innerHTML = 'Perspective';
                break;
        }

        if (position) {
            this.setOrthoZoom();
            scene.activeCamera.position = position.multiplyByFloats(
                scene.activeCamera.radius, scene.activeCamera.radius, scene.activeCamera.radius).add(zoomTarget);
            scene.activeCamera.target = zoomTarget;
        }
    }

    this.setOrthoZoom = function() {
        const radius = scene.activeCamera.radius / 2;
        const sizeY = radius * scene.activeCamera.fov;
        const sizeX = radius * scene.activeCamera.fov * scene.getEngine().getAspectRatio(scene.activeCamera);
        scene.activeCamera.orthoLeft = -sizeX;
        scene.activeCamera.orthoRight = sizeX;
        scene.activeCamera.orthoTop = sizeY;
        scene.activeCamera.orthoBottom = -sizeY;
    }

    this.setFov = function(elem) {
        const fov = parseFloat(elem.value);
        scene.activeCamera.fov = fov;
        if (MODE == 2) {
            ui.domReticle.children[2].style.width  = fov * 100 + 'px';
            ui.domReticle.children[2].style.height = fov * 100 + 'px';
            ui.domReticle.children[2].style.marginLeft = 49-(fov * 100)/2 + 'px';
            ui.domReticle.children[2].style.marginTop  = 49-(fov * 100)/2 + 'px';
        }
        if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
            this.setOrthoZoom();
    }

    this.speedUp = function() {
        if (this.camera2.speed == CAM2SPEED)
            clearTimeout(speedTimeout);

        this.camera2.speed = CAM2SPEED * 3;
        speedTimeout = setTimeout(() => {
            this.camera2.speed = CAM2SPEED;
        }, 2000);
    }
}


// -------------------------------------------------------
// HDRI and Skybox


function HDRI(scene) {
    this.hdrMap = null;
    this.skybox = null;
    this.isLoaded = false;

    this.initHDRI = async () => { await this.init() }

    this.init = async function() {
        this.hdrMap = new BABYLON.HDRCubeTexture(ENVMAP, scene, 512, undefined,undefined,undefined,undefined, () => {
            hdri.hdrMap.gammaSpace = false;
            hdri.skybox = hdri.createSkybox(hdri.hdrMap.clone(), parseFloat(ui.domHdriBlur.value));
            scene.environmentTexture = hdri.hdrMap;
        });
    }

    this.loadHDR = function(url) {
        if (url == '') return; // ignore first preset option
        if (this.hdrMap) {
            this.hdrMap.dispose();
            this.hdrMap = null;
        }
        this.hdrMap = new BABYLON.HDRCubeTexture(url, scene, 512, undefined,undefined,undefined,undefined, () => {
            hdri.hdrMap.gammaSpace = false;
            if (hdri.skybox.material.reflectionTexture)
                hdri.skybox.material.reflectionTexture.dispose();
            hdri.skybox.material.reflectionTexture = hdri.hdrMap.clone();
            hdri.skybox.material.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            hdri.skybox.isVisible = ui.domHdriToggle.checked;
            scene.environmentTexture = hdri.hdrMap;
            
            bakery.updateReflectionTextures();

            hdri.isLoaded = true;
        });
    }

    this.unloadHDR = function() {
        this.loadHDR(ENVMAP);
    }

    this.createSkybox = function(tex, blur) {
        const dist = (scene.activeCamera.maxZ - scene.activeCamera.minZ) / 2;
        const skybox = BABYLON.MeshBuilder.CreateBox('skybox', { size: dist }, scene);
        skybox.material = new BABYLON.PBRMaterial("skybox", scene);
        skybox.material.reflectionTexture = tex;
        skybox.material.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
        skybox.material.microSurface = 1.0 - blur;
        skybox.material.disableLighting = true;
        skybox.material.twoSidedLighting = true;
        skybox.material.backFaceCulling = false;
        skybox.isPickable = false;
        skybox.isVisible = false;
        skybox.infiniteDistance = true;
        skybox.ignoreCameraMaxZ = true;
        skybox.doNotSyncBoundingInfo = true;
        skybox.convertToUnIndexedMesh();
        skybox.freezeWorldMatrix();
        skybox.freezeNormals();
        return skybox;
    }

    this.toggleSkybox = function(isShow) {
        if (this.skybox) this.skybox.isVisible = isShow;
    }

    this.setBlurAmount = function(num) {
        this.skybox.material.microSurface = 1.0 - num;
    }

    this.init();
}


// -------------------------------------------------------
// Pipeline (post-process)


function Pipeline(scene) {
    this.pip = null;
    this.ssao = null;
    this.isHq = false;
    this.curve = null;
    this.currentRenderMode = 'voxel'; // voxel|bake

    this.init = function() {
        if (this.pip) this.dispose(); // prevent overdraw

        this.pip = new BABYLON.DefaultRenderingPipeline("default", true, scene,
            [ camera.camera2 ]);

        this.pip.imageProcessingEnabled = true;
        this.pip.imageProcessing.toneMappingEnabled = true;
        this.pip.imageProcessing.applyByPostProcess = true;
        this.pip.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;
        this.pip.imageProcessing.contrast = parseFloat(ui.domPipelineContrast.value);
        this.pip.imageProcessing.exposure = parseFloat(ui.domPipelineExposure.value);
        this.pip.imageProcessing.vignetteEnabled = true;
        this.pip.imageProcessing.vignetteWeight = parseInt(ui.domPipelineVignette.value);
        this.pip.imageProcessing.vignetteStretch = 2;
        this.pip.imageProcessing.vignetteColor = new BABYLON.Color4(0, 0, 0, 0);
        this.pip.imageProcessing.colorCurvesEnabled = true;
        if (this.pip.imageProcessing.colorCurvesEnabled) {
            this.curve = new BABYLON.ColorCurves();
            this.curve.globalDensity = 0; //def: 0
            this.curve.globalExposure = 0; //def: 0
            this.curve.globalHue = parseInt(ui.domPipelineHue.value); //def: 30
            this.curve.globalSaturation = 0; //def: 0
            this.curve.highlightsDensity = 0; //def: 0
            this.curve.highlightsExposure = 0; //def: 0
            this.curve.highlightsHue = parseInt(ui.domPipelineHue.value); //def: 30
            this.curve.highlightsSaturation = 0; //def: 0
            this.curve.midtonesDensity = 0; //def: 0
            this.curve.midtonesExposure = 0; //def: 0
            this.curve.midtonesHue = parseInt(ui.domPipelineHue.value); //def: 30
            this.curve.midtonesSaturation = 0; //def: 0
            this.curve.shadowsDensity = 0; //def: 0
            this.curve.shadowsExposure = 0; //def: 0
            this.curve.shadowsHue = parseInt(ui.domPipelineHue.value); //def: 30
            this.curve.shadowsDensity = 80; //def: 80
            this.curve.shadowsSaturation = 0; //def: 0
            this.pip.imageProcessing.colorCurves = this.curve;
        }

        this.pip.samples = 1; //MSAA def: 1
        this.pip.fxaaEnabled = true;
        if (this.pip.fxaaEnabled)
            this.pip.fxaa.samples = 1; //def: 1

        this.pip.sharpenEnabled = true;
        this.pip.sharpen.edgeAmount = parseFloat(ui.domPipelineSharpen.value);
        this.pip.sharpen.colorAmount = 1;

        this.pip.grainEnabled = true;
        this.pip.grain.intensity = parseInt(ui.domPipelineGrain.value);
        this.pip.grain.animated = true;

        this.pip.bloomEnabled = ui.domPipelineBloom.checked;
        if (this.pip.bloomEnabled) {
            this.pip.bloomThreshold = 0.4;
            this.pip.bloomWeight = 0.3;
            this.pip.bloomKernel = 64;
            this.pip.bloomScale = 0.5;
        }

        this.pip.depthOfFieldEnabled = ui.domPipelineDof.checked;
        if (this.pip.depthOfFieldEnabled) {
            this.pip.depthOfField.focusDistance = parseInt(ui.domPipelineDofDist.value) * builder.SPS.mesh.getDistanceToCamera(camera.camera2);
            this.pip.depthOfField.focalLength = 180;
            this.pip.depthOfField.fStop = 2.0;
            this.pip.depthOfField.lensSize = 50; // default
            this.pip.depthOfFieldBlurLevel = BABYLON.DepthOfFieldEffectBlurLevel.Medium;
            if (isMobileDevice())
                this.pip.depthOfFieldBlurLevel = BABYLON.DepthOfFieldEffectBlurLevel.Low;
        }

        this.pip.chromaticAberrationEnabled = true;
        if (this.pip.chromaticAberrationEnabled) {
            this.pip.chromaticAberration.aberrationAmount = parseInt(ui.domPipelineChromatic.value); //def: 30
            this.pip.chromaticAberration.alphaMode = 0; //def: 0
            this.pip.chromaticAberration.alwaysForcePOT = false; //def: false
            this.pip.chromaticAberration.enablePixelPerfectMode = false; //def: false
            this.pip.chromaticAberration.forceFullscreenViewport = true;
        }
        
        if (!isMobileDevice()) {
            this.ssao = new BABYLON.SSAORenderingPipeline("ssao", scene,
                { ssaoRatio: 0.5, combineRatio: 1.0 }, [ camera.camera2 ]);
            this.ssao.fallOff = 0.00001;  //def: 0.000001
            this.ssao.radius = 0.0010;    //def: 0.0006
            this.ssao.area = 0.0100;      //def: 0.0075
            this.ssao.base = 0.6;         //lower=darker
            this.ssao.totalStrength = 1;
        }

        this.isHq = true;
        ui.domPipelineDofDist.disabled = !ui.domPipelineDof.checked;
    }

    this.updateProps = function() {
        if (MODE == 2 && this.pip) {
            this.pip.imageProcessing.contrast = parseFloat(ui.domPipelineContrast.value);
            this.pip.imageProcessing.exposure = parseFloat(ui.domPipelineExposure.value);
            this.pip.imageProcessing.vignetteWeight = parseInt(ui.domPipelineVignette.value);
            this.pip.bloomEnabled = ui.domPipelineBloom.checked;
            this.pip.depthOfFieldEnabled = ui.domPipelineDof.checked;
            this.pip.depthOfField.focusDistance = parseInt(ui.domPipelineDofDist.value) * builder.SPS.mesh.getDistanceToCamera(camera.camera2);
            this.pip.sharpen.edgeAmount = parseFloat(ui.domPipelineSharpen.value);
            this.pip.grain.intensity = parseInt(ui.domPipelineGrain.value);
            this.pip.chromaticAberration.aberrationAmount = parseInt(ui.domPipelineChromatic.value);
            this.curve.globalHue = parseInt(ui.domPipelineHue.value);
            this.curve.highlightsHue = parseInt(ui.domPipelineHue.value);
            this.curve.midtonesHue = parseInt(ui.domPipelineHue.value);
            this.curve.shadowsHue = parseInt(ui.domPipelineHue.value);
        }
    }

    this.toggle = function() {
        (this.isHq) ? this.dispose() : this.init();
    }

    this.dispose = function() {
        if (this.ssao) {
            this.ssao.dispose();
            this.ssao = null;
        }
        if (this.pip) { // important to prevent multiple camera conflict
            this.pip.fxaaEnabled = false;
            this.pip.imageProcessingEnabled = false;
            this.pip.sharpenEnabled = false;
            this.pip.grainEnabled = false;
            this.pip.bloomEnabled = false;
            this.pip.depthOfFieldEnabled = false;
            this.pip.chromaticAberrationEnabled = false;
            this.pip.dispose();
            this.pip = null;
        }
        this.isHq = false;
    }

    this.setRenderMode = function(mode) {
        if (mode == 'bake') { // RENDER bakes
            if (bakery.meshes.length > 0) {
                scene.lights[1].getShadowGenerator().setDarkness(0);
                builder.setMeshVisibility(false);
                bakery.setBakesVisibility(true);
                this.currentRenderMode = mode;
            } else {
                ui.notification('no baked meshes');
            }
        }
        if (mode == 'voxel') { // PREVIEW voxels
            scene.lights[1].getShadowGenerator().setDarkness(0.8);
            builder.setMeshVisibility(true);
            bakery.setBakesVisibility(false);
            this.currentRenderMode = mode;
        }
        updateShadowMap();
    }
}


// -------------------------------------------------------
// Material


function Material(scene) {
    this.texId = 0;    // current PBR texture
    this.mat_cel = null;
    this.mat_pbr = null;
    this.mat_ghost = null;
    this.mat_workplane = null;
    this.mat_grid = null;
    this.tex_cel = null;
    this.tex_pbr = null;
    this.textures = [];
    let numDefTex = 0;

    this.init = function() {
        numDefTex = TEX_PATTERNS.length;
        for (let i = 0; i < numDefTex; i++) // load pattern textures
            this.textures.push(this.createTexture('texpat'+i, TEX_PATTERNS[i], BABYLON.Texture.LINEAR_LINEAR_MIPLINEAR));

        for (const i of TEX_PRESETS)
            this.addTexture(i); // import texture samples

        this.tex_cel = this.createVoxelTexture('#000000');
        this.setPBRTexture(); //def: 1

        this.createCelMaterial();
        this.createWorkplaneMaterial();
        this.createGridMaterial();
        this.createGhostMaterial();
    }

    this.update = function() {
        this.createPBRMaterial();
    }

    this.createCelMaterial = function() {
        if (this.mat_cel) {
            this.mat_cel.dispose();
            this.mat_cel = null;
        }
        const mat = new BABYLON.StandardMaterial("CEL", scene);
        mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        mat.specularColor = new BABYLON.Color3(0, 0, 0);
        mat.emissiveColor = new BABYLON.Color3(0.4, 0.4, 0.4);
        mat.emissiveTexture = this.tex_cel;
        mat.opacityTexture = this.tex_cel;
        mat.opacityFresnelParameters = new BABYLON.FresnelParameters();
        mat.opacityFresnelParameters.leftColor = new BABYLON.Color3(0.8, 0.8, 0.8);
        mat.opacityFresnelParameters.rightColor = new BABYLON.Color3(0.8, 0.8, 0.8);
        mat.useEmissiveAsIllumination = false;
        mat.linkEmissiveWithDiffuse = true;
        mat.backFaceCulling = true;
        mat.transparencyMode = 0;
        this.mat_cel = mat;
    }

    this.createPBRMaterial = function() { // initial/overrided
        if (this.mat_pbr) {
            this.mat_pbr.albedoTexture.dispose();
            this.mat_pbr.reflectionTexture.dispose();
            this.mat_pbr.dispose();
            this.mat_pbr = null;
        }
        const mat = new BABYLON.PBRMaterial("PBR", scene);
        mat.albedoColor = new BABYLON.Color3(1, 1, 1);
        mat.albedoTexture = this.tex_pbr.clone();
        mat.reflectionTexture = hdri.hdrMap.clone();
        mat.reflectionTexture.coordinatesMode = BABYLON.Texture.CUBIC_MODE;
        mat.roughness = 0.8;
        mat.metallic = 0.2;
        mat.alpha = 1;
        mat.alphaCutOff = 0.5;
        mat.alphaMode = BABYLON.PBRMaterial.PBRMATERIAL_ALPHABLEND;
        mat.transparencyMode = 1;
        mat.useAlphaFromAlbedoTexture = true;
        mat.backFaceCulling = true;
        mat.specularIntensity = 1;
        mat.directIntensity = 1;
        mat.environmentIntensity = 1;
        this.mat_pbr = mat;
    }

    this.createExportMaterial = function() {
        const mat = new BABYLON.StandardMaterial("export", scene);
        mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        mat.specularColor = new BABYLON.Color3(1, 1, 1);
        mat.backFaceCulling = true;
        mat.freeze();
        return mat;
    }

    this.createWorkplaneMaterial = function() {
        const mat = new BABYLON.GridMaterial("workplane", scene);
        mat.gridRatio = 1;
        mat.majorUnitFrequency = 20;
        mat.minorUnitVisibility = 0.3;
        mat.mainColor = new BABYLON.Color3(0, 1, 1);
        mat.lineColor = new BABYLON.Color3(0, 1, 1);
        mat.opacity = 0.5;
        mat.backFaceCulling = false;
        mat.freeze();
        this.mat_workplane = mat;
    }

    this.createGridMaterial = function() {
        const mat = new BABYLON.GridMaterial("grid", scene);
        mat.opacityTexture = new BABYLON.Texture(PARTICLE, scene, undefined, undefined, BABYLON.Texture.NEAREST_SAMPLINGMODE);
        mat.opacityTexture.optimizeUVAllocation = true;
        mat.gridRatio = 0; // overrided by setGrid()
        mat.majorUnitFrequency = 40;
        mat.minorUnitVisibility = 0.3;
        mat.mainColor = new BABYLON.Color3(1,1,1);
        mat.lineColor = new BABYLON.Color3(1,1,1);
        mat.opacity = 0.05;
        mat.backFaceCulling = false;
        mat.freeze();
        this.mat_grid = mat;
    }

    this.createGhostMaterial = function() {
        const mat = new BABYLON.StandardMaterial("ghostvoxel", scene);
        mat.diffuseColor = new BABYLON.Color3(0, 0, 0); // overrided
        mat.specularColor = new BABYLON.Color3(0, 0, 0);
        mat.emissiveColor = new BABYLON.Color3(0.25, 0.25, 0.25);
        mat.emissiveTexture = this.tex_cel;
        mat.opacityTexture = this.tex_cel;
        mat.opacityFresnelParameters = new BABYLON.FresnelParameters();
        mat.opacityFresnelParameters.leftColor = new BABYLON.Color3(0.8, 0.8, 0.8);
        mat.opacityFresnelParameters.rightColor = new BABYLON.Color3(0.8, 0.8, 0.8);
        mat.useEmissiveAsIllumination = false;
        mat.linkEmissiveWithDiffuse = true;
        mat.backFaceCulling = true;
        mat.transparencyMode = 0;
        mat.checkReadyOnEveryCall = false;
        this.mat_ghost = mat;
    }

    this.createVoxelTexture = function(hex) {
        const tex = new BABYLON.DynamicTexture('voxelgrid', 256, scene, BABYLON.Texture.NEAREST_SAMPLINGMODE);
        const ctx = tex.getContext();
        ctx.lineWidth = 4; // grid
        ctx.strokeStyle = hex + '20';
        ctx.beginPath();
        ctx.moveTo(0, 128);
        ctx.lineTo(256, 128);
        ctx.moveTo(128, 0);
        ctx.lineTo(128, 256);
        ctx.stroke();
        ctx.lineWidth = 8; // outline
        ctx.strokeStyle = hex + '60';
        ctx.strokeRect(0, 0, 256, 256);
        tex.update();
        tex.hasAlpha = true;
        tex.getAlphaFromRGB = false;
        return tex;
    }

    this.createTexture = function(name, url, sampling = BABYLON.Texture.NEAREST_SAMPLINGMODE) {
        const tex = new BABYLON.Texture(url, scene, undefined, undefined, sampling);
        tex.name = name;
        tex.uScale = 1;
        tex.vScale = 1;
        tex.hasAlpha = true;
        tex.gammaSpace = true;
        tex.optimizeUVAllocation = true;
        return tex;
    }

    this.setPBRTexture = function(idx = 1) {
        this.texId = idx;
        this.tex_pbr = this.textures[idx];
    }

    this.addTexture = function(data) {
        this.textures.push(this.createTexture('texpbr_user', data));
        const idx = this.textures.length - 1;
        this.setPBRTexture(idx);
        this.update();
        const li = document.createElement("li");
        li.classList.add("img");
        li.innerHTML = `<img src="${ data }">`;
        li.addEventListener("click", () => {
            for (const i of ui.domTexturePresets.children)  // unselect
                i.firstChild.style.borderColor = '#6b798d'; // presets
            li.firstChild.style.borderColor = COL_ORANGE; // select preset

            material.setPBRTexture(idx);
            bakery.replaceTexture();
        }, false);
        ui.domTexturePresets.appendChild(li);
    }

    this.deleteTexture = function(evt) {
        evt.preventDefault();
        let data = evt.dataTransfer.getData("text");
        const imgs = document.querySelectorAll('#menu-texture img');
        for (let i = 0; i < imgs.length; i++) {
            if (imgs[i].src == data) {
                imgs[i].src = '';
                if (i > numDefTex)
                    this.textures[i].dispose();
                ui.domTexturePresets.removeChild(imgs[i].parentElement);
            }
        }
        data = null;
        this.setPBRTexture();
        this.update();
    }

    this.init();
}


// -------------------------------------------------------
// Builder (SPS particles)
// voxel = {
//    position: vector3,
//    color: #HEXHEX (uppercase/no alpha)
//    visible: bool
// }


function Builder(scene) {
    this.voxels = [];
    this.voxel = null;
    this.SPS = null;
    this.isOnionSkin = false;

    this.init = function() {
        this.voxel = BABYLON.MeshBuilder.CreateBox("voxel", { sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: false }, scene);
        this.voxel.isVisible = false;
        this.voxel.isPickable = false;
        this.voxel.doNotSerialize = true;
        this.voxel.convertToUnIndexedMesh();
        this.voxel.freezeWorldMatrix();
        this.voxel.freezeNormals();
    }

    this.createSPS = function(voxels = this.voxels) {
        if (this.SPS)
            this.SPS.dispose();
        this.SPS = new BABYLON.SolidParticleSystem('SPS', scene, { 
            isPickable: true, updatable: true, expandable: false,
            boundingSphereOnly: true // faster, no bbox computation
        });
        
        this.SPS.addShape(this.voxel, voxels.length, { positionFunction: (particle, i, s) => {
            particle.position.copyFrom(voxels[i].position);
            particle.color = BABYLON.Color4.FromHexString(voxels[i].color);
            if (!voxels[i].visible) // respect hidden voxels to enable hide and seek
                particle.scaling = BABYLON.Vector3.Zero(); // unable to use particle.isVisible
        }});

        this.SPS.buildMesh();
        this.SPS.mesh.material = material.mat_cel;
        this.SPS.mesh.receiveShadows = true;
        this.SPS.mesh.freezeWorldMatrix();
        this.SPS.mesh.freezeNormals();

        this.SPS.initParticles();
        this.SPS.setParticles();       // update SPS mesh and draw it
        this.SPS.refreshVisibleSize(); // update BBox for picking and shadows
        this.SPS.computeBoundingBox = false;
        this.SPS.computeParticleColor = false;
        this.SPS.computeParticleRotation = false;
        this.SPS.computeParticleTexture = false;
        this.SPS.computeParticleVertex = false;

        scene.lights[1].getShadowGenerator().addShadowCaster(this.SPS.mesh);
        updateShadowMap();
        
        this.setOnionSkin();
        if (symmetry.axis !== '')
            helper.setSymmPivot();
    }

    this.add = function(pos, hex, visible) {
        this.voxels.push({ position: pos, color: hex, visible: visible });
    }

    this.addNoDup = function(pos, hex, visible) {
        if (this.findIndexByPosition(pos) == -1) // no duplicates allowed
            this.voxels.push({ position: pos, color: hex, visible: visible });
    }

    this.remove = function(index) {
        if (builder.voxels.length > 1) { // 1 voxel minimum, useless but keep it
            index = this.voxels.indexOf(this.voxels[index]);
            if (index > -1)
                this.voxels.splice(index, 1);
        }
    }

    this.removeByPosition = function(pos) {
        this.remove(this.findIndexByPosition(pos));
    }

    this.removeDuplicates = function() {
        const last = this.voxels.length;
        this.voxels = this.voxels.filter((value, index, self) =>
            index === self.findIndex(i =>
                i.position.x == value.position.x &&
                i.position.y == value.position.y &&
                i.position.z == value.position.z
            ));
        return last - this.voxels.length;
    }

    this.removeDuplicatesFunc = function() {
        engine.displayLoadingUI();
        setTimeout(() => {
            ui.notification(`found ${ this.removeDuplicates() } duplicates`);
            engine.hideLoadingUI();
        }, 100);
    }

    this.findIndexByPosition = function(pos) {
        return this.voxels.findIndex(i =>
            i.position.x == pos.x &&
            i.position.y == pos.y &&
            i.position.z == pos.z);
    }

    this.findIndexByColor = function(hex) {
        return this.voxels.findIndex(i => i.color == hex);
    }

    this.getVoxelsByPosition = function(pos) {
        return this.voxels.filter(i =>
            i.position.x == pos.x &&
            i.position.y == pos.y &&
            i.position.z == pos.z);
    }

    this.getVoxelsByColor = function(hex) {
        return this.voxels.filter(i => i.color == hex);
    }

    this.getVoxelsByVisibility = function(isVisible) {
        return this.voxels.filter(i => i.visible == isVisible);
    }

    this.setVoxelPosition = function(index, pos) {
        this.voxels[index].position = pos;
        this.SPS.particles[index].position = pos;
    }

    this.setVoxelColor = function(index, hex) {
        this.voxels[index].color = hex;
    }

    this.setVoxelVisible = function(index, visible) {
        this.voxels[index].visible = visible;
        this.SPS.particles[index].isVisible = visible;
    }

    this.setVoxelsVisibility = function(isVisible) {
        for (let i = 0; i < this.voxels.length; i++)
            this.setVoxelVisible(i, isVisible);
    }

    this.setVoxelsVisibilityAndUpdate = function(isVisible) {
        for (let i = 0; i < this.voxels.length; i++)
            this.setVoxelVisible(i, isVisible);
        this.createSPS();
        palette.create();
        memory.record();
        updateShadowMap();
    }

    this.setMeshVisibility = function(isVisible) {
        this.SPS.mesh.isVisible = isVisible;
    }

    this.setOnionSkin = function() {
        (this.isOnionSkin) ? this.SPS.mesh.visibility = 0.5 : this.SPS.mesh.visibility = 1;
    }

    this.toggleOnionSkin = function() {
        this.isOnionSkin = !this.isOnionSkin; 
        this.setOnionSkin();
    }

    this.deleteHidden = function() {
        let hiddens = this.getVoxelsByVisibility(false);
        if (hiddens.length == 0) {
            ui.notification('no hidden voxels');
            return;
        }
        const len = this.voxels.length;
        for (let i = 0; i < hiddens.length; i++) {
            this.voxels.splice(this.voxels.indexOf(hiddens[i]), 1);
        }
        this.createSPS();
        palette.create();
        if (this.voxels.length !== len)
            memory.record(); // record on changes
        hiddens = null;
    }

    this.normalizeVoxelPositions = function(isRecordMem) {
        const bounds = this.SPS.mesh.getBoundingInfo();
        const size = getMeshSize(bounds);
        const center = bounds.boundingBox.center;
        const nX = -bounds.maximum.x + (size.x / 2);
        const nY = ((size.y / 2) - center.y) - 0.5;
        const nZ = -bounds.maximum.z + (size.z / 2);
        let transMatrix = null;
        let position = null;
        for (let i = 0; i < this.voxels.length; i++) {
            transMatrix = BABYLON.Matrix.Translation(nX, nY, nZ);
            position = BABYLON.Vector3.TransformCoordinates(this.voxels[i].position, transMatrix);
            this.setVoxelPosition(i, position);
        }
        this.SPS.setParticles();
        this.SPS.refreshVisibleSize();
        transMatrix = null;
        position = null;
        if (isRecordMem) {
            memory.record(); // record on changes
            ui.notification('normalized');
        }
        updateShadowMap();
    }

    this.reduceVoxels = async function() {
        if (!await ui.showConfirm('This operation is not undoable<br>continue?')) return;
        engine.displayLoadingUI();
        setTimeout(() => {
            let reduced = this.voxels.length;
            let toDelete = [];
            let idx = []; // remove voxels by testing 6 sides
            let test = [
                new BABYLON.Vector3(1, 0, 0),
                new BABYLON.Vector3(-1, 0, 0),
                new BABYLON.Vector3(0, 1, 0),
                new BABYLON.Vector3(0, -1, 0),
                new BABYLON.Vector3(0, 0, 1),
                new BABYLON.Vector3(0, 0, -1)
            ];
            for (let i = 0; i < this.voxels.length; i++) {
                idx[0] = this.findIndexByPosition(this.voxels[i].position.add(test[0]));
                idx[1] = this.findIndexByPosition(this.voxels[i].position.add(test[1]));
                idx[2] = this.findIndexByPosition(this.voxels[i].position.add(test[2]));
                idx[3] = this.findIndexByPosition(this.voxels[i].position.add(test[3]));
                idx[4] = this.findIndexByPosition(this.voxels[i].position.add(test[4]));
                idx[5] = this.findIndexByPosition(this.voxels[i].position.add(test[5]));
                if (idx[0] > -1 && idx[1] > -1 && idx[2] > -1 && idx[3] > -1 && idx[4] > -1 && idx[5] > -1)
                    toDelete.push(this.voxels[i]);
            }
            for (let i = 0; i < toDelete.length; i++) {
                this.voxels.splice(this.voxels.indexOf(toDelete[i]), 1);
            }
            this.createSPS();
            palette.create();
            ui.notification(`${ reduced - this.voxels.length } voxels removed`);
            idx = null;
            test = null;
            toDelete = null;
            engine.hideLoadingUI();
        }, 100);
    }

    this.getData = function() { // raw io, used in Memory and Snapshot
        let data = '';
        for (let i = 0; i < this.voxels.length; i++) {
            data += this.voxels[i].position.x + ',' +
                    this.voxels[i].position.y + ',' +
                    this.voxels[i].position.z + ',' +
                    this.voxels[i].color + ',' +
                    this.voxels[i].visible + ';';
        }
        return data;
    }

    this.setData = function(data) {
        let newData = [];
        let voxels = data.split(';').slice(0, -1);
        for (let i = 0; i < voxels.length; i++) {
            const chunk = voxels[i].split(',');
            newData.push({ 
                position: new BABYLON.Vector3(
                    parseFloat(chunk[0]),
                    parseFloat(chunk[1]),
                    parseFloat(chunk[2])
                ),
                color: chunk[3],
                visible: parseBool(chunk[4])
            });
        }
        this.voxels = newData;
        this.createSPS();
        palette.create();
        data = null;
        newData = null;
        helper.setGrid();
    }

    // used in file, project and generator functions
    // except memory record, do after createSPS()
    // except symmetry axis, do after createSPS()
    this.loadData = function(data, isDupCheck = true, isNormalize = false) {
        this.voxels = []; // important
        for (let i = 0; i < data.length; i++) 
            this.add(data[i].position, data[i].color, data[i].visible);
        if (isDupCheck)
            this.removeDuplicates();
        this.createSPS();
        palette.create();
        if (isNormalize)
            this.normalizeVoxelPositions(false);
        data = null;
        helper.setGrid();
        helper.resetWorkplane();
        uix.unbindWorkplane();
        ui.domWorkplane.checked = false;
    }

    this.init();
}


// -------------------------------------------------------
// Palette (color palette)


function Palette() {
    const W = 30;
    const H = 20;
    let ctx = null;
    this.uniqueColors = [];

    this.init = function() {
        canvasP.width = canvasP.clientWidth;
        canvasP.height = canvasP.clientHeight;
        
        ctx = canvasP.getContext('2d', { willReadFrequently: true });
        
        canvasP.addEventListener("pointerdown", (ev) => {
            const hex = getCanvasColor(ctx, ev.offsetX, ev.offsetY);
            if (palette.uniqueColors.includes(hex)) {
                currentColor = hex;
                uix.colorPicker0.value = BABYLON.Color3.FromHexString(hex);
            }
        }, false);

        canvasP.addEventListener("dblclick", (ev) => {
            const hex = getCanvasColor(ctx, ev.offsetX, ev.offsetY);
            if (palette.uniqueColors.includes(hex)) {
                if (palette.isColorVisible(hex)) {
                    palette.setColorVisible(hex, false);
                } else {
                    palette.setColorVisible(hex, true);
                }
                builder.createSPS();
                this.create();
                memory.record();
            }
        }, false);
    }

    this.create = function() {   // generate color palette
        ctx.clearRect(0, 0, canvasP.clientWidth, canvasP.clientHeight);

        this.uniqueColors = [];
        let padding = 2;
        for (let i = 0; i < builder.voxels.length; i++) {
            if (this.uniqueColors.indexOf(builder.voxels[i].color) == -1) {
                this.addColor(padding, builder.voxels[i].color);
                this.uniqueColors.push(builder.voxels[i].color);
                padding += H + 2;
            }
        }
    }
    
    this.addColor = function(pad, hex) {
        if (this.isColorVisible(hex)) { // respect the stored visibility state
            ctx.strokeStyle = 'transparent';
        } else {
            ctx.strokeStyle = 'orange';
        }
        ctx.lineWidth = 2;
        ctx.strokeRect(1, pad, W, H);
        ctx.fillStyle = hex;
        ctx.fillRect(1, pad, W, H);
    }

    this.setColorVisible = function(hex, isVisible) {
        let voxels = builder.getVoxelsByColor(hex);
        for (let i = 0; i < voxels.length; i++)
            voxels[i].visible = isVisible;
        voxels = null;
    }

    this.isColorVisible = function(hex) {
        const idx = builder.findIndexByColor(hex);
        if (idx > -1)
            return builder.voxels[ idx ].visible;
        return false;
    }

    this.init();
}


// -------------------------------------------------------
// Helper (overlays)


function Helper(scene, sceneAxisView) {
    this.gridPlane = BABYLON.MeshBuilder.CreatePlane("gridplane", { width: 3, height: 3, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, scene);
    this.workPlane = BABYLON.MeshBuilder.CreatePlane("workplane", { size: 80, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, scene);
    this.axisPlane = BABYLON.MeshBuilder.CreatePlane("axisplane", { width: 1.1, height: 1.1, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, sceneAxisView);
    this.symmPivot = BABYLON.MeshBuilder.CreateBox("symmpivot", { size: 0.5, sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: false }, uix.utilLayer.utilityLayerScene);
    this.overlayPlane = BABYLON.MeshBuilder.CreatePlane("overlayplane", { sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: false }, scene);
    this.overlayCube = BABYLON.MeshBuilder.CreateBox("overlaycube", { size: 1, sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: false }, scene);
    this.ghostBox = BABYLON.MeshBuilder.CreateBox("ghostbox", { size: 1, sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: false }, scene);
    this.ghostVoxel = null;
    this.workplaneAxis = BABYLON.Axis.Y;

    this.init = function() {
        this.gridPlane.material = material.mat_grid;
        this.gridPlane.isVisible = true;
        this.gridPlane.isPickable = false;
        this.gridPlane.position.y = -0.5;
        this.gridPlane.rotation.x = PIH;
        this.gridPlane.doNotSerialize = true;
        this.gridPlane.convertToUnIndexedMesh();
        this.gridPlane.freezeNormals();
        
        this.axisPlane.isVisible = false; // indicate symmetry-axis plane in AxisView scene
        this.axisPlane.isPickable = false;
        this.axisPlane.visibility = 0.3;
        this.axisPlane.renderOverlay = true;
        this.axisPlane.overlayAlpha = 0.5;
        this.axisPlane.overlayColor = BABYLON.Color3.FromHexString('#FF00FF');
        this.axisPlane.edgesWidth = 10;
        this.axisPlane.edgesColor = BABYLON.Color4.FromHexString('#FF00FFFF');
        this.axisPlane.doNotSerialize = true;
        this.axisPlane.enableEdgesRendering();
        this.axisPlane.convertToUnIndexedMesh();
        this.axisPlane.freezeNormals();

        this.symmPivot.isVisible = false; // indicate symmetry pivot center
        this.symmPivot.isPickable = false;
        this.symmPivot.visibility = 0.01;
        this.symmPivot.position.y = -0.5;
        this.symmPivot.edgesWidth = 6;
        this.symmPivot.edgesColor = BABYLON.Color4.FromHexString('#FF00FFFF');
        this.symmPivot.doNotSerialize = true;
        this.symmPivot.enableEdgesRendering();
        this.symmPivot.convertToUnIndexedMesh();
        this.symmPivot.freezeNormals();

        this.overlayPlane.isVisible = false;
        this.overlayPlane.isPickable = false;
        this.overlayPlane.visibility = 0.1;
        this.overlayPlane.renderOverlay = true;
        this.overlayPlane.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
        this.overlayPlane.overlayAlpha = 0.5;
        this.overlayPlane.edgesWidth = 0; // overrided
        this.overlayPlane.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
        this.overlayPlane.doNotSerialize = true;
        this.overlayPlane.enableEdgesRendering();
        this.overlayPlane.convertToUnIndexedMesh();
        this.overlayPlane.freezeNormals();

        this.overlayCube.isVisible = false;
        this.overlayCube.isPickable = false;
        this.overlayCube.visibility = 0.1;
        this.overlayCube.renderOverlay = true;
        this.overlayCube.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
        this.overlayCube.overlayAlpha = 0.5;
        this.overlayCube.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
        this.overlayCube.edgesWidth = 0; // overrided
        this.overlayCube.doNotSerialize = true;
        this.overlayCube.enableEdgesRendering();
        this.overlayCube.convertToUnIndexedMesh();
        this.overlayCube.freezeNormals();

        this.ghostBox.isVisible = false;
        this.ghostBox.isPickable = false;
        this.ghostBox.visibility = 0.1;
        this.ghostBox.renderOverlay = true;
        this.ghostBox.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
        this.ghostBox.overlayAlpha = 0.5;
        this.ghostBox.edgesWidth = 0; // overrided
        this.ghostBox.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
        this.ghostBox.doNotSerialize = true;
        this.ghostBox.enableEdgesRendering();
        this.ghostBox.convertToUnIndexedMesh();
        this.ghostBox.freezeNormals();
        this.clearGhostVoxels(); // init

        this.workPlane.position.y = -0.5;
        this.workPlane.bakeCurrentTransformIntoVertices();
        resetPivot(this.workPlane);
        this.workPlane.material = material.mat_workplane;
        this.workPlane.isVisible = false;
        this.workPlane.isPickable = true;
        this.workPlane.visibility = 0.3;
        this.workPlane.renderOverlay = true;
        this.workPlane.overlayColor = BABYLON.Color3.FromHexString(COL_AQUA);
        this.workPlane.overlayAlpha = 0.05;
        this.workPlane.doNotSerialize = true;
        this.workPlane.convertToUnIndexedMesh();
        this.workPlane.freezeNormals();
        this.setWorkPlane(this.workplaneAxis); // initial
    }

    this.setGrid = function() {
        setTimeout(() => {
            const radius = 2 * builder.SPS.mesh.getBoundingInfo().boundingSphere.radius;
            this.gridPlane.scaling.x = radius;
            this.gridPlane.scaling.y = radius;
            this.gridPlane.scaling.z = radius;
            this.gridPlane.material.gridRatio = 1 / radius;
        }, 100);
    }

    this.toggleWorkplane = function() {
        this.workPlane.isVisible = !this.workPlane.isVisible;
        ui.domWorkplane.checked = this.workPlane.isVisible;
        (this.workPlane.isVisible) ? uix.bindWorkplane() : uix.unbindWorkplane();
    }

    this.setWorkPlane = function(axis) { // BABYLON.Axis.X
        this.workplaneAxis = axis;
        this.workPlane.rotation = BABYLON.Vector3.Zero();
        if (axis.x == 1) this.workPlane.rotation.y = PIH;
        if (axis.y == 1) this.workPlane.rotation.x = PIH;
        if (axis.z == 1) this.workPlane.rotation.z = PIH;
    }

    this.resetWorkplane = function() {
        this.workPlane.position.x = 0;
        this.workPlane.position.y = -0.5;
        this.workPlane.position.z = 0;
        this.setWorkPlane(BABYLON.Axis.Y);
    }

    this.setAxisPlane = function(axis, pos) {
        this.axisPlane.isVisible = true;
        this.axisPlane.position = pos;
        this.axisPlane.rotation = BABYLON.Vector3.Zero();
        if (axis.x == 1) this.axisPlane.rotation.y = PIH;
        if (axis.y == 1) this.axisPlane.rotation.x = PIH;
        if (axis.z == 1) this.axisPlane.rotation.z = PIH;
    }

    this.setSymmPivot = function() {
        this.symmPivot.isVisible = (symmetry.axis !== '');
        if (ui.domSymmCenter.checked) { // world
            this.symmPivot.position = BABYLON.Vector3.Zero();
            this.symmPivot.position.y -= 0.5;
        } else { // local
            this.symmPivot.position = builder.SPS.mesh.getBoundingInfo().boundingSphere.centerWorld;
        }
    }

    this.toggleAxisPlane = function(isVisible) {
        this.axisPlane.isVisible = isVisible;
        this.symmPivot.isVisible = isVisible;
    }

    this.setOverlayPlane = function(pos, normAxis, hex = null) {
        this.overlayPlane.isVisible = true;
        this.overlayPlane.position = pos;
        this.overlayPlane.rotationQuaternion = BABYLON.Quaternion.RotationAxis(
            BABYLON.Vector3.Cross(BABYLON.Axis.Z, normAxis),         // axis
            Math.acos(BABYLON.Vector3.Dot(normAxis, BABYLON.Axis.Z)) // angle
        );
        if (hex) {
            this.overlayPlane.overlayColor = BABYLON.Color3.FromHexString(hex);
            this.overlayPlane.edgesColor = BABYLON.Color4.FromHexString(hex + 'FF');
        } else {
            this.overlayPlane.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
            this.overlayPlane.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
        }
        this.overlayPlane.edgesWidth = scene.activeCamera.radius/5;
    }

    this.setOverlayCube = function(pos, hex = null) {
        this.overlayCube.isVisible = true;
        this.overlayCube.position = pos;
        if (hex) {
            this.overlayCube.overlayColor = BABYLON.Color3.FromHexString(hex);
            this.overlayCube.edgesColor = BABYLON.Color4.FromHexString(hex + 'FF');
        } else {
            this.overlayCube.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
            this.overlayCube.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
        }
        this.overlayCube.edgesWidth = scene.activeCamera.radius/5;
    }

    this.clearOverlays = function() {
        this.overlayCube.isVisible = false;
        this.overlayPlane.isVisible = false;
    }

    this.drawGhostBox = function(pos, scale, hex) {
        this.ghostBox.isVisible = true;
        this.ghostBox.position = pos;
        this.ghostBox.scaling = scale;
        this.ghostBox.overlayColor = BABYLON.Color3.FromHexString(hex);
        this.ghostBox.edgesWidth = scene.activeCamera.radius/5;
    }

    this.clearGhostBox = function() {
        this.ghostBox.isVisible = false;
        this.ghostBox.position = BABYLON.Vector3.Zero();
        this.ghostBox.scaling = BABYLON.Vector3.Zero();
    }

    this.cloneGhostVoxel = function(pos, hex = '#C58A1B') {
        this.ghostVoxel.isVisible = true;
        this.ghostVoxel.material.diffuseColor = BABYLON.Color3.FromHexString(hex);
        this.ghostVoxel.thinInstanceAdd( BABYLON.Matrix.Translation(pos.x, pos.y, pos.z) );
    }

    this.clearGhostVoxels = function() {
        if (this.ghostVoxel) // dispose all instances
            this.ghostVoxel.dispose();
        this.ghostVoxel = BABYLON.MeshBuilder.CreateBox("ghostvoxel", { size: 1, sideOrientation: BABYLON.Mesh.FRONTSIDE, updatable: false }, scene);
        this.ghostVoxel.material = material.mat_ghost;
        this.ghostVoxel.isVisible = false;
    }

    this.init();
}


// -------------------------------------------------------
// Tool, ToolBakery


function Tool(scene) {
    this.name = 'camera';
    this.selected = [];
    this.isMouseDown = false;
    this.lastCamPos = null;
    this.pick = null;
    let startPos = null;
    let selVoxels = [];

    this.init = function() {
        this.toolSelector(this.name); // startup tool
    }

    this.add = function(pos) {
        helper.cloneGhostVoxel(pos, currentColor);
        this.selected.push(pos);
    }

    this.addSymmetry = function(pos) {
        pos = symmetry.invertPos(pos);
        this.add(pos);
    }

    this.remove = function(pos) {
        helper.cloneGhostVoxel(pos, COL_DELETE);
        this.selected.push(pos); // removing voxels onToolUp to prevent infinite-depth picking
    }

    this.removeSymmetry = function(pos) {
        this.remove(symmetry.invertPos(pos));
    }

    this.paint = function(index, pos) {
        builder.setVoxelColor(index, currentColor);
        helper.cloneGhostVoxel(pos, currentColor);
    }

    this.paintSymmetry = function(pos) {
        const index = symmetry.findIndexInvert(pos);
        if (index > -1) {
            builder.setVoxelColor(index, currentColor);
            helper.cloneGhostVoxel(builder.voxels[index].position, currentColor);
        }
    }

    this.eyedrop = function(hex) {
        currentColor = hex;
        uix.colorPicker0.value = BABYLON.Color3.FromHexString(currentColor);
    }

    this.bucket = function(hex) {
        for (let i = 0; i < builder.voxels.length; i++) {
            if (builder.voxels[i].color === hex)
                builder.voxels[i].color = currentColor;
        }
    }

    this.hideColor = function(hex) {
        palette.setColorVisible(hex, false);
    }

    this.isolateColor = function(hex) {
        builder.setVoxelsVisibility(false);
        palette.setColorVisible(hex, true);
    }
    
    this.bakeColor = function(hex) {
        bakery.bakeColor(hex);
    }

    this.pull = function(posBegin, posEnd, index) {
        for (let i = 0; i < this.selected.length; i++) { // prevent infinite-depth picking
            if (this.selected[i].equals(posBegin))
                return;
        }
        if (builder.findIndexByPosition(posEnd) == -1) {  // no duplicates on merge,
            builder.setVoxelPosition(index, posEnd);      // e.g. transform cause a merge of two parallel voxels
            builder.SPS.setParticles(index, index, true);
            this.selected.push(posEnd);
        }
    }

    this.pullSymmetry = function(posBegin, posEnd, index, axis) {
        index = symmetry.findIndexInvert(posBegin, axis);
        if (index == -1) return;
        posEnd = symmetry.invertPos(posEnd, axis);
        this.pull(posBegin, posEnd, index);
    }

    this.pullColor = function(norm, hex) {
        for (let i = 0; i < builder.voxels.length; i++) {
            if (builder.voxels[i].color == hex)
                builder.voxels[i].position.addInPlace(norm);
        }
    }

    let fixedHeight = 0;
    let sX,sY,sZ, eX,eY,eZ;
    this.box = function(endPos, isAdd, hex = null) {
        if (isAdd && fixedHeight > 0) // enable wall drawing
            endPos.y = startPos.y + fixedHeight - 1;

        if (endPos.x <= startPos.x && endPos.y <= startPos.y && endPos.z <= startPos.z) {
            sX = endPos.x;      eX = startPos.x;
            sY = endPos.y;      eY = startPos.y;
            sZ = endPos.z;      eZ = startPos.z;
        }
        else if (startPos.x <= endPos.x && startPos.y <= endPos.y && startPos.z <= endPos.z) {
            sX = startPos.x;    eX = endPos.x;
            sY = startPos.y;    eY = endPos.y;
            sZ = startPos.z;    eZ = endPos.z;
        }

        else if (endPos.x <= startPos.x && startPos.y <= endPos.y && endPos.z <= startPos.z) {
            sX = endPos.x;      eX = startPos.x;
            sY = startPos.y;    eY = endPos.y;
            sZ = endPos.z;      eZ = startPos.z;
        }
        else if (startPos.x <= endPos.x && endPos.y <= startPos.y && startPos.z <= endPos.z) {
            sX = startPos.x;    eX = endPos.x;
            sY = endPos.y;      eY = startPos.y;
            sZ = startPos.z;    eZ = endPos.z;
        }

        else if (startPos.x <= endPos.x && endPos.y <= startPos.y && endPos.z <= startPos.z) {
            sX = startPos.x;    eX = endPos.x;
            sY = endPos.y;      eY = startPos.y;
            sZ = endPos.z;      eZ = startPos.z;
        }
        else if (endPos.x <= startPos.x && startPos.y <= endPos.y && startPos.z <= endPos.z) {
            sX = endPos.x;      eX = startPos.x;
            sY = startPos.y;    eY = endPos.y;
            sZ = startPos.z;    eZ = endPos.z;
        }

        else if (startPos.x <= endPos.x && startPos.y <= endPos.y && endPos.z <= startPos.z) {
            sX = startPos.x;    eX = endPos.x;
            sY = startPos.y;    eY = endPos.y;
            sZ = endPos.z;      eZ = startPos.z;
        }
        else if (endPos.x <= startPos.x && endPos.y <= startPos.y && startPos.z <= endPos.z) {
            sX = endPos.x;      eX = startPos.x;
            sY = endPos.y;      eY = startPos.y;
            sZ = startPos.z;    eZ = endPos.z;
        }

        helper.drawGhostBox(
            startPos.add(endPos).divide(new BABYLON.Vector3(2, 2, 2)),
            new BABYLON.Vector3(1 + eX - sX, 1 + eY - sY, 1 + eZ - sZ),
            hex);

        this.selected = [];
        for (let x = sX; x <= eX; x++) {
            for (let y = sY; y <= eY; y++) {
                for (let z = sZ; z <= eZ; z++) {
                    this.selected.push(new BABYLON.Vector3(x, y, z));
                }
            }
        }
    }

    function castRay(pos) { // TODO: slow raycast
        const ray = BABYLON.Ray.CreateNewFromTo(
            camera.camera0.position.clone().scale(0.5), pos);
        //BABYLON.RayHelper.CreateAndShow(ray, scene, new BABYLON.Color3(0, 1, 1));
        return !ray.intersectsMesh(builder.SPS.mesh, true).hit; // equals to (if hit ghostVoxels)
    }

    this.fill = function(norm) {
        const endPos = { x: scene.pointerX, y: scene.pointerY };
        const minX = Math.min(startPos.x, endPos.x);
        const minY = Math.min(startPos.y, endPos.y);
        const maxX = Math.max(startPos.x, endPos.x);
        const maxY = Math.max(startPos.y, endPos.y);
        ui.domMarquee.style.top = minY + 'px';
        ui.domMarquee.style.left = minX + 'px';
        ui.domMarquee.style.width = maxX - minX + 'px';
        ui.domMarquee.style.height = maxY - minY + 'px';

        selVoxels = builder.voxels.filter((i) => 
            isTargetIn(startPos, endPos, i.position, scene.activeCamera));

        this.selected = [];
        helper.clearGhostVoxels();
        for (let i = 0; i < selVoxels.length; i++) {
            const pos = selVoxels[i].position.add(norm);
            if (castRay(pos)) {
                helper.cloneGhostVoxel(pos, currentColor);
                this.selected.push(pos);
            }
        }
    }

    this.pickWorkplane = function(pick, norm) {
        norm.z = parseFloat(norm.z.toFixed(3)); // fix workplane bug at border 1,0,-1.5

        const pos = pick.pickedPoint.floor();
        if (helper.workplaneAxis.x == 1) {
            if (norm.x < 0) pos.x = helper.workPlane.position.x + 0.5;
            if (norm.x > 0) pos.x = helper.workPlane.position.x - 0.5;
            pos.y += 1;
            pos.z += 0.5;
        }
        else if (helper.workplaneAxis.y == 1) {
            pos.x += 0.5;
            if (norm.y < 0) pos.y = helper.workPlane.position.y + 0.5;
            if (norm.y > 0) pos.y = helper.workPlane.position.y - 0.5;
            pos.z += 0.5;
        }
        else if (helper.workplaneAxis.z == 1) {
            pos.x += 0.5;
            pos.y += 1;
            if (norm.z < 0) pos.z = helper.workPlane.position.z + 0.5;
            if (norm.z > 0) pos.z = helper.workPlane.position.z - 0.5;
        }
        return pos;
    }

    this.onToolDown = function(pick) {
        if (pick && pick.faceId == -1) return;
        if (!this.pauseCameraControls()) return;
        const index = builder.SPS.pickedParticles[pick.faceId].idx;
        const norm = pick.getNormal(true);
        let pos = builder.SPS.particles[index].position;

        if (pick.pickedMesh == helper.workPlane) {
            if (!['add', 'boxadd', 'fill'].includes(this.name))
                return;
            pos = this.pickWorkplane(pick, norm);
        }

        switch (this.name) {
            case 'add':
                this.add(pos.add(norm));
                if (symmetry.axis !== '')
                    this.addSymmetry(pos.add(norm));
                break;
            case 'remove':
                this.remove(pos);
                if (symmetry.axis !== '')
                    this.removeSymmetry(pos);
                break;
            case 'pull':
                this.pull(pos, pos.add(norm), index);
                if (symmetry.axis !== '')
                    this.pullSymmetry(pos, pos.add(norm), index, symmetry.axis);
                updateShadowMap(); // important
                break;
            case 'pullcolor':
                this.pullColor(norm, builder.voxels[index].color);
                updateShadowMap();
                break;
            case 'paint':
                this.paint(index, pos);
                if (symmetry.axis !== '')
                    this.paintSymmetry(pos);
                break;
            case 'eyedrop':
                this.eyedrop(builder.voxels[index].color);
                break;
            case 'bucket':
                this.bucket(builder.voxels[index].color);
                break;
            case 'hidecolor':
                this.hideColor(builder.voxels[index].color);
                break;
            case 'isolatecolor':
                this.isolateColor(builder.voxels[index].color);
                break;
            case 'bakecolor':
                this.bakeColor(builder.voxels[index].color);
                break;
            case 'boxadd':
                this.selected.push(pos.add(norm)); // allow to draw one voxel
                if (symmetry.axis !== '')
                    this.addSymmetry(pos.add(norm));
                startPos = pos.add(norm);
                fixedHeight = parseInt(ui.domBoxToolHeight.value);
                break;
            case 'boxrem':
                this.selected.push(pos);  // allow to remove one voxel
                if (symmetry.axis !== '')
                    this.removeSymmetry(pos);
                startPos = pos;
                break;
            case 'boxpaint':
                this.selected.push(pos);
                startPos = pos;
                break;
            case 'boxhide':
                this.selected.push(pos);
                startPos = pos;
                break;
            case 'fill':
                startPos = { x: scene.pointerX, y: scene.pointerY };
                ui.domMarquee.style.display = 'unset';
                break;
        }
    }

    this.onToolMove = function(pick) {
        if (pick && pick.faceId == -1) return;
        const index = builder.SPS.pickedParticles[pick.faceId].idx;
        const norm = pick.getNormal(true);
        let pos = builder.SPS.particles[index].position;

        if (pick.pickedMesh == helper.workPlane) {
            if (!['add', 'boxadd', 'fill'].includes(this.name))
                return;
            pos = this.pickWorkplane(pick, norm);
        }

        switch (this.name) {
            case 'add':
                helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                if (this.isMouseDown && this.pauseCameraControls()) {
                    this.add(pos.add(norm));
                    if (symmetry.axis !== '')
                        this.addSymmetry(pos.add(norm));
                }
                break;
            case 'remove':
                helper.setOverlayCube(pos, COL_DELETE);
                if (this.isMouseDown && this.pauseCameraControls()) {
                    this.remove(pos);
                    if (symmetry.axis !== '')
                        this.removeSymmetry(pos);
                }
                break;
            case 'pull':
                helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                if (this.isMouseDown && this.pauseCameraControls()) {
                    this.pull(pos, pos.add(norm), index);
                    if (symmetry.axis !== '')
                        this.pullSymmetry(pos, pos.add(norm), index, symmetry.axis);
                    updateShadowMap(); // important
                }
                break;
            case 'pullcolor':
                helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                break;
            case 'paint':
                helper.setOverlayCube(pos);
                if (this.isMouseDown && this.pauseCameraControls()) {
                    this.paint(index, pos);
                    if (symmetry.axis !== '')
                        this.paintSymmetry(pos);
                }
                break;
            case 'eyedrop':
                helper.setOverlayCube(pos);
                if (this.isMouseDown && this.pauseCameraControls())
                    this.eyedrop(builder.voxels[index].color);
                break;
            case 'bucket':
                helper.setOverlayCube(pos);
                break;
            case 'hidecolor':
                helper.setOverlayCube(pos);
                break;
            case 'isolatecolor':
                helper.setOverlayCube(pos);
                break;
            case 'bakecolor':
                helper.setOverlayCube(pos);
                break;
            case 'boxadd':
                helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                if (startPos && this.isMouseDown && this.pauseCameraControls())
                    this.box(pos.add(norm), true, currentColor);
                break;
            case 'boxrem':
                helper.setOverlayCube(pos, COL_DELETE);
                if (startPos && this.isMouseDown && this.pauseCameraControls())
                    this.box(pos, false, COL_DELETE);
                break;
            case 'boxpaint':
                helper.setOverlayCube(pos);
                if (startPos && this.isMouseDown && this.pauseCameraControls())
                    this.box(pos, false, currentColor);
                break;
            case 'boxhide':
                helper.setOverlayCube(pos);
                if (startPos && this.isMouseDown && this.pauseCameraControls())
                    this.box(pos, false, COL_HIDE);
                break;
            case 'fill':
                helper.setOverlayPlane(pos.add(norm.scale(0.5)), norm);
                if (this.isMouseDown && this.pauseCameraControls())
                    this.fill(norm);
                break;
        }
    }

    this.onToolUp = function() {
        if (!this.pauseCameraControls()) return;
        switch (this.name) {
            case 'add':
                if (this.selected.length > 0) {
                    for (let i = 0; i < this.selected.length; i++)
                        builder.addNoDup(this.selected[i], currentColor, true);
                    builder.createSPS();
                    palette.create();
                    memory.record();
                }
                break;
            case 'remove':
                if (this.selected.length > 0) {
                    for (let i = 0; i < this.selected.length; i++)
                        builder.removeByPosition(this.selected[i]);
                    builder.createSPS();
                    palette.create();
                    memory.record();
                }
                break;
            case 'pull':
                builder.createSPS();
                palette.create();
                memory.record();
                break;
            case 'pullcolor':
                builder.createSPS();
                palette.create();
                memory.record();
                break;
            case 'paint':
                builder.createSPS();
                palette.create();
                memory.record();
                break;
            case 'bucket':
                builder.createSPS();
                palette.create();
                memory.record();
                break;
            case 'hidecolor':
                builder.createSPS();
                palette.create();
                memory.record();
                break;
            case 'isolatecolor':
                builder.createSPS();
                palette.create();
                memory.record();
                break;
            case 'bakecolor':
                break;
            case 'boxadd':
                if (this.selected.length > 0) {
                    for (let i = 0; i < this.selected.length; i++) {
                        builder.addNoDup(this.selected[i], currentColor, true);
                        if (symmetry.axis !== '')
                            builder.addNoDup(symmetry.invertPos(this.selected[i]), currentColor, true);
                    }
                    builder.createSPS();
                    palette.create();
                    memory.record();
                }
                break;
            case 'boxrem':
                if (this.selected.length > 0) {
                    for (let i = 0; i < this.selected.length; i++) {
                        builder.removeByPosition(this.selected[i]);
                        if (symmetry.axis !== '')
                            builder.removeByPosition(symmetry.invertPos(this.selected[i]));
                    }
                    builder.createSPS();
                    palette.create();
                    memory.record();
                }
                break;
            case 'boxpaint':
                if (this.selected.length > 0) {
                    for (let i = 0; i < this.selected.length; i++) {
                        let idx = builder.findIndexByPosition(this.selected[i]);
                        if (idx > -1) {
                            builder.voxels[idx].color = currentColor;
                            if (symmetry.axis !== '') {
                                idx = builder.findIndexByPosition(symmetry.invertPos(this.selected[i]));
                                if (idx > -1)
                                    builder.voxels[idx].color = currentColor;
                            }
                        }
                    }
                    builder.createSPS();
                    palette.create();
                    memory.record();
                }
                break;
            case 'boxhide':
                if (this.selected.length > 0) {
                    for (let i = 0; i < this.selected.length; i++) {
                        const idx = builder.findIndexByPosition(this.selected[i]);
                        if (idx > -1)
                            builder.setVoxelVisible(idx, false);
                    }
                    builder.SPS.setParticles();
                    palette.create();
                    memory.record();
                    updateShadowMap();
                }
                break;
            case 'fill':
                if (this.selected.length > 0) {
                    for (let i = 0; i < this.selected.length; i++)
                        builder.addNoDup(this.selected[i], currentColor, true);
                    builder.createSPS();
                    palette.create();
                    memory.record();
                }
                break;
        }
    }

    const predicate = function(mesh) {
        if (helper.workPlane.isVisible) {
            return mesh.name == 'SPS' || mesh == helper.workPlane;
        } else {
            return mesh.name == 'SPS';
        }
    };

    this.handleToolDown = function(ev) {
        this.isMouseDown = true;
        this.lastCamPos = scene.activeCamera.position.clone();
        if (this.name !== 'camera') {
            this.pick = scene.pick(scene.pointerX, scene.pointerY, predicate);
            tool.onToolDown(this.pick);
            if (helper.workPlane.isVisible)
                uix.disposeWorkplaneGizmo();
        }
    }

    this.handleToolMove = function(ev) {
        if (this.name !== 'camera') { // speed up navigation
            setTimeout(() => {
                this.pick = scene.pick(scene.pointerX, scene.pointerY, predicate);
                if (this.pick.hit) {
                    tool.onToolMove(this.pick);
                } else {
                    helper.clearOverlays(); // important: prevent last ghost/overlay after drawing
                }
            }, FPS_TOOLMOVE);
        }
    }

    this.handleToolUp = function(ev) {
        this.isMouseDown = false;
        tool.onToolUp();
        
        selVoxels = [];
        this.selected = [];
        helper.clearGhostBox();
        helper.clearGhostVoxels();
        setTimeout(() => { // a little hack to prevent last ghost/overlay in touchscreen
            helper.clearOverlays();
        }, 10);
        ui.domMarquee.style = "display: none; left: 0; top: 0; width: 0; height: 0;";
        
        helper.setGrid();
        if (helper.workPlane.isVisible)
            uix.bindWorkplane();

        scene.activeCamera.attachControl(canvas, true);
    }

    this.toolSelector = function(toolName) {
        this.name = toolName;

        const elem = document.getElementsByClassName('tool_' + this.name);
        for (const i of document.querySelectorAll('li'))
            if (i.classList.contains("tool_selector"))
                i.classList.remove("tool_selector");
        for (const i of document.querySelectorAll('button'))
            if (i.classList.contains("tool_selector"))
                i.classList.remove("tool_selector");
        for (let i = 0; i < elem.length; i++)
            elem[i].classList.add("tool_selector");

        helper.clearOverlays();
    }

    this.pauseCameraControls = function() { // prevent drawing and camera-control conflict
        if (!this.lastCamPos.equals(scene.activeCamera.position)) {
            return false;
        } else {
            scene.activeCamera.detachControl(canvas);
            return true;
        }
    }

    this.init();
}

function ToolBakery(scene) {
    this.name = 'xform';
    this.selected = [];
    this.pick = null;

    this.onToolDown = function() {
        this.pick = scene.pick(scene.pointerX, scene.pointerY, (mesh) => {
            return bakery.meshes.includes(mesh);
        });

        if (!this.pick.hit) {
            bakery.clearSelected();
            uix.unbindTransformGizmo();
            return;
        }

        switch (this.name) {
            case 'xform': // bind transform gizmo to baked meshes
                bakery.clearSelected();
                uix.bindTransformGizmo([this.pick.pickedMesh]);
                break;
            case 'merge': // merge by select and apply
                const idx = this.selected.indexOf(this.pick.pickedMesh);
                if (idx == -1) {
                    this.selected.push(this.pick.pickedMesh);
                    this.pick.pickedMesh.edgesWidth = 4;
                    this.pick.pickedMesh.edgesColor = BABYLON.Color4.FromHexString(COL_ORANGE + 'FF');
                    this.pick.pickedMesh.enableEdgesRendering();
                } else {
                    this.selected.splice(idx, 1);
                    this.pick.pickedMesh.disableEdgesRendering();
                }
                break;
        }
    }

    this.onToolMove = function() {
        //
    }

    this.onToolUp = function() {
        //
    }

    this.mergeBakes = function() {
        if (this.selected.length == 1) {
            ui.notification('pick more bakes...');
            return;
        }
        if (this.selected.length > 1) {
            for (let i = 0; i < bakery.meshes.length; i++)
                bakery.meshes[i].renderOverlay = false;

            bakery.mergeSelected(this.selected);

            for (let i = 0; i < this.selected.length; i++)
                this.selected[i].disableEdgesRendering();

            this.selected = [];
            this.toolSelector('xform');
        } else {
            ui.notification('select bakes and hit merge');
        }
    }

    this.cancelTools = function() {
        if (this.selected.length > 0) {
            for (let i = 0; i < this.selected.length; i++)
                this.selected[i].disableEdgesRendering();
            this.selected = [];
        }
        this.toolSelector('xform');
    }

    this.onGizmoAttached = function(mesh) {
        bakery.clearSelected(); // on user select
        bakery.selectMesh(mesh);
        if (ui.domMaterialAutoUpdate.checked)
            bakery.getMaterial();
    }

    this.toolSelector = function(toolName) {
        this.name = toolName;

        for (const i of document.querySelectorAll('li'))
            if (i.classList.contains("tool_bakery_selector"))
                i.classList.remove("tool_bakery_selector");
        for (const i of document.querySelectorAll('button'))
            if (i.classList.contains("tool_bakery_selector"))
                i.classList.remove("tool_bakery_selector");
        const elem = document.getElementsByClassName('tool_' + this.name)[0];
        if (elem)
            elem.classList.add("tool_bakery_selector");

        bakery.clearSelected();
        uix.unbindTransformGizmo();
    }
}


// -------------------------------------------------------
// Symmetry


function Symmetry() {
    this.axis = ''; // 'x'

    this.setAxis = function(axis) {
        this.axis = axis;
        helper.toggleAxisPlane(false);
        helper.setSymmPivot();
        if (axis == 'x') {
            helper.setAxisPlane(BABYLON.Axis.X, BABYLON.Vector3.Zero());
            ui.domSymmAxis.innerHTML = 'X';
            ui.domSymmAxis.style.color = COL_AXIS_X;
            ui.domSymmAxis2.innerHTML = 'X';
            ui.domSymmAxis2.style.color = COL_AXIS_X;
        } else if (axis == 'y') {
            helper.setAxisPlane(BABYLON.Axis.Y, BABYLON.Vector3.Zero());
            ui.domSymmAxis.innerHTML = 'Y';
            ui.domSymmAxis.style.color = COL_AXIS_Y;
            ui.domSymmAxis2.innerHTML = 'Y';
            ui.domSymmAxis2.style.color = COL_AXIS_Y;
        } else if (axis == 'z') {
            helper.setAxisPlane(BABYLON.Axis.Z, BABYLON.Vector3.Zero());
            ui.domSymmAxis.innerHTML = 'Z';
            ui.domSymmAxis.style.color = COL_AXIS_Z;
            ui.domSymmAxis2.innerHTML = 'Z';
            ui.domSymmAxis2.style.color = COL_AXIS_Z;
        } else {
            ui.domSymmAxis.innerHTML = 'None';
            ui.domSymmAxis.style.color = '#98a1ac';
            ui.domSymmAxis2.innerHTML = 'S';
            ui.domSymmAxis2.style.color = '#FB4BFB';
        }
    }

    this.switchAxis = function() {
        if (this.axis == '') {
            this.setAxis('x');
        } else if (this.axis == 'x') {
            this.setAxis('y');
        } else if (this.axis == 'y') {
            this.setAxis('z');
        } else if (this.axis == 'z') {
            this.setAxis('');
            this.resetAxis();
        }
    }

    this.resetAxis = function() {
        this.setAxis('');
    }

    this.symmetrizeVoxelPositions = function(side) {
        if (this.axis == '') {
            ui.notification('select symmetry axis');
            return;
        }
        builder.setVoxelsVisibility(true);
        if (side == 1) { // pos-to-neg
            this.deleteHalf(1);
            this.mirrorVoxels();
        } else { // neg-to-pos
            this.deleteHalf(-1);
            this.mirrorVoxels();
        }
        builder.createSPS();
        palette.create();
        memory.record();
    }

    this.mirrorVoxelPositions = function() {
        if (this.axis == '') {
            ui.notification('select symmetry axis');
            return;
        }
        builder.setVoxelsVisibility(true);
        this.invertVoxels();
        builder.createSPS();
        palette.create();
        memory.record();
    }

    this.deleteHalfVoxels = function(side) {
        if (this.axis == '') {
            ui.notification('select symmetry axis');
            return;
        }
        builder.setVoxelsVisibility(true);
        this.deleteHalf(side);
        builder.createSPS();
        palette.create();
        memory.record();
    }

    this.deleteHalf = function(side) { // preserve 0 borders, prevent duplicates at the middle
        let p = null; // modo reminder: 0.00000001 for vertex, voxel is 1.0, >=0.1 is more than enough!
        for (let i = 0; i < builder.SPS.particles.length; i++) {
            p = builder.SPS.particles[i].position;
            if (this.axis == 'x') {
                if (side == -1 && this.center(p.x) <= -0.1) builder.removeByPosition(p);
                if (side == 1  && this.center(p.x) >= 0.1)  builder.removeByPosition(p);
            }
            if (this.axis == 'y') {
                if (side == -1 && this.center(p.y) <= -0.1) builder.removeByPosition(p);
                if (side == 1  && this.center(p.y) >= 0.1)  builder.removeByPosition(p);
            }
            if (this.axis == 'z') {
                if (side == -1 && this.center(p.z) <= -0.1) builder.removeByPosition(p);
                if (side == 1  && this.center(p.z) >= 0.1)  builder.removeByPosition(p);
            }
        }
        p = null;
    }

    this.mirrorVoxels = function() {
        for (let i = 0; i < builder.voxels.length; i++)
            builder.addNoDup(this.invertPos(builder.voxels[i].position), builder.voxels[i].color, true);
    }

    this.invertVoxels = function() {
        for (let i = 0; i < builder.voxels.length; i++)
            builder.voxels[i].position = this.invertPos(builder.voxels[i].position);
    }

    this.invertPos = function(pos) { // invert positive to negative and reverse
        if (this.axis == 'x') pos = new BABYLON.Vector3(this.center2(pos.x), pos.y, pos.z);
        if (this.axis == 'y') pos = new BABYLON.Vector3(pos.x, this.center2(pos.y), pos.z);
        if (this.axis == 'z') pos = new BABYLON.Vector3(pos.x, pos.y, this.center2(pos.z));
        return pos;
    }

    this.center = function(p) { // calculate position from center
        if (ui.domSymmCenter.checked) { // world center
            if (this.axis == 'x') return -p;
            if (this.axis == 'y') return -p;
            if (this.axis == 'z') return -p;
        } else { // local center
            const center = builder.SPS.mesh.getBoundingInfo().boundingBox.centerWorld;
            if (this.axis == 'x') return center.x - p;
            if (this.axis == 'y') return center.y - p;
            if (this.axis == 'z') return center.z - p;
        }
    }

    this.center2 = function(p) { // calculate position from center*2
        if (ui.domSymmCenter.checked) { // world center
            if (this.axis == 'x') return -p;
            if (this.axis == 'y') return -p;
            if (this.axis == 'z') return -p;
        } else { // local center
            const center = builder.SPS.mesh.getBoundingInfo().boundingBox.centerWorld;
            if (this.axis == 'x') return (center.x * 2) - p;
            if (this.axis == 'y') return (center.y * 2) - p;
            if (this.axis == 'z') return (center.z * 2) - p;
        }
    }

    this.findIndexInvert = function(pos) {
        // return index at mirrored position, or '-1' if not exist
        return builder.findIndexByPosition(this.invertPos(pos));
    }
}


// -------------------------------------------------------
// Voxelizer


function Voxelizer() {
    this.voxelize = function(mesh) {
        const scale = parseInt(document.getElementById('input-voxelizer-scale').value);
        const dense = parseInt(document.getElementById('input-voxelizer-dense').value);
        
        // calculate random points per surface area,
        // voxel is 1x1x1, larger mesh size require more voxels,
        // and longer surface require more points to fill details.
        normalizeMesh(mesh, scale);
        let points = getRandomPointsOnMeshSurface(mesh, dense);

        let data = [];
        for (let i = 0; i < points.length; i++) {
            data.push({ position: points[i], color: currentColor, visible: true });
        }
        ui.setMode(0);
        builder.loadData(data, false, true);
        memory.clear();
        symmetry.resetAxis();
        camera.frame();
        
        points = null;
        data = null;
    }

    this.voxelize2D = function(imgData) {
        engine.displayLoadingUI();
        const ratio = parseFloat(document.getElementById('input-voxelizer-ratio').value);
        const zUp = parseBool(document.getElementById('input-voxelizer-zup').checked);
        const img = new Image();
        img.src = imgData;
        img.onload = () => {
            const c = document.createElement('canvas');
            const cx = c.getContext('2d');

            const dim = aspectRatioFit(img.width, img.height, 10*ratio, 10*ratio);
            c.width = dim.width;
            c.height = dim.height;

            cx.msImageSmoothingEnabled = false;
            cx.mozImageSmoothingEnabled = false;
            cx.webkitImageSmoothingEnabled = false;
            cx.imageSmoothingEnabled = false;
            cx.drawImage(img, 0, 0, c.width, c.height);

            let data = [];
            let imageData = cx.getImageData(0, 0, c.width, c.height).data;
            let x,y,r,g,b,a;
            for (let i = 0; i < imageData.length; i += 4) {
                if (imageData[i + 3] > 0) {
                    r = imageData[i];
                    g = imageData[i + 1];
                    b = imageData[i + 2];
                    x = (i / 4) % c.width;
                    y = ~~(i / 4 / c.width);
                    if (zUp) {
                        data.push({
                            position: new BABYLON.Vector3(x, dim.height-y-1, 0).floor(),
                            color: rgbIntToHex(r, g, b),
                            visible: true
                        });
                    } else {
                        data.push({
                            position: new BABYLON.Vector3(x, 0, y).floor(),
                            color: rgbIntToHex(r, g, b),
                            visible: true
                        });
                    }
                }
            }
            builder.loadData(data, false, true);
            memory.clear();
            symmetry.resetAxis();
            camera.frame();
            engine.hideLoadingUI();

            data = null;
            imgData = null;
            imageData = null;
        }
    }

    this.importMesh = function(url) {
        engine.displayLoadingUI();
        let mesh = null;
        BABYLON.SceneLoader.LoadAssetContainerAsync(url, "", scene, null, '.obj')
            .then((container) => {
                mesh = BABYLON.Mesh.MergeMeshes(container.meshes, true, true);
                container.removeAllFromScene();
                voxelizer.voxelize(mesh);
                mesh.dispose();
                mesh = null;
                engine.hideLoadingUI();
            }).catch((err) => {
                if (mesh) mesh.dispose();
                mesh = null;
                engine.hideLoadingUI();
                ui.notification("unable to import model");
                console.error(err.message);
            });
    }

    this.importMeshGLB = function(url) {
        engine.displayLoadingUI();
        let mesh = null;
        BABYLON.SceneLoader.LoadAssetContainerAsync(url, "", scene, null, '.glb')
            .then((container) => {
                let meshes = [];
                for (let i = 0; i < container.meshes.length; i++) {
                    if (container.meshes[i].name !== '__root__')
                        meshes.push(container.meshes[i]);
                }
                if (meshes.length > 0) {
                    mesh = BABYLON.Mesh.MergeMeshes(meshes, true, true);
                    voxelizer.voxelize(mesh);
                    mesh.dispose();
                } else {
                    ui.notification('unable to find meshes');
                }
                container.removeAllFromScene();
                meshes = null;
                mesh = null;
                engine.hideLoadingUI();
            }).catch((err) => {
                if (mesh) mesh.dispose();
                mesh = null;
                engine.hideLoadingUI();
                ui.notification("unable to import model");
                console.error(err.message);
            });
    }

    this.pasteBase64Image = function() {
        navigator.clipboard.readText()
            .then(url => {
                if (url.startsWith('data:image/')) {
                    voxelizer.voxelize2D(url);
                } else {
                    ui.notification('invalid base64 image');
                }
            }).catch(err => {
                ui.notification('failed to read clipboard data');
            });
    }

    this.pasteObjBase64 = function() {
        navigator.clipboard.readText()
            .then(url => {
                if (url.startsWith('data:application/octet-stream;')) {
                    voxelizer.importMesh(url);
                } else {
                    ui.notification('invalid base64 obj');
                }
            }).catch(err => {
                ui.notification('failed to read clipboard data');
            });
    }

    this.pasteModelUrl = function() {
        navigator.clipboard.readText()
            .then(url => {
                url = url.toLowerCase();
                if (url.startsWith('https://') && url.endsWith('.obj')) {
                    voxelizer.importMesh(url);
                } else if (url.startsWith('https://') && url.endsWith('.glb')) {
                    voxelizer.importMeshGLB(url);
                } else {
                    ui.notification('invalid obj/glb url');
                }
            }).catch(err => {
                ui.notification('failed to read clipboard data');
            });
    }
}


// -------------------------------------------------------
// Generator


function Generator() {
    this.createGrid = function(isPlane = false) {
        const isFill = document.getElementById('input-grid-fill').checked;
        const X = (parseInt(document.getElementById('input-grid-x').value) - 1) / 2;
        let Y = (parseInt(document.getElementById('input-grid-y').value) - 1) / 2;
        const Z = (parseInt(document.getElementById('input-grid-z').value) - 1) / 2;
        if (isPlane) Y = 0;
        let data = [];
        if (isFill) {
            for (let x = -X; x <= X; x++) {
                for (let y = 0; y <= Y * 2; y++) {
                    for (let z = -Z; z <= Z; z++) {
                        data.push({
                            position: new BABYLON.Vector3(x, y, z),
                            color: currentColor,
                            visible: true
                        });
                    }
                }
            }
        } else {
            for (let x = -X; x <= X; x++) {
                for (let y = 0; y <= Y * 2; y++) {
                    for (let z = -Z; z <= Z; z++) {
                        if ((x <= -X || y <= 0 || z <= -Z) ||
                            (x >= X || y >= Y * 2 || z >= Z)) {
                            data.push({
                                position: new BABYLON.Vector3(x, y, z),
                                color: currentColor,
                                visible: true
                            });
                        }
                    }
                }
            }
        }
        if (data.length > MAXAMOUNT)
            ui.notification('warning: exceed 64k voxels', 5000);
        builder.loadData(data, false, false);
        memory.clear();
        symmetry.resetAxis();
        camera.frame();
        data = null;
    }

    this.createIsometric = function() {
        const size = (parseInt(document.getElementById('input-isometric-size').value) - 1) / 2;
        let data = [];
        for (let x = -size; x <= size; x++) {
            for (let y = 0; y <= size * 2; y++) {
                for (let z = -size; z <= size; z++) {
                    if (x <= -size || y <= 0 || z <= -size)
                        data.push({
                            position: new BABYLON.Vector3(x, y, z),
                            color: currentColor,
                            visible: true
                        });
                }
            }
        }
        builder.loadData(data, false, false);
        memory.clear();
        symmetry.resetAxis();
        camera.frame();
        data = null;
    }

    this.createTerrain = function() {
        const isHeightGrad = document.getElementById('input-terrain-grad').checked;
        const X = parseInt(document.getElementById('input-terrain-x').value) / 2;
        const Y = parseInt(document.getElementById('input-terrain-y').value);
        const Z = parseInt(document.getElementById('input-terrain-z').value) / 2;
        let perlin = new ClassicalNoise();
        let data = [];
        let colArrayHigh = gradientHexArray('#C07D21', '#20BC20', Y);
        let colArrayLow  = gradientHexArray('#0000EE', '#20BC20', Y);
        let xoff = 0;
        let zoff = 0;
        let v = 0;
        for (let x = -X; x < X; x++) {
            for (let z = -Z; z < Z; z++) {
                xoff = (0.4/Y) * x; // fill x and z
                zoff = (0.4/Y) * z; // relative to Y
                v = ~~(perlin.noise(xoff, 0, zoff) * Y);
                if (v >= 0) {
                    data.push({
                        position: new BABYLON.Vector3(x, v, z),
                        color: (isHeightGrad) ? colArrayHigh[ v ] : currentColor,
                        visible: true
                    });
                } else {
                    data.push({
                        position: new BABYLON.Vector3(x, v, z),
                        color: (isHeightGrad) ? colArrayLow[ Math.abs(v) ] : currentColor,
                        visible: true
                    });
                }
            }
        }
        if (data.length > MAXAMOUNT)
            ui.notification('warning: exceed 64k voxels', 5000);
        builder.loadData(data, false, true);
        memory.clear();
        symmetry.resetAxis();
        camera.frame();
        perlin.dispose();
        perlin = null;
        data = null;
        colArrayHigh = null;
        colArrayLow = null;
    }

    this.createSphere = function() { // source: Babylon.js createSphere()
        const X = (parseInt(document.getElementById('input-grid-x').value) - 1) / 2;
        const Y = (parseInt(document.getElementById('input-grid-y').value) - 1) / 2;
        const Z = (parseInt(document.getElementById('input-grid-z').value) - 1) / 2;
        const totalZRotSteps = 2 + ((X+Y+Z) * 2); // pseudo relativity
        const totalYRotSteps = 2 * totalZRotSteps;
        let data = [];
        for (let z = 0; z <= totalZRotSteps; z++) {
            const normalizedZ = z / totalZRotSteps;
            const angleZ = normalizedZ * Math.PI;
            for (let y = 0; y <= totalYRotSteps; y++) {
                const afterRotZ = BABYLON.Vector3.TransformCoordinates(BABYLON.Vector3.Up(), BABYLON.Matrix.RotationZ(-angleZ));
                const complete = BABYLON.Vector3.TransformCoordinates(afterRotZ, BABYLON.Matrix.RotationY((y / totalYRotSteps) * PI2));
                data.push({
                    position: complete.multiplyByFloats(X, Y, Z).floor(),
                    color: currentColor,
                    visible: true
                });
            }
        }
        if (data.length > MAXAMOUNT)
            ui.notification('warning: exceed 64k voxels', 5000);
        builder.loadData(data, true, true);
        memory.clear();
        symmetry.resetAxis();
        camera.frame();
        data = null;
    }

    this.createRandom = function() {
        const X = (parseInt(document.getElementById('input-grid-x').value) - 1) / 2;
        const Y = (parseInt(document.getElementById('input-grid-y').value) - 1) / 2;
        const Z = (parseInt(document.getElementById('input-grid-z').value) - 1) / 2;
        let data = [];
        let colors = [];
        for (let i = 0; i < 10; i++)
            colors.push(randomHexColor());
        for (let x = -X; x <= X; x++) {
            for (let y = 0; y <= Y * 2; y++) {
                for (let z = -Z; z <= Z; z++) {
                    if (Math.random() < 0.05) {
                        data.push({
                            position: new BABYLON.Vector3(x, y, z),
                            color: colors[Math.floor(Math.random() * colors.length)],
                            visible: true
                        });
                    }
                }
            }
        }
        if (data.length > MAXAMOUNT)
            ui.notification('warning: exceed 64k voxels', 5000);
        builder.loadData(data, false, false);
        memory.clear();
        symmetry.resetAxis();
        camera.frame();
        data = null;
        colors = null;
    }
}


// -------------------------------------------------------
// Bakery


function Bakery(scene) {
    this.meshes = [];
    this.selected = null;
    this.pick = null;
    this.lastSelected = null;

    this.exportOptions = {
        shouldExportNode: (node) => {
            return bakery.meshes.includes(node);
        }
    };
    
    this.bakeToMesh = function(isTestColor, voxels = builder.voxels) {
        const baked = this.reconstructMesh('baked', isTestColor, voxels);
        resetPivot(baked);

        baked.material = material.mat_pbr.clone('baked');

        baked.checkCollisions = true;
        baked.receiveShadows = true;
        scene.lights[1].getShadowGenerator().addShadowCaster(baked);

        this.meshes.push(baked);
    }

    this.newBake = function(voxels = null) {
        engine.displayLoadingUI();
        setTimeout(() => {
            ui.setMode(1);
            material.setPBRTexture();
            material.update();

            if (voxels) {
                this.bakeToMesh(true, voxels);
            } else {
                this.bakeToMesh(true);
            }

            uix.bindTransformGizmo(this.meshes[this.meshes.length-1]);
            uix.gizmo.attachToMesh(this.meshes[this.meshes.length-1]);

            camera.frame();
            updateShadowMap();
            engine.hideLoadingUI();
        }, 100);
    }

    this.bakeColor = function(hex) {
        engine.displayLoadingUI();
        setTimeout(() => {
            ui.setMode(1);
            material.setPBRTexture();
            material.update();

            let voxels = [];
            for (let i = 0; i < builder.voxels.length; i++) {
                if (builder.voxels[i].color == hex)
                    voxels.push(builder.voxels[i]);
            }
            this.bakeToMesh(true, voxels);
            voxels = null;

            uix.bindTransformGizmo(this.meshes[this.meshes.length-1]);
            uix.gizmo.attachToMesh(this.meshes[this.meshes.length-1]);

            camera.frame();
            updateShadowMap();
            engine.hideLoadingUI();
        }, 100);
    }

    this.bakeAllColors = async function() {
        if (!await ui.showConfirm('Clear and bake all voxels<br>grouped by colors, continue?')) return;
        engine.displayLoadingUI();
        setTimeout(() => {
            ui.setMode(1);
            material.setPBRTexture();
            material.update();
            this.clearBakes();

            for (let i = 0; i < palette.uniqueColors.length; i++)
                this.bakeToMesh(true, builder.getVoxelsByColor(palette.uniqueColors[i]));

            camera.frame();
            updateShadowMap();
            engine.hideLoadingUI();
        }, 100);
    }

    this.cloneSelected = function() {
        if (this.selected) {
            const clone = this.selected.clone('baked');
            clone.material = this.selected.material.clone('baked');

            clone.checkCollisions = true;
            clone.receiveShadows = true;
            scene.lights[1].getShadowGenerator().addShadowCaster(clone);
            updateShadowMap();

            uix.bindTransformGizmo(clone);
            uix.gizmo.attachToMesh(clone);
            this.highlightMesh(clone);

            this.meshes.push(clone);
        } else {
            ui.notification('select a bake');
        }
    }

    this.instanceSelected = function() {
        if (this.selected) {
            const inst = this.selected.createInstance('baked');

            inst.checkCollisions = true;
            inst.receiveShadows = true;
            scene.lights[1].getShadowGenerator().addShadowCaster(inst);
            updateShadowMap();

            uix.bindTransformGizmo(inst);
            uix.gizmo.attachToMesh(inst);

            this.meshes.push(inst);
        } else {
            ui.notification('select a bake');
        }
    }

    this.mergeSelected = function(bakes) {
        for (let i = 0; i < bakes.length; i++) { // instances not supported
            if (bakes[i].hasInstances || bakes[i].isAnInstance) {
                ui.notification('unable to merge instances');
                return;
            }
        }

        const mesh = BABYLON.Mesh.MergeMeshes(bakes, true, true);
        resetPivot(mesh);
        mesh.name = 'baked_merged';

        for (let i = 0; i < bakes.length; i++) {
            this.meshes.splice(this.meshes.indexOf(bakes[i]), 1);
            if (bakes[i].material) {
                if (bakes[i].material.albedoTexture)
                    bakes[i].material.albedoTexture.dispose();
                bakes[i].material.dispose();
            }
            bakes[i].dispose();
        }

        material.setPBRTexture();
        material.update();
        mesh.material = material.mat_pbr.clone('baked');

        mesh.checkCollisions = true;
        mesh.receiveShadows = true;
        scene.lights[1].getShadowGenerator().addShadowCaster(mesh);
        updateShadowMap();

        uix.bindTransformGizmo(mesh);
        uix.gizmo.attachToMesh(mesh);
        
        bakery.meshes.push(mesh);
    }

    this.deleteSelected = function() {
        if (this.selected) {
            this.meshes.splice(this.meshes.indexOf(this.selected), 1);
            if (!this.selected.isAnInstance) {
                if (this.selected.material.albedoTexture)
                    this.selected.material.albedoTexture.dispose();
                this.selected.material.dispose();
            }
            this.selected.dispose();
            this.selected = null;
            uix.unbindTransformGizmo();
            updateShadowMap();
        } else {
            ui.notification('select a bake');
        }
    }

    this.selectMesh = function(mesh) {
        this.selected = mesh;
        if (!mesh.isAnInstance) { // useless, instances not support it anyway
            this.selected.renderOutline = true;
            this.selected.outlineWidth = scene.activeCamera.radius/600;
            this.selected.outlineColor = BABYLON.Color3.FromHexString(COL_ORANGE);
        }
        this.lastSelected = mesh;
    }

    this.highlightMesh = function(mesh) {
        if (!mesh.isAnInstance) {
            mesh.renderOverlay = true;
            mesh.overlayAlpha = 0.3;
            mesh.overlayColor = BABYLON.Color3.FromHexString(COL_ORANGE);
        }
    }

    this.clearSelected = function() {
        if (this.selected)
            this.selected = null;
        for (let i = 0; i < this.meshes.length; i++) {
            this.meshes[i].renderOutline = false;
            this.meshes[i].renderOverlay = false;
        }
    }

    this.setBakesVisibility = function(isVisible) {
        for (let i = 0; i < this.meshes.length; i++)
            this.meshes[i].isVisible = isVisible;
    }

    this.clearBakes = async function(isAlert = false) {
        if (this.meshes.length > 0) {
            if (isAlert && !await ui.showConfirm('This operation is not undoable<br>continue?')) return;
            scene.blockfreeActiveMeshesAndRenderingGroups = true; // save unnecessary
            for (let i = 0; i < this.meshes.length; i++) { // dispose() computation
                if (!this.meshes[i].isAnInstance) {
                    if (this.meshes[i].material.albedoTexture)
                        this.meshes[i].material.albedoTexture.dispose();
                    if (this.meshes[i].material.reflectionTexture)
                        this.meshes[i].material.reflectionTexture.dispose();
                    this.meshes[i].material.dispose();
                }
                this.meshes[i].dispose();
            }
            scene.blockfreeActiveMeshesAndRenderingGroups = false;
            this.meshes = [];
            this.selected = null;
            uix.unbindTransformGizmo();
            updateShadowMap();
        }
    }
    
    this.getMaterial = function() {
        if (this.selected) {
            currentColorBake = this.selected.material.albedoColor.toHexString();
            uix.colorPicker1.value = this.selected.material.albedoColor;
            ui.domRoughness.value = this.selected.material.roughness;
            ui.domMetallic.value = this.selected.material.metallic;
            ui.domColorPickerEmissive.value = this.selected.material.emissiveColor.toHexString();
            ui.domAlpha.value = this.selected.material.alpha;
        } else {
            ui.notification('select a bake');
        }
    }

    this.setMaterial = function(type) {
        if (this.selected) {
            switch (type) {
                case 'albedo':
                    this.selected.material.albedoColor = BABYLON.Color3.FromHexString(currentColorBake);
                    break;
                case 'roughness':
                    this.selected.material.roughness = parseFloat(ui.domRoughness.value);
                    break;
                case 'metallic':
                    this.selected.material.metallic = parseFloat(ui.domMetallic.value);
                    break;
                case 'emissive':
                    this.selected.material.emissiveColor = BABYLON.Color3.FromHexString(ui.domColorPickerEmissive.value);
                    break;
                case 'alpha':
                    this.selected.material.alpha = parseFloat(ui.domAlpha.value);
                    this.selected.visibility = parseFloat(ui.domAlpha.value); // set alpha seth!
                    break;
            }
        } else {
            ui.notification('select a bake');
        }
    }

    this.setMaterialAll = function() {
        if (this.selected) {
            if (ui.domMaterialAutoUpdate.checked) {
                ui.notification('uncheck auto update');
                return;
            }
            this.setMaterial('albedo');
            this.setMaterial('roughness');
            this.setMaterial('metallic');
            this.setMaterial('emissive');
            this.setMaterial('alpha');
        } else {
            ui.notification('select a bake');
        }
    }

    this.replaceTexture = function() {
        if (this.selected && this.selected.material) {
            if (this.selected.material.albedoTexture)
                this.selected.material.albedoTexture.dispose();
            this.selected.material.albedoTexture = material.textures[material.texId].clone();
        } else {
            ui.notification('select a bake');
        }
    }

    this.replaceTextureAll = async function() {
        if (!await ui.showConfirm('This operation is not undoable<br>continue?')) return;
        for (let i = 0; i < bakery.meshes.length; i++) {
            this.selected = bakery.meshes[i];
            this.replaceTexture();
        }
    }

    this.updateReflectionTextures = function() {
        for (let i = 0; i < this.meshes.length; i++) {
            if (!this.meshes[i].isAnInstance) {
                if (this.meshes[i].material.reflectionTexture)
                    this.meshes[i].material.reflectionTexture.dispose();
                this.meshes[i].material.reflectionTexture = scene.environmentTexture.clone();
                this.meshes[i].material.reflectionTexture.coordinatesMode = BABYLON.Texture.CUBIC_MODE;
            }
        }
    }

    this.updateVertexColors = async function(hex = currentColorBake) {
        if (this.selected) {
            if (!await ui.showConfirm('Set all vertex colors<br>to albedo color, continue?')) return;
            let positions = this.selected.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            let colors = [];
            const rgb = hexToRgbFloat(hex);
            for (let i = 0; i < positions.length/3; i++) {
                colors.push(rgb.r, rgb.g, rgb.b, 1);
            }
            this.selected.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);
            positions = null;
            colors = null;
        } else {
            ui.notification('select a bake');
        }
    }

    this.loadBakes = function(url, isLoadBakery) {
        engine.displayLoadingUI();
        BABYLON.SceneLoader.LoadAssetContainerAsync("", url, scene, null, '.glb')
            .then((container) => {
                let count = 0;
                for (let i = 0; i < container.meshes.length; i++) {
                    if (container.meshes[i].name !== '__root__') {
                        const baked = container.meshes[i].clone('baked');
                        baked.setParent(null);
                        baked.metadata = null;
                        // important, GLB exporter flip side-orientation,
                        baked.overrideMaterialSideOrientation = null;
                        baked.flipFaces(false); // or can't merge them to new bakes

                        baked.material = container.meshes[i].material.clone('baked');
                        baked.visibility = baked.material.alpha; // reload alpha seth!
                        
                        baked.checkCollisions = true;
                        baked.receiveShadows = true;
                        scene.lights[1].getShadowGenerator().addShadowCaster(baked);

                        bakery.meshes.push(baked);
                        count += 1;
                    }
                }
                container.removeAllFromScene();

                if (count == 0) {
                    ui.notification('unable to load baked meshes');
                } else {
                    (isLoadBakery) ? ui.setMode(1) : ui.setMode(0);
                    bakery.updateReflectionTextures();
                    updateShadowMap();
                }
                engine.hideLoadingUI();
            }).catch((reason) => {
                engine.hideLoadingUI();
                ui.notification("unable to load bake");
                console.error(reason.message);
            });
    }

    this.reconstructMesh = function(name, isTestColor, voxels) {
        const isPerFaceUV = ui.domBakeryPerFaceUvs.checked;
        let planes = [];
        let colors = [];
        let plane = null;
        let idx = 0;

        function createSide(index, side, position, nearby, rotX, rotY, colors) {
            idx = builder.findIndexByPosition(voxels[index].position.add(nearby));
            if (idx == -1) { // test by side
                plane = createPlane(side, isPerFaceUV);
                plane.position = voxels[index].position.add(position);
                plane.rotation.x = rotX;
                plane.rotation.y = rotY;
                plane.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);
                planes.push(plane);
            } else { // test by color
                if (isTestColor) {
                    if (voxels[index].color !== builder.voxels[idx].color) {
                        plane = createPlane(side, isPerFaceUV);
                        plane.position = voxels[index].position.add(position);
                        plane.rotation.x = rotX;
                        plane.rotation.y = rotY;
                        plane.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);
                        planes.push(plane);
                    }
                }
            }
        }

        for (let i = 0; i < voxels.length; i++) {
            colors = [];
            const rgb = hexToRgbFloat(voxels[i].color);
            for (let p = 0; p < 8; p++) //24 verts / 3 = 8
                colors.push(rgb.r, rgb.g, rgb.b, 1);

            createSide(i, 'right',  // X+
                        new BABYLON.Vector3(0.5, 0, 0),
                        new BABYLON.Vector3(1, 0, 0),
                        0, -PIH, colors);
            createSide(i, 'left',   // X-
                        new BABYLON.Vector3(-0.5, 0, 0),
                        new BABYLON.Vector3(-1, 0, 0),
                        0, PIH, colors);
            createSide(i, 'top',    // +Y
                        new BABYLON.Vector3(0, 0.5, 0),
                        new BABYLON.Vector3(0, 1, 0),
                        PIH, 0, colors);
            createSide(i, 'bottom', // -Y
                        new BABYLON.Vector3(0, -0.5, 0),
                        new BABYLON.Vector3(0, -1, 0),
                        -PIH, 0, colors);
            createSide(i, 'front',  // Z+
                        new BABYLON.Vector3(0, 0, 0.5),
                        new BABYLON.Vector3(0, 0, 1),
                        0, Math.PI, colors);
            createSide(i, 'back',   // Z-
                        new BABYLON.Vector3(0, 0, -0.5),
                        new BABYLON.Vector3(0, 0, -1),
                        0, 0, colors);
        }

        const mesh = BABYLON.Mesh.MergeMeshes(planes, true, true);
        mesh.name = name;
        //mesh.forceSharedVertices(); // merge vertices but affect uvs (use blender, see readme)
        //mesh.convertToFlatShadedMesh();

        planes = null;
        colors = null;
        return mesh;
    }

    function createPlane(side, isPerFaceUV) {
        let indices = [ 0, 1, 2, 0, 2, 3 ];
        let positions = [ -0.5, -0.5, 0, 0.5, -0.5, 0, 0.5,  0.5, 0, -0.5,  0.5, 0 ];
        let normals = [ 0, 0, -1.0, 0, 0, -1.0, 0, 0, -1.0, 0, 0, -1.0 ];
        let uvs = [];

        if (isPerFaceUV) {
            uvs = [ 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0 ];
        } else {
            if (side == 'right')  uvs.push(1,1/3, 0,1/3,  0,2/3, 1,2/3);
            if (side == 'left')   uvs.push(1,1/3, 0,1/3,  0,2/3, 1,2/3);
            if (side == 'top')    uvs.push(0,1,   1,1,    1,2/3, 0,2/3);
            if (side == 'bottom') uvs.push(0,1/3, 1,1/3,  1,0,   0,0);
            if (side == 'front')  uvs.push(1,1/3, 0,1/3,  0,2/3, 1,2/3);
            if (side == 'back')   uvs.push(1,1/3, 0,1/3,  0,2/3, 1,2/3);
        }

        BABYLON.VertexData._ComputeSides(BABYLON.VertexData.FRONTSIDE, positions, indices, normals, uvs);

        const mesh = new BABYLON.Mesh('plane', scene);
        let vertexData = new BABYLON.VertexData();
        vertexData.indices = indices;
        vertexData.positions = positions;
        vertexData.normals = normals;
        vertexData.uvs = uvs;
        vertexData.applyToMesh(mesh);

        vertexData = null;
        indices = null;
        positions = null;
        normals = null;
        uvs = null;
        return mesh;
    }
}


// -------------------------------------------------------
// Snapshot


function Snapshot() {
    const strVox = 'vbstore_voxels';
    const strVoxSnap = 'vbstore_voxels_snap';
    const strVoxSnapImage = 'vbstore_voxels_snap_img';
    const strBakes = 'vbstore_bakes';

    this.init = function() {
        this.createSnapshots();
    }

    this.setStorageVoxels = function(name = strVox) {
        localStorage.setItem(name, builder.getData());
    }

    this.getStorageVoxels = function(name = strVox) {
        let data = localStorage.getItem(name);
        if (!data) {
            ui.notification("empty storage");
            return;
        }
        builder.setData(data);
        memory.clear();
        data = null;
    }

    this.setStorageBakes = function() {
        if (bakery.meshes.length > 0) {
            BABYLON.GLTF2Export.GLBAsync(scene, strBakes, bakery.exportOptions).then((glb) => {
                const blob = glb.glTFFiles[strBakes + ".glb"];
                const file = new File([ blob ], "storage.glb");
                const reader = new FileReader();
                reader.onload = () => {
                    localStorage.setItem(strBakes, reader.result);
                }
                reader.readAsDataURL(file);
            });
        } else {
            localStorage.setItem(strBakes, 0);
        }
    }
    
    this.getStorageBakes = function() {
        let data = localStorage.getItem(strBakes);
        if (!data) {
            ui.notification("empty storage");
            return;
        }
        if (data !== '0') {
            bakery.clearBakes(false);
            bakery.loadBakes(data, true);
        }
        data = null;
    }

    this.delStorage = function(name) {
        if (localStorage.getItem(name))
            localStorage.removeItem(name);
    }

    this.createSnapshots = function() {
        const shots = document.querySelectorAll('li.storage');
        for (let i = 0; i < shots.length; i++) {
            const img = shots[i].children[0];
            const save = shots[i].children[1].lastChild;
            const clear = shots[i].children[1].firstChild;

            img.src = SNAPSHOT;
            img.id = 'shot' + i;

            // restore previous on startup
            const data = localStorage.getItem(strVoxSnapImage + img.id);
            if (data) img.src = data;

            clear.addEventListener("click", (ev) => {
                img.src = SNAPSHOT;
                snapshot.delStorage(strVoxSnap + img.id);
                snapshot.delStorage(strVoxSnapImage + img.id);
            }, false);

            save.addEventListener("click", (ev) => {
                createScreenshotBasic(img.clientWidth, img.clientHeight, (data) => {
                    img.src = data;
                    snapshot.setStorageVoxels(strVoxSnap + img.id);
                    localStorage.setItem(strVoxSnapImage + img.id, data);
                });
            }, false);

            img.addEventListener("click", (ev) => {
                snapshot.getStorageVoxels(strVoxSnap + img.id);
            }, false);

            img.addEventListener("dragstart", (ev) => {
                ev.preventDefault();
            }, false);
        }
    }

    this.init();
}


// -------------------------------------------------------
// Memory


function Memory() {
    this.stack = [];
    this.block = -1;

    this.record = function() {
        this.stack[++this.block] = builder.getData();
        this.stack.splice(this.block + 1); // delete anything forward
    }

    this.undo = function() {
        --this.block;
        if (this.stack[this.block]) {
            builder.setData(this.stack[this.block]);
        } else {
            ++this.block;
        }
    }

    this.redo = function() {
        ++this.block;
        if (this.stack[this.block]) {
            builder.setData(this.stack[this.block]);
        } else {
            --this.block;
        }
    }

    this.clear = function() {
        this.stack = [];
        this.block = -1;
        this.record(); // init memory block 0
    }
}


// -------------------------------------------------------
// Project


function Project(scene) {
    this.init = function() {
        builder.loadData([{ // fill null data
            position: BABYLON.Vector3.Zero(),
            color: currentColor,
            visible: false
        }], false, false);
    }

    this.newBox = function(size = 4, hex = currentColor) {
        size = (size - 1) / 2;
        let data = [];
        for (let x = -size; x <= size; x++) {
            for (let y = 0; y <= size*2; y++) {
                for (let z = -size; z <= size; z++) {
                    data.push({
                        position: new BABYLON.Vector3(x, y, z),
                        color: hex,
                        visible: true
                    });
                }
            }
        }
        builder.loadData(data, false, false);
        memory.clear();
        symmetry.resetAxis();
        bakery.clearBakes();
        ui.setMode(0);
        camera.frame();
        ui.domProjectName.value = 'untitled';
        data = null;
    }

    function setProjectValues(uiDom, iniKey, defVal) {
        (iniKey) ? uiDom.value = iniKey : uiDom.value = defVal;
    }

    this.load = function(voxdata) {
        if (voxdata.startsWith('#')) {
            this.loadOld(voxdata); // backward compatibity
            return;
        }

        let ini = parseINI(voxdata);
        
        // [project]
        ui.domProjectName.value = ini.project.name;
        setProjectValues(ui.domColorPickerBackground, ini.project.bgcolor, '#6C6F7A');
        setProjectValues(ui.domColorPickerLightColor, ini.project.lightcolor, '#CCCCCC');
        updateLightColor(ui.domColorPickerLightColor.value);

        // [data.voxels]
        let voxels = ini.data.voxels.split(';').slice(0, -1);
        let data = [];
        for (let i = 0; i < voxels.length; i++) {
            const chunk = voxels[i].split(',');
            data.push({ 
                position: new BABYLON.Vector3(
                    parseFloat(chunk[0]),
                    parseFloat(chunk[1]),
                    parseFloat(chunk[2])
                ),
                color: chunk[3],
                visible: parseBool(chunk[4])
            });
        }
        ui.setMode(0);
        builder.loadData(data, false, false);
        memory.clear();
        symmetry.resetAxis();
        camera.frame();

        // [data.bakes]
        if (ini.data.bakes) {
            bakery.clearBakes(false);
            bakery.loadBakes(ini.data.bakes, false);
        } else {
            bakery.clearBakes(false);
        }

        ini = null;
        data = null;
        voxels = null;
    }

    this.save = function() {
        let data = '; Voxel Builder file format (VBX)\n\n';

        data += '[project]\n';
        data += 'name=' + ui.domProjectName.value + '\n' +
                'bgcolor=' + ui.domColorPickerBackground.value.toUpperCase() + '\n' +
                'lightcolor=' + ui.domColorPickerLightColor.value.toUpperCase() + '\n' +
                '\n';

        let line = '';
        for (let i = 0; i < builder.voxels.length; i++) {
            line += builder.voxels[i].position.x + ',' +
                    builder.voxels[i].position.y + ',' +
                    builder.voxels[i].position.z + ',' +
                    builder.voxels[i].color + ',' +
                    builder.voxels[i].visible + ';';
        }
        data += '[data]\n';
        data += 'voxels=' + line + '\n';
        line = null;

        if (bakery.meshes.length > 0) {
            BABYLON.GLTF2Export.GLBAsync(scene, ui.domProjectName.value, bakery.exportOptions).then((glb) => {
                const blob = glb.glTFFiles[ui.domProjectName.value + ".glb"];
                const file = new File([ blob ], "exported.glb");
                const reader = new FileReader();
                reader.onload = () => {
                    data += 'bakes=' + reader.result + '\n';
                    saveFile(data, ui.domProjectName.value + '.vbx');
                    data = null;
                }
                reader.readAsDataURL(file);
            });
        } else {
            saveFile(data, ui.domProjectName.value + '.vbx');
            data = null;
        }
    }

    this.loadOld = function(voxdata) { // < 3.8.9
        ui.setMode(0);
        let lines = voxdata.split('\n');
        let data = [];
        let chunk = [];
        let line = '';
        ui.domProjectName.value = 'untitled';
        for (let i = 0; i < lines.length; i++) {
            if (lines[i]) { // ignore empty lines
                line = lines[i].replace(/\s+/g, ''); // strip whitespaces
                if (line.startsWith('#')) {
                    ui.domProjectName.value = line.substring(1); // strip #
                } else if (line.startsWith('data:')) {
                    bakery.clearBakes();
                    bakery.loadBakes(line, false);
                } else {
                    chunk = line.split(',');
                    data.push({ 
                        position: new BABYLON.Vector3(
                            parseFloat(chunk[0]),
                            parseFloat(chunk[1]),
                            parseFloat(chunk[2])),
                        color: chunk[3],
                        visible: parseBool(chunk[4])
                    });
                }
            }
        }
        if (!lines[lines.length - 1].startsWith('data:'))
            bakery.clearBakes(false); // no bakes, just clear bakery
        builder.loadData(data, false, false);
        memory.clear();
        symmetry.resetAxis();
        camera.frame();
        data = null;
        chunk = null;
        lines = null;
        voxdata = null;
    }

    this.import = function(voxdata) {
        let ini = parseINI(voxdata);
        if (!ini.data.bakes) {
            ui.notification('unable to read baked data');
            return;
        }
        bakery.loadBakes(ini.data.bakes, true);
        camera.frame();
        ini = null;
    }

    this.exportVoxels = function() {
        const options = {
            shouldExportNode: (node) => {
                return node == builder.SPS.mesh;
            }
        }
        engine.displayLoadingUI();
        builder.SPS.mesh.material = material.createExportMaterial();
        BABYLON.GLTF2Export.GLBAsync(scene, ui.domProjectName.value, options).then((glb) => {
            glb.downloadFiles();
            builder.SPS.mesh.material.dispose();
            builder.SPS.mesh.material = material.mat_cel;
            engine.hideLoadingUI();
        });
    }

    this.exportBakes = function() {
        if (bakery.meshes.length == 0) {
            ui.notification('no baked meshes');
            return;
        }
        engine.displayLoadingUI();
        BABYLON.GLTF2Export.GLBAsync(scene, ui.domProjectName.value, bakery.exportOptions).then((glb) => {
            glb.downloadFiles();
            engine.hideLoadingUI();
        });
    }

    this.loadFromUrl = function(url) {
        if (url == '') return; // ignore first preset option
        fetch(url).then((response) => {
            if (response.status !== 200) {
                ui.notification('unable to load data from url');
                return;
            }
            response.text().then((data) => {
                project.load(data);
            });
        }).catch((err) => {
            console.error('loadUrl', err);
        });
    }

    this.loadMagicaVoxel = function(buffer) {
        engine.displayLoadingUI();
        setTimeout(() => {
            let chunks = parseMagicaVoxel(buffer);
            if (!chunks) {
                ui.notification('unable to load magicavoxel file');
                return;
            }
            if (chunks[0].data.length / 4 > MAXAMOUNT)
                ui.notification('warning: exceed 64k voxels', 5000);

            let data = [];
            for (let i = 0; i < chunks[0].data.length; i += 4) {
                const x = chunks[0].data[ i + 0 ];
                const y = chunks[0].data[ i + 1 ];
                const z = chunks[0].data[ i + 2 ];
                const c = chunks[0].data[ i + 3 ];

                const hex = chunks[0].palette[ c ];
                const r = ( hex >> 0 & 0xff ) / 0xff;
                const g = ( hex >> 8 & 0xff ) / 0xff;
                const b = ( hex >> 16 & 0xff ) / 0xff;

                data.push({ 
                    position: new BABYLON.Vector3(x, z, -y),
                    color: rgbFloatToHex(r, g, b),
                    visible: true
                });
            }

            ui.setMode(0);
            builder.loadData(data, false, true);
            memory.clear();
            symmetry.resetAxis();
            bakery.clearBakes(false);
            camera.frame();
            data = null;
            chunks = null;
            buffer = null;
            engine.hideLoadingUI();
        }, 100);
    }

    this.init();
}


// -------------------------------------------------------
// UserInterface


function UserInterface(scene) {
    this.isShowMenuFile = false;
    this.isShowMenuGenerator = false;
    this.isShowMenuVoxelizer = false;
    this.isShowMenuSymmetry = false;
    this.isShowMenuModel = false;
    this.isShowMenuPaint = false;
    this.isShowMenuVoxels = false;
    this.isShowMenuBakery = false;
    this.isShowMenuBakes = false;
    this.isShowMenuCamera = false;
    this.isShowMenuEnv = false;
    this.isShowMenuMaterial = false;
    this.isShowMenuTexture = false;
    this.isShowMenuRender = false;
    this.isShowMenuStorage = false;
    this.isShowMenuGroups = false;
    this.isShowMenuPrefs = false;
    this.isShowMenuAbout = false;
    this.domToolbarR = document.getElementById('toolbar_R');
    this.domToolbarL = document.getElementById('toolbar_L');
    this.domToolbarC = document.getElementById('toolbar_C');
    this.domToolbarC_mem = document.getElementById('toolbar_C_mem');
    this.domModes = document.querySelectorAll('#toolbar_C li.mode');
    this.domMenuR = document.getElementsByClassName('menu_R');
    this.domMenuL = document.getElementsByClassName('menu_L');
    this.domMenuFile = document.getElementById('menu-file');
    this.domMenuGenerator = document.getElementById('menu-generator');
    this.domMenuVoxelizer = document.getElementById('menu-voxelizer');
    this.domMenuSymmetry = document.getElementById('menu-symmetry');
    this.domMenuModel = document.getElementById('menu-model');
    this.domMenuPaint = document.getElementById('menu-paint');
    this.domMenuVoxels = document.getElementById('menu-voxels');
    this.domMenuBakery = document.getElementById('menu-bakery');
    this.domMenuBakes = document.getElementById('menu-bakes');
    this.domMenuCamera = document.getElementById('menu-camera');
    this.domMenuEnv = document.getElementById('menu-env');
    this.domMenuMaterial = document.getElementById('menu-material');
    this.domMenuTexture = document.getElementById('menu-texture');
    this.domMenuRender = document.getElementById('menu-render');
    this.domMenuStorage = document.getElementById('menu-storage');
    this.domMenuGroups = document.getElementById('menu-groups');
    this.domMenuPrefs = document.getElementById('menu-prefs');
    this.domMenuAbout = document.getElementById('menu-about');
    this.domSymmAxis = document.getElementById('btn-symm-axis');
    this.domSymmAxis2 = document.getElementById('btn-helper-symmetry');
    this.domSymmCenter = document.getElementById('input-symm-center');
    this.domWorkplane = document.getElementById('input-helper-workplane');
    this.domWorkplaneBtn = document.getElementById('btn-helper-workplane');
    this.domColorPicker0 = document.getElementById('colorpicker0');
    this.domColorPicker1 = document.getElementById('colorpicker1');
    this.domPalette = document.getElementById('palette');
    this.domPaletteColors = document.getElementById('palette-colors');
    this.domHover = document.getElementById('hover');
    this.domMarquee = document.getElementById("marquee");
    this.domBoxToolHeight = document.getElementById('input-boxtool-height');
    this.domPipelineContrast = document.getElementById('input-pipeline-contrast');
    this.domPipelineExposure = document.getElementById('input-pipeline-exposure');
    this.domPipelineHue = document.getElementById('input-pipeline-hue');
    this.domPipelineBloom = document.getElementById('input-pipeline-bloom');
    this.domPipelineDof = document.getElementById('input-pipeline-dof');
    this.domPipelineDofDist = document.getElementById('input-pipeline-dofdist');
    this.domPipelineSharpen = document.getElementById('input-pipeline-sharpen');
    this.domPipelineGrain = document.getElementById('input-pipeline-grain');
    this.domPipelineVignette = document.getElementById('input-pipeline-vignette');
    this.domPipelineChromatic = document.getElementById('input-pipeline-chromatic');
    this.domHdriToggle = document.getElementById('input-hdri-toggle');
    this.domHdriBlur = document.getElementById('input-hdri-blur');
    this.domCamFov = document.getElementById('input-camera-fov');
    this.domBakeryPerFaceUvs = document.getElementById('input-bakery-uvs');
    this.domAutoRotation = document.getElementById('input-autorotate');
    this.domMaterialAutoUpdate = document.getElementById('input-material-autoupdate');
    this.domTexturePresets = document.getElementById('texturepresets');
    this.domRoughness = document.getElementById('input-material-roughness');
    this.domMetallic = document.getElementById('input-material-metallic');
    this.domAlpha = document.getElementById('input-material-alpha');
    this.domBackgroundCheck = document.getElementById('input-env-bgcheck');
    this.domColorPicker0 = document.getElementById('input-color-0');
    this.domColorPicker1 = document.getElementById('input-color-1');
    this.domColorPickerBackground = document.getElementById('input-env-background');
    this.domColorPickerLightColor = document.getElementById('input-env-lightcolor');
    this.domColorPickerEmissive = document.getElementById('input-material-emissive');
    this.domProjectName = document.getElementById('input-project-name');
    this.domPrefsNoIntro = document.getElementById('input-prefs-nointro');
    this.domPrefsNoHover = document.getElementById('input-prefs-nohover');
    this.domAxisViewHitbox = document.getElementById('axisview-hitbox');
    this.domOrthoBtn = document.getElementById('btn-ortho');
    this.domReticle = document.getElementById('reticle');
    this.domHelp = document.getElementById('help');
    this.domConfirm = document.getElementById('confirm');
    this.domConfirmBlocker = document.getElementById('confirmblocker');
    this.domNotifier = document.getElementById('notifier');
    this.domIntro = document.getElementById('intro');
    this.domInfo = document.getElementById('info').children;
    this.domLoadingScreen = document.getElementById('loadingscreen');
    const styleMenuR = 'translate(200px, 0)';
    const styleMenuL = 'translate(-200px, 0)';
    const styleMenuR_open = 'translate(-61px, 0)';
    const styleMenuL_open = 'translate(61px, 0)';
    let notificationTimer = null;
    let xOffset = 0, yOffset = 0; // hover

    this.init = function() {
        this.domColorPicker0.addEventListener('input', (ev) => {
            currentColor = ui.domColorPicker0.value.toUpperCase();
            uix.colorPicker0.value = BABYLON.Color3.FromHexString(currentColor);
        }, false);

        this.domColorPicker1.addEventListener('input', (ev) => {
            currentColorBake = ui.domColorPicker1.value.toUpperCase();
            uix.colorPicker1.value = BABYLON.Color3.FromHexString(currentColorBake);
            bakery.setMaterial('albedo'); // update material
        }, false);

        this.domColorPickerEmissive.addEventListener('input', (ev) => {
            bakery.setMaterial('emissive');
        }, false);

        this.domColorPickerBackground.addEventListener('input', (ev) => {
            if (MODE == 0 || MODE == 1) {
                scene.clearColor = BABYLON.Color4.FromHexString(ui.domColorPickerBackground.value);
            } else if (MODE == 2) {
                scene.clearColor = BABYLON.Color4.FromHexString(ui.domColorPickerBackground.value).toLinearSpace();
            }
            scene.autoClear = ui.domBackgroundCheck.checked;
        }, false);

        this.domColorPickerLightColor.addEventListener('input', (ev) => {
            updateLightColor(ui.domColorPickerLightColor.value);
        }, false);

        this.domLoadingScreen.addEventListener('click', (ev) => {
            if (ui.domHelp.style.bottom == '0px')
                ui.toggleHelp();
        }, false);
    }

    this.setMode = function(mode) {
        MODE = mode;

        for (let i = 0; i < viewAxes.length; i++)
            viewAxes[i].isVisible = true;

        if (mode == 0) {
            scene.clearColor = BABYLON.Color4.FromHexString(this.domColorPickerBackground.value);
            scene.lights[1].getShadowGenerator().filteringQuality = BABYLON.ShadowGenerator.QUALITY_MEDIUM;
            scene.lights[1].getShadowGenerator().setDarkness(0.6);
            tool.toolSelector('camera');
            toolBakery.toolSelector('xform');
            builder.setMeshVisibility(true);
            bakery.setBakesVisibility(false);
            pipeline.dispose();
            helper.gridPlane.isVisible = true;
            helper.toggleAxisPlane(symmetry.axis !== '');
            uix.showJoysticks(false);
            (ui.domWorkplane.checked) ? uix.bindWorkplane() : uix.unbindWorkplane();
        } else if (mode == 1) {
            scene.clearColor = BABYLON.Color4.FromHexString(this.domColorPickerBackground.value);
            scene.lights[1].getShadowGenerator().filteringQuality = BABYLON.ShadowGenerator.QUALITY_MEDIUM;
            scene.lights[1].getShadowGenerator().setDarkness(0);
            tool.toolSelector('camera');
            toolBakery.toolSelector('xform');
            builder.setMeshVisibility(false);
            bakery.setBakesVisibility(true);
            pipeline.dispose();
            helper.gridPlane.isVisible = true;
            helper.toggleAxisPlane(false);
            uix.showJoysticks(false);
            uix.unbindWorkplane();
        } else if (mode == 2) {
            scene.clearColor = BABYLON.Color4.FromHexString(this.domColorPickerBackground.value).toLinearSpace();
            scene.lights[1].getShadowGenerator().filteringQuality = BABYLON.ShadowGenerator.QUALITY_HIGH;
            scene.lights[1].getShadowGenerator().setDarkness(0.6);
            tool.toolSelector('camera');
            toolBakery.toolSelector('xform');
            pipeline.init();
            pipeline.setRenderMode(pipeline.currentRenderMode);
            helper.gridPlane.isVisible = false;
            helper.toggleAxisPlane(false);
            uix.showJoysticks(isMobileDevice());
            uix.unbindWorkplane();
            for (let i = 0; i < viewAxes.length; i++)
                viewAxes[i].isVisible = false;
        }

        scene.autoClear = this.domBackgroundCheck.checked;
        hdri.toggleSkybox(this.domHdriToggle.checked);

        if (scene.activeCamera.useAutoRotationBehavior)
            camera.toggleCameraAutoRotation();
        camera.switchCamera();

        this.setInterfaceMode();
        updateShadowMap();

        for (const i of this.domModes)
            i.classList.remove("mode_select");
        this.domModes[mode].classList.add("mode_select");
    }

    this.setInterfaceMode = function() {
        this.domToolbarC_mem.style.display = 'unset';
        this.domToolbarC_mem.children[0].innerHTML = 'SAVE';
        this.domToolbarC_mem.children[1].innerHTML = 'LOAD';
        this.domToolbarC_mem.children[0].style.width = '47px';
        this.domToolbarC_mem.children[1].style.width = '47px';
        this.domPalette.style.display = 'none';
        this.domHover.style.display = 'unset';
        this.domColorPicker0.style.display = 'none';
        this.domColorPicker1.style.display = 'none';
        this.domReticle.style.display = 'none';
        this.domAxisViewHitbox.style.display = 'none';
        this.domAutoRotation.disabled = false;
        this.domOrthoBtn.disabled = false;
        this.domSymmAxis2.style.display = 'none';
        this.domWorkplaneBtn.style.display = 'none';
        uix.colorPicker0.isVisible = false;
        uix.colorPicker1.isVisible = false;
        for (const i of this.domToolbarL.children)
            i.style.display = 'unset';
        for (const i of this.domToolbarR.children)
            i.style.display = 'unset';

        this.clearAllMenus('both', [ // except
            this.domMenuAbout,
            this.domMenuFile,
            this.domMenuPrefs,
            this.domMenuCamera,
            this.domMenuEnv
        ]);
            
        if (MODE == 0) {
            this.domPalette.style.display = 'unset';
            this.domColorPicker0.style.display = 'unset';
            this.domToolbarR.children[8].style.display = 'none'; // BAKES
            this.domToolbarL.children[3].style.display = 'none'; // MAT
            this.domToolbarL.children[4].style.display = 'none'; // TEX
            this.domToolbarL.children[5].style.display = 'none'; // RENDER
            this.domToolbarC_mem.children[0].onclick = snapshot.setStorageVoxels; // SAVE
            this.domToolbarC_mem.children[1].onclick = snapshot.getStorageVoxels; // LOAD
            this.domToolbarC_mem.children[2].style.display = 'inline-block'; // UNDO
            this.domToolbarC_mem.children[3].style.display = 'inline-block'; // REDO
            this.domSymmAxis2.style.display = 'unset';
            this.domWorkplaneBtn.style.display = 'unset';
            uix.colorPicker0.isVisible = true;
        } else if (MODE == 1) {
            this.domColorPicker1.style.display = 'unset';
            this.domHover.style.display = 'none';
            this.domToolbarR.children[1].style.display = 'none'; // GENERATOR
            this.domToolbarR.children[2].style.display = 'none'; // VOXELIZER
            this.domToolbarR.children[3].style.display = 'none'; // SYMMETRY
            this.domToolbarR.children[4].style.display = 'none'; // TOOLS
            this.domToolbarR.children[5].style.display = 'none'; // PAINT
            this.domToolbarR.children[6].style.display = 'none'; // VOXELS
            this.domToolbarL.children[5].style.display = 'none'; // RENDER
            this.domToolbarL.children[6].style.display = 'none'; // STORAGE
            this.domToolbarL.children[7].style.display = 'none'; // GROUP
            this.domToolbarC_mem.children[0].onclick = snapshot.setStorageBakes; // SAVE
            this.domToolbarC_mem.children[1].onclick = snapshot.getStorageBakes; // LOAD
            this.domToolbarC_mem.children[0].style.width = '60px';
            this.domToolbarC_mem.children[1].style.width = '60px';
            this.domToolbarC_mem.children[2].style.display = 'none'; // UNDO
            this.domToolbarC_mem.children[3].style.display = 'none'; // REDO
            uix.colorPicker1.isVisible = true;
        } else if (MODE == 2) {
            this.domHover.style.display = 'none';
            this.domReticle.style.display = 'grid';
            this.domToolbarR.children[1].style.display = 'none'; // GENERATOR
            this.domToolbarR.children[2].style.display = 'none'; // VOXELIZER
            this.domToolbarR.children[3].style.display = 'none'; // SYMMETRY
            this.domToolbarR.children[4].style.display = 'none'; // TOOLS
            this.domToolbarR.children[5].style.display = 'none'; // PAINT
            this.domToolbarR.children[6].style.display = 'none'; // VOXELS
            this.domToolbarR.children[7].style.display = 'none'; // BAKERY
            this.domToolbarR.children[8].style.display = 'none'; // BAKES
            this.domToolbarL.children[3].style.display = 'none'; // MAT
            this.domToolbarL.children[4].style.display = 'none'; // TEX
            this.domToolbarL.children[6].style.display = 'none'; // STORAGE
            this.domToolbarL.children[7].style.display = 'none'; // GROUP
            this.domToolbarC_mem.children[0].onclick = () => { pipeline.setRenderMode('voxel') };
            this.domToolbarC_mem.children[1].onclick = () => { pipeline.setRenderMode('bake') };
            this.domToolbarC_mem.children[0].innerHTML = 'VOXELS';
            this.domToolbarC_mem.children[1].innerHTML = 'BAKES';
            this.domToolbarC_mem.children[0].style.width = '60px';
            this.domToolbarC_mem.children[1].style.width = '60px';
            this.domToolbarC_mem.children[2].style.display = 'none'; // UNDO
            this.domToolbarC_mem.children[3].style.display = 'none'; // REDO
            this.domAutoRotation.disabled = true;
            this.domOrthoBtn.disabled = true;
            if (isMobileDevice()) // allow to frame camera (joysticks prevent access to axisview)
                this.domAxisViewHitbox.style.display = 'unset';
        }

        if (scene.activeCamera.mode == BABYLON.Camera.PERSPECTIVE_CAMERA)
            this.domOrthoBtn.innerHTML = 'Perspective';
        if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
            this.domOrthoBtn.innerHTML = 'Orthographic';

        this.domBackgroundCheck.disabled = (MODE == 2) ? true : false;
    }

    this.toggleMenuFile = function() {
        this.isShowMenuFile = !this.isShowMenuFile;
        this.switchMenus(this.domMenuFile, 'right', this.isShowMenuFile);
    }
    this.toggleMenuGenerator = function() {
        this.isShowMenuGenerator = !this.isShowMenuGenerator;
        this.switchMenus(this.domMenuGenerator, 'right', this.isShowMenuGenerator);
    }
    this.toggleMenuVoxelizer = function() {
        this.isShowMenuVoxelizer = !this.isShowMenuVoxelizer;
        this.switchMenus(this.domMenuVoxelizer, 'right', this.isShowMenuVoxelizer);
    }
    this.toggleMenuSymmetry = function() {
        this.isShowMenuSymmetry = !this.isShowMenuSymmetry;
        this.switchMenus(this.domMenuSymmetry, 'right', this.isShowMenuSymmetry);
    }
    this.toggleMenuModel = function() {
        this.isShowMenuModel = !this.isShowMenuModel;
        this.switchMenus(this.domMenuModel, 'right', this.isShowMenuModel);
    }
    this.toggleMenuPaint = function() {
        this.isShowMenuPaint = !this.isShowMenuPaint;
        this.switchMenus(this.domMenuPaint, 'right', this.isShowMenuPaint);
    }
    this.toggleMenuVoxels = function() {
        this.isShowMenuVoxels = !this.isShowMenuVoxels;
        this.switchMenus(this.domMenuVoxels, 'right', this.isShowMenuVoxels);
    }
    this.toggleMenuBakery = function() {
        this.isShowMenuBakery = !this.isShowMenuBakery;
        this.switchMenus(this.domMenuBakery, 'right', this.isShowMenuBakery);
    }
    this.toggleMenuBakes = function() {
        this.isShowMenuBakes = !this.isShowMenuBakes;
        this.switchMenus(this.domMenuBakes, 'right', this.isShowMenuBakes);
    }

    this.toggleMenuCamera = function() {
        this.isShowMenuCamera = !this.isShowMenuCamera;
        this.switchMenus(this.domMenuCamera, 'left', this.isShowMenuCamera);
    }
    this.toggleMenuEnv = function() {
        this.isShowMenuEnv = !this.isShowMenuEnv;
        this.switchMenus(this.domMenuEnv, 'left', this.isShowMenuEnv);
    }
    this.toggleMenuMaterial = function() {
        this.isShowMenuMaterial = !this.isShowMenuMaterial;
        this.switchMenus(this.domMenuMaterial, 'left', this.isShowMenuMaterial);
    }
    this.toggleMenuTexture = function() {
        this.isShowMenuTexture = !this.isShowMenuTexture;
        this.switchMenus(this.domMenuTexture, 'left', this.isShowMenuTexture);
    }
    this.toggleMenuRender = function() {
        this.isShowMenuRender = !this.isShowMenuRender;
        this.switchMenus(this.domMenuRender, 'left', this.isShowMenuRender);
    }
    this.toggleMenuStorage = function() {
        this.isShowMenuStorage = !this.isShowMenuStorage;
        this.switchMenus(this.domMenuStorage, 'left', this.isShowMenuStorage);
    }
    this.toggleMenuGroups = function() {
        this.isShowMenuGroups = !this.isShowMenuGroups;
        this.switchMenus(this.domMenuGroups, 'left', this.isShowMenuGroups);
    }
    this.toggleMenuPrefs = function() {
        this.isShowMenuPrefs = !this.isShowMenuPrefs;
        this.switchMenus(this.domMenuPrefs, 'left', this.isShowMenuPrefs);
    }
    this.toggleMenuAbout = function() {
        this.isShowMenuAbout = !this.isShowMenuAbout;
        this.switchMenus(this.domMenuAbout, 'left', this.isShowMenuAbout);
    }

    this.clearAllMenus = function(side, exclude = []) {
        if (side == 'right' || side == 'both') {
            if (exclude.indexOf(this.domMenuFile) == -1) {
                this.domMenuFile.style.transform = styleMenuR;
                this.isShowMenuFile = false;
            }
            if (exclude.indexOf(this.domMenuGenerator) == -1) {
                this.domMenuGenerator.style.transform = styleMenuR;
                this.isShowMenuGenerator = false;
            }
            if (exclude.indexOf(this.domMenuVoxelizer) == -1) {
                this.domMenuVoxelizer.style.transform = styleMenuR;
                this.isShowMenuVoxelizer = false;
            }
            if (exclude.indexOf(this.domMenuBakery) == -1) {
                this.domMenuBakery.style.transform = styleMenuR;
                this.isShowMenuBakery = false;
            }
            if (exclude.indexOf(this.domMenuBakes) == -1) {
                this.domMenuBakes.style.transform = styleMenuR;
                this.isShowMenuBakes = false;
            }
            if (exclude.indexOf(this.domMenuSymmetry) == -1) {
                this.domMenuSymmetry.style.transform = styleMenuR;
                this.isShowMenuSymmetry = false;
            }
            if (exclude.indexOf(this.domMenuModel) == -1) {
                this.domMenuModel.style.transform = styleMenuR;
                this.isShowMenuModel = false;
            }
            if (exclude.indexOf(this.domMenuPaint) == -1) {
                this.domMenuPaint.style.transform = styleMenuR;
                this.isShowMenuPaint = false;
            }
            if (exclude.indexOf(this.domMenuVoxels) == -1) {
                this.domMenuVoxels.style.transform = styleMenuR;
                this.isShowMenuVoxels = false;
            }
        }
        if (side == 'left' || side == 'both') {
            if (exclude.indexOf(this.domMenuCamera) == -1) {
                this.domMenuCamera.style.transform = styleMenuL;
                this.isShowMenuCamera = false;
            }
            if (exclude.indexOf(this.domMenuEnv) == -1) {
                this.domMenuEnv.style.transform = styleMenuL;
                this.isShowMenuEnv = false;
            }
            if (exclude.indexOf(this.domMenuMaterial) == -1) {
                this.domMenuMaterial.style.transform = styleMenuL;
                this.isShowMenuMaterial = false;
            }
            if (exclude.indexOf(this.domMenuTexture) == -1) {
                this.domMenuTexture.style.transform = styleMenuL;
                this.isShowMenuTexture = false;
            }
            if (exclude.indexOf(this.domMenuRender) == -1) {
                this.domMenuRender.style.transform = styleMenuL;
                this.isShowMenuRender = false;
            }
            if (exclude.indexOf(this.domMenuStorage) == -1) {
                this.domMenuStorage.style.transform = styleMenuL;
                this.isShowMenuStorage = false;
            }
            if (exclude.indexOf(this.domMenuGroups) == -1) {
                this.domMenuGroups.style.transform = styleMenuL;
                this.isShowMenuGroups = false;
            }
            if (exclude.indexOf(this.domMenuPrefs) == -1) {
                this.domMenuPrefs.style.transform = styleMenuL;
                this.isShowMenuPrefs = false;
            }
            if (exclude.indexOf(this.domMenuAbout) == -1) {
                this.domMenuAbout.style.transform = styleMenuL;
                this.isShowMenuAbout = false;
            }
        }
    }

    this.switchMenus = function(dom, side, isEnabled) {
        this.clearAllMenus(side, [ dom ]);
        if (isEnabled) {
            if (side == 'right') dom.style.transform = styleMenuR_open;
            if (side == 'left')  dom.style.transform = styleMenuL_open;
        } else {
            if (side == 'right') dom.style.transform = styleMenuR;
            if (side == 'left')  dom.style.transform = styleMenuL;
        }
    }

    this.toggleHover = function(isEnabled) {
        if (isEnabled) {
            for (let i = 1; i < this.domHover.children.length; i++)
                this.domHover.children[i].style.display = 'unset';
        } else {
            for (let i = 1; i < this.domHover.children.length; i++)
                this.domHover.children[i].style.display = 'none';
        }
    }

    this.updateStatus = function() {
        ui.domInfo[0].innerHTML = ~~engine.getFps();
        if (MODE == 0) {
            this.domInfo[1].innerHTML = builder.voxels.length + ' VOX';
            this.domInfo[2].innerHTML = palette.uniqueColors.length + ' COL';
        } else if (MODE == 1) {
            this.domInfo[1].innerHTML = bakery.meshes.length + ' MSH';
            this.domInfo[2].innerHTML = scene.getTotalVertices() + ' VTX';
        } else if (MODE == 2) {
            ui.domInfo[1].innerHTML = 'FOV ' + camera.camera2.fov;
            (pipeline.currentRenderMode == 'bake') ? this.domInfo[2].innerHTML = 'BAKES' : this.domInfo[2].innerHTML = 'VOXELS';
        }
    }

    this.notification = function(txt, timeout = 3000) {
        if (this.domNotifier.style.display == 'unset') // prevent overdraw
            clearTimeout(notificationTimer);
        this.domNotifier.innerHTML = txt.toUpperCase();
        this.domNotifier.style.display = 'unset';
        this.domNotifier.style.marginLeft = -(this.domNotifier.getBoundingClientRect().width/2) + 'px';
        notificationTimer = setTimeout(() => {
            ui.domNotifier.style.display = 'none';
        }, timeout);
    }

    this.toggleHelp = function() {
        if (ui.domHelp.style.bottom == '0px') {
            ui.domHelp.style.bottom = '-1000px';
            engine.hideLoadingUI();
        } else {
            ui.domHelp.style.bottom = '0px';
            engine.displayLoadingUI();
        }
    }

    this.showConfirm = async function(title) {
        ui.domConfirmBlocker.style.display = 'unset';
        ui.domConfirm.style.display = 'unset';
        ui.domConfirm.children[0].innerHTML = title;
        return new Promise((resolve) => {
            ui.domConfirm.children[1].onclick = (ev) => {
                ui.domConfirmBlocker.style.display = 'none';
                ui.domConfirm.style.display = 'none';
                resolve(false);
            };
            ui.domConfirm.children[2].onclick = (ev) => {
                ui.domConfirmBlocker.style.display = 'none';
                ui.domConfirm.style.display = 'none';
                resolve(true);
            };
        });
    }

    this.toggleDebugMode = function() {
        if (scene.debugLayer.isVisible()) {
            this.domToolbarL.style.display = 'unset';
            this.domToolbarR.style.display = 'unset';
            if (MODE == 0) {
                this.domToolbarC_mem.style.display = 'unset';
                this.domPalette.style.display = 'unset';
            }
            scene.debugLayer.hide();
        } else {
            this.clearAllMenus('both');
            this.domToolbarL.style.display = 'none';
            this.domToolbarR.style.display = 'none';
            this.domToolbarC_mem.style.display = 'none';
            this.domPalette.style.display = 'none';
            scene.debugLayer.show();
        }
    }

    this.dragElement = function(elem) {
        let active = false;
        let currentX, currentY, initialX, initialY;
        // prevent fast-dragging problem with background elements
        document.body.addEventListener("mousedown", dragStart, false);
        document.body.addEventListener("mouseup", dragEnd, false);
        document.body.addEventListener("mousemove", drag, false);
        document.body.addEventListener("touchstart", dragStart, false);
        document.body.addEventListener("touchend", dragEnd, false);
        document.body.addEventListener("touchmove", drag, false);
        function dragStart(e) {
            if (e.type === "touchstart") {
                initialX = e.touches[0].clientX - xOffset;
                initialY = e.touches[0].clientY - yOffset;
            } else {
                initialX = e.clientX - xOffset;
                initialY = e.clientY - yOffset;
            }
            if (e.target === elem) active = true;
        }
        function dragEnd(e) {
            initialX = currentX;
            initialY = currentY;
            active = false;
            document.body.removeEventListener("mousedown", dragStart, false);
            document.body.removeEventListener("mouseup", dragEnd, false);
            document.body.removeEventListener("mousemove", drag, false);
            document.body.removeEventListener("touchstart", dragStart, false);
            document.body.removeEventListener("touchend", dragEnd, false);
            document.body.removeEventListener("touchmove", drag, false);
        }
        function drag(e) {
            if (active) {
                if (e.type === "touchmove") {
                    currentX = e.touches[0].clientX - initialX;
                    currentY = e.touches[0].clientY - initialY;
                } else {
                    currentX = e.clientX - initialX;
                    currentY = e.clientY - initialY;
                }
                xOffset = currentX;
                yOffset = currentY;
                setTranslate(currentX, currentY, elem.parentElement);
            }
        }
        function setTranslate(xPos, yPos, el) {
            el.style.transform = "translate3d(" + xPos + "px, " + yPos + "px, 0)";
        }
    }

    this.init();
}


// -------------------------------------------------------
// UserInterfaceAdvanced


function UserInterfaceAdvanced(scene) {
    this.advancedTexture = null;
    this.utilLayer = null;
    this.colorPicker0 = undefined;
    this.colorPicker1 = undefined;
    this.gizmo = null;
    this.joysticks = []; // [left, right]
    this.workplaneGizmos = [];

    this.init = function() {
        this.advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", {}, scene);
        this.utilLayer = new BABYLON.UtilityLayerRenderer(scene);
        this.utilLayer.utilityLayerScene.autoClearDepthAndStencil = true;
        this.createAdvancedColorPicker();

        const colAqua = new BABYLON.Color3(0,1,1);
        this.workplaneGizmos[0] = new BABYLON.AxisDragGizmo(BABYLON.Axis.X, BABYLON.Color3.Red(), this.utilLayer, undefined, 5);
        this.workplaneGizmos[1] = new BABYLON.AxisDragGizmo(BABYLON.Axis.Y, BABYLON.Color3.Green(), this.utilLayer, undefined, 5);
        this.workplaneGizmos[2] = new BABYLON.AxisDragGizmo(BABYLON.Axis.Z, BABYLON.Color3.Blue(), this.utilLayer, undefined, 5);
        this.workplaneGizmos[3] = new BABYLON.AxisScaleGizmo(BABYLON.Axis.X, colAqua, this.utilLayer, undefined, 7);
        this.workplaneGizmos[4] = new BABYLON.AxisScaleGizmo(BABYLON.Axis.Y, colAqua, this.utilLayer, undefined, 7);
        this.workplaneGizmos[5] = new BABYLON.AxisScaleGizmo(BABYLON.Axis.Z, colAqua, this.utilLayer, undefined, 7);
        this.workplaneGizmos[3].hoverMaterial.diffuseColor = BABYLON.Color3.Red();
        this.workplaneGizmos[4].hoverMaterial.diffuseColor = BABYLON.Color3.Green();
        this.workplaneGizmos[5].hoverMaterial.diffuseColor = BABYLON.Color3.Blue();
        this.workplaneGizmos[3].disableMaterial.diffuseColor = BABYLON.Color3.Red();
        this.workplaneGizmos[4].disableMaterial.diffuseColor = BABYLON.Color3.Green();
        this.workplaneGizmos[5].disableMaterial.diffuseColor = BABYLON.Color3.Blue();
        this.disposeWorkplaneGizmo(); // important, startup artifact

        this.initJoysticks();
    }

    this.createAdvancedColorPicker = function() {
        const panel = new BABYLON.GUI.StackPanel();
        panel.width = "115px";
        panel.height = "105px";
        panel.isVertical = true;
        panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
        this.advancedTexture.addControl(panel);  

        this.colorPicker0 = new BABYLON.GUI.ColorPicker();
        this.colorPicker0.value = BABYLON.Color3.FromHexString(currentColor);
        this.colorPicker0.height = "100px";
        this.colorPicker0.width = "100px";
        this.colorPicker0.paddingBottom = "3px";
        this.colorPicker0.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        this.colorPicker0.verticalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_TOP;
        this.colorPicker0.onValueChangedObservable.add((value) => { //color3
            currentColor = value.toHexString();
            ui.domColorPicker0.value = currentColor;
        });
        panel.addControl(this.colorPicker0);

        this.colorPicker1 = new BABYLON.GUI.ColorPicker();
        this.colorPicker1.value = BABYLON.Color3.FromHexString(currentColorBake);
        this.colorPicker1.height = "100px";
        this.colorPicker1.width = "100px";
        this.colorPicker1.paddingBottom = "3px";
        this.colorPicker1.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        this.colorPicker1.verticalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_TOP;
        this.colorPicker1.onValueChangedObservable.add((value) => { //color3
            currentColorBake = value.toHexString();
            ui.domColorPicker1.value = currentColorBake;
            bakery.setMaterial('albedo'); // update material
        });
        panel.addControl(this.colorPicker1);
    }

    this.bindTransformGizmo = function(meshes) {
        this.unbindTransformGizmo();
        this.gizmo = new BABYLON.GizmoManager(scene, 4, new BABYLON.UtilityLayerRenderer(scene));
        this.gizmo.positionGizmoEnabled = true;
        this.gizmo.rotationGizmoEnabled = true;
        this.gizmo.scaleGizmoEnabled = false;
        this.gizmo.usePointerToAttachGizmos = true;
        this.gizmo.clearGizmoOnEmptyPointerEvent = false; // handled manually on pointer events

        this.gizmo.gizmos.positionGizmo.scaleRatio = 0.6;
        this.gizmo.gizmos.positionGizmo.snapDistance  = 0.5;
        this.gizmo.gizmos.positionGizmo.planarGizmoEnabled = false;
        this.gizmo.gizmos.positionGizmo.updateGizmoRotationToMatchAttachedMesh = true;
        [this.gizmo.gizmos.positionGizmo.xGizmo,
            this.gizmo.gizmos.positionGizmo.yGizmo,
            this.gizmo.gizmos.positionGizmo.zGizmo].forEach((gizmo) => {
            gizmo.dragBehavior.onDragObservable.add(() => {
                updateShadowMap();
            });
        });
        
        this.gizmo.gizmos.rotationGizmo.scaleRatio = 0.3;
        this.gizmo.gizmos.rotationGizmo.snapDistance = Math.PI / 8;
        this.gizmo.gizmos.rotationGizmo.updateGizmoRotationToMatchAttachedMesh = false;
        [this.gizmo.gizmos.rotationGizmo.xGizmo,
            this.gizmo.gizmos.rotationGizmo.yGizmo,
            this.gizmo.gizmos.rotationGizmo.zGizmo].forEach((gizmo) => {
            gizmo.dragBehavior.onDragObservable.add(() => {
                updateShadowMap();
            });
        });

        this.gizmo.attachableMeshes = meshes;
        this.gizmo.onAttachedToMeshObservable.add((mesh) => {
            toolBakery.onGizmoAttached(mesh);
        });
    }

    this.unbindTransformGizmo = function() {
        if (this.gizmo) {
            this.gizmo.dispose();
            this.gizmo = null;
        }
    }

    this.bindWorkplane = function(workplane = helper.workPlane) {
        workplane.isVisible = true;
        ui.domWorkplaneBtn.firstChild.style.color = COL_ORANGE;

        this.workplaneGizmos[0].scaleRatio = 0.5;
        this.workplaneGizmos[0].snapDistance = 0.5;
        this.workplaneGizmos[0].attachedMesh = workplane;
        this.workplaneGizmos[0].updateGizmoRotationToMatchAttachedMesh = false;
        this.workplaneGizmos[0].dragBehavior.onDragStartObservable.add(() => {
            workplane.visibility = 0.5;
            for (let i = 0; i < this.workplaneGizmos.length; i++)
                this.workplaneGizmos[i].gizmoLayer.shouldRender = false;
        });
        this.workplaneGizmos[0].dragBehavior.onDragEndObservable.add(() => {
            workplane.visibility = 0.3;
            for (let i = 0; i < this.workplaneGizmos.length; i++)
                this.workplaneGizmos[i].gizmoLayer.shouldRender = true;
        });
        
        this.workplaneGizmos[1].scaleRatio = 0.5;
        this.workplaneGizmos[1].snapDistance = 0.5;
        this.workplaneGizmos[1].attachedMesh = workplane;
        this.workplaneGizmos[1].updateGizmoRotationToMatchAttachedMesh = false;
        this.workplaneGizmos[1].dragBehavior.onDragStartObservable.add(() => {
            workplane.visibility = 0.5;
            for (let i = 0; i < this.workplaneGizmos.length; i++)
                this.workplaneGizmos[i].gizmoLayer.shouldRender = false;
        });
        this.workplaneGizmos[1].dragBehavior.onDragEndObservable.add(() => {
            workplane.visibility = 0.3;
            for (let i = 0; i < this.workplaneGizmos.length; i++)
                this.workplaneGizmos[i].gizmoLayer.shouldRender = true;
        });

        this.workplaneGizmos[2].scaleRatio = 0.5;
        this.workplaneGizmos[2].snapDistance = 0.5;
        this.workplaneGizmos[2].attachedMesh = workplane;
        this.workplaneGizmos[2].updateGizmoRotationToMatchAttachedMesh = false;
        this.workplaneGizmos[2].dragBehavior.onDragStartObservable.add(() => {
            workplane.visibility = 0.5;
            for (let i = 0; i < this.workplaneGizmos.length; i++)
                this.workplaneGizmos[i].gizmoLayer.shouldRender = false;
        });
        this.workplaneGizmos[2].dragBehavior.onDragEndObservable.add(() => {
            workplane.visibility = 0.3;
            for (let i = 0; i < this.workplaneGizmos.length; i++)
                this.workplaneGizmos[i].gizmoLayer.shouldRender = true;
        });

        this.workplaneGizmos[3].scaleRatio = -0.25;
        this.workplaneGizmos[3].attachedMesh = workplane;
        this.workplaneGizmos[3].updateGizmoRotationToMatchAttachedMesh = false;
        this.workplaneGizmos[3].dragBehavior.onDragStartObservable.add(() => {
            this.workplaneGizmos[3].dragBehavior._enabled = false;
            helper.setWorkPlane(BABYLON.Axis.X);
        });
        this.workplaneGizmos[3].dragBehavior.onDragEndObservable.add(() => {
            this.workplaneGizmos[3].dragBehavior._enabled = true;
        });

        this.workplaneGizmos[4].scaleRatio = -0.25;
        this.workplaneGizmos[4].attachedMesh = workplane;
        this.workplaneGizmos[4].updateGizmoRotationToMatchAttachedMesh = false;
        this.workplaneGizmos[4].dragBehavior.onDragStartObservable.add(() => {
            this.workplaneGizmos[4].dragBehavior._enabled = false;
            helper.setWorkPlane(BABYLON.Axis.Y);
        });
        this.workplaneGizmos[4].dragBehavior.onDragEndObservable.add(() => {
            this.workplaneGizmos[4].dragBehavior._enabled = true;
        });

        this.workplaneGizmos[5].scaleRatio = -0.25;
        this.workplaneGizmos[5].attachedMesh = workplane;
        this.workplaneGizmos[5].updateGizmoRotationToMatchAttachedMesh = false;
        this.workplaneGizmos[5].dragBehavior.onDragStartObservable.add(() => {
            this.workplaneGizmos[5].dragBehavior._enabled = false;
            helper.setWorkPlane(BABYLON.Axis.Z);
        });
        this.workplaneGizmos[5].dragBehavior.onDragEndObservable.add(() => {
            this.workplaneGizmos[5].dragBehavior._enabled = true;
        });
    }

    this.unbindWorkplane = function() {
        ui.domWorkplaneBtn.firstChild.style.color = COL_AQUA;
        helper.workPlane.isVisible = false;
        this.disposeWorkplaneGizmo();
    }

    this.disposeWorkplaneGizmo = function() {
        for (let i = 0; i < this.workplaneGizmos.length; i++)
            this.workplaneGizmos[i].attachedMesh = null;
    }

    this.initJoysticks = function() { // freeCameraVirtualJoystickInput.ts
        this.joysticks[0] = new BABYLON.VirtualJoystick(true);
        this.joysticks[0].setAxisForUpDown(BABYLON.JoystickAxis.Z);
        this.joysticks[0].setAxisForLeftRight(BABYLON.JoystickAxis.X);
        this.joysticks[0].setJoystickSensibility(0.15);
        this.joysticks[0].setJoystickColor("#00ffff60");
        this.joysticks[0].reverseLeftRight = true; // using right-handed system
        this.joysticks[1] = new BABYLON.VirtualJoystick(false);
        this.joysticks[1].setAxisForUpDown(BABYLON.JoystickAxis.X);
        this.joysticks[1].setAxisForLeftRight(BABYLON.JoystickAxis.Y);
        this.joysticks[1].setJoystickSensibility(0.015);
        this.joysticks[1].setJoystickColor("#00ffff60");
        this.joysticks[1].reverseUpDown = true;
        this.joysticks[1].reverseLeftRight = true;
        //this.joysticks[0].puckSize = 5; // introduce artifacts,
        //this.joysticks[0].containerSize = 50; // canvas clear issue
        BABYLON.VirtualJoystick.Canvas.style.zIndex = "-1"; // initialize
        BABYLON.VirtualJoystick.Canvas.style.background = "none";

        scene.onBeforeRenderObservable.add(() => {
            if (MODE == 2 && this.joysticks[0]) {
                const speed = camera.camera2._computeLocalCameraSpeed() * 50;
                const cameraTransform = BABYLON.Matrix.RotationYawPitchRoll(
                    camera.camera2.rotation.y, camera.camera2.rotation.x, 0);
                const deltaTransform = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(
                        this.joysticks[0].deltaPosition.x * speed,
                        this.joysticks[0].deltaPosition.y * speed,
                        this.joysticks[0].deltaPosition.z * speed),
                        cameraTransform);
                        
                camera.camera2.cameraDirection = camera.camera2.cameraDirection.add(deltaTransform);
                camera.camera2.cameraRotation = camera.camera2.cameraRotation.addVector3(this.joysticks[1].deltaPosition);

                if (!this.joysticks[0].pressed)
                    this.joysticks[0].deltaPosition = this.joysticks[0].deltaPosition.scale(0.9);
                if (!this.joysticks[1].pressed)
                    this.joysticks[1].deltaPosition = this.joysticks[1].deltaPosition.scale(0.9);
            }
        });
    }

    this.showJoysticks = function(isVisible) {
        if (isVisible) {
            BABYLON.VirtualJoystick.Canvas.style.zIndex = "5";
        } else {
            BABYLON.VirtualJoystick.Canvas.style.zIndex = "-1";
        }
    }

    this.toggleJoysticks = function() {
        if (BABYLON.VirtualJoystick.Canvas.style.zIndex == "-1") {
            BABYLON.VirtualJoystick.Canvas.style.zIndex = "5";
        } else {
            BABYLON.VirtualJoystick.Canvas.style.zIndex = "-1";
        }
    }

    this.init();
}


// -------------------------------------------------------
// Preferences


function Preferences() {
    this.isNoIntro = false;
    this.isNoHover = false;

    this.init = function() {
        this.isNoIntro = parseBool(localStorage.getItem('vbp_nointro'));
        this.isNoHover = parseBool(localStorage.getItem('vbp_nohover'));
    }

    this.finish = function() {
        if (this.isNoIntro) {                
            ui.domPrefsNoIntro.checked = true;
        } else {
            ui.domPrefsNoIntro.checked = false;
            ui.domIntro.style.display = 'unset';
            ui.domIntro.style.opacity = 1;
            setTimeout(() => {
                ui.domIntro.style.opacity = 0;
                setTimeout(() => {
                    ui.domIntro.style.display = 'none';
                }, 1000);
            }, 8000);
        }

        ui.domPrefsNoHover.checked = this.isNoHover;
        ui.toggleHover(!this.isNoHover);
    }

    this.setNoIntro = function(isEnabled) {
        localStorage.setItem('vbp_nointro', isEnabled);
    }

    this.setNoHover = function(isEnabled) {
        localStorage.setItem('vbp_nohover', isEnabled);
        ui.toggleHover(!isEnabled);
    }
}


// -------------------------------------------------------
// Events


scene.onPointerObservable.add((pInfo) => {
    switch (pInfo.type) {
        case BABYLON.PointerEventTypes.POINTERDOWN:
            if (MODE == 0) tool.handleToolDown(pInfo.event);
            if (MODE == 1) toolBakery.onToolDown();
            break;
        case BABYLON.PointerEventTypes.POINTERMOVE:
            if (MODE == 0) tool.handleToolMove(pInfo.event);
            if (MODE == 1) toolBakery.onToolMove();
            break;
        case BABYLON.PointerEventTypes.POINTERUP:
            if (MODE == 0) tool.handleToolUp(pInfo.event);
            if (MODE == 1) toolBakery.onToolUp();
            break;
        case BABYLON.PointerEventTypes.POINTERWHEEL:
            if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
                camera.setOrthoZoom();
            break;
    }
});

canvas.addEventListener("touchmove", (ev) => {
    if (ev.touches.length > 1 && scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
        camera.setOrthoZoom();
}, false);

canvas.addEventListener("keyup", (ev) => {
    //console.log(ev.key);
    switch (ev.key) {
        case ' ':
            if (MODE == 0) tool.toolSelector('camera');
            break;
        case 'a':
            if (MODE == 0) tool.toolSelector('add');
            break;
        case 'b':
            if (MODE == 0) tool.toolSelector('boxadd');
            break;
        case 'r':
            if (MODE == 0) tool.toolSelector('remove');
            break;
        case 't':
            if (MODE == 0) tool.toolSelector('transform');
            break;
        case 'p':
            if (MODE == 0) tool.toolSelector('paint');
            break;
        case 'b':
            if (MODE == 0) tool.toolSelector('bucket');
            break;
        case 'e':
            if (MODE == 0) tool.toolSelector('eyedrop');
            break;
        case 's':
            if (MODE == 0) symmetry.switchAxis();
            break;
        case 'w':
            if (MODE == 0) helper.toggleWorkplane();
            break;
        case 'c':
            if (MODE == 1) bakery.cloneSelected();
            break;
        case 'Delete':
            if (MODE == 1) bakery.deleteSelected();
            break;
        case 'f':
            camera.frame();
            break;
        case 'o':
            ui.toggleDebugMode();
            break;
    }
    if (MODE == 0) {
        if (ev.ctrlKey && ev.key === 'z') memory.undo();
        if (ev.ctrlKey && ev.key === 'x') memory.redo();
    }
}, false);

canvas.addEventListener("keydown", (ev) => {
    if (MODE == 2) {
        if (ev.shiftKey)
            camera.speedUp();
    }
}, false);

function fileHandler(file) {
    const ext = file.name.split('.').pop().toLowerCase(); //ext|exts
    const url = URL.createObjectURL(file);
    const reader = new FileReader();
    reader.onload = () => {
        if (ext === 'vbx') project.load(reader.result);
        if (ext === 'obj') voxelizer.importMesh(url);
        if (ext === 'glb') voxelizer.importMeshGLB(url);
        if (ext === 'vox') project.loadMagicaVoxel(reader.result);
        if (ext === 'hdr') hdri.loadHDR(url);
        if (MODE == 0) {
            if (['jpg','png','svg'].includes(ext)) voxelizer.voxelize2D(reader.result);
        } else {
            if (['jpg','png'].includes(ext)) material.addTexture(reader.result);
        }
        URL.revokeObjectURL(url);
    }
    if (ext === 'vbx') {
        reader.readAsText(file);
    } else if (ext === 'vox') {
        reader.readAsArrayBuffer(file);
    } else {
        reader.readAsDataURL(file);
    }
}

function fileHandlerNoDrop(file) {
    const ext = file.name.split('.').pop().toLowerCase(); //ext|exts
    const url = URL.createObjectURL(file);
    const reader = new FileReader();
    reader.onload = () => {
        if (ext === 'vbx') project.import(reader.result);
        URL.revokeObjectURL(url);
    }
    if (ext === 'vbx') {
        reader.readAsText(file);
    } else {
        reader.readAsDataURL(file);
    }
}

function dropHandler(ev) {
    ev.preventDefault();
    if (ev.dataTransfer.files[0] && ev.dataTransfer.files[0].path !== "")
        fileHandler(ev.dataTransfer.files[0]);
}
function dragHandler(ev) {
    ev.preventDefault();
}
function dragLeaveHandler(ev) {
    ev.preventDefault();
}

document.getElementById('openfile_vbx').addEventListener("change", (ev) => {
    if (ev.target.files.length > 0)
        fileHandler(ev.target.files[0]);
}, false);

document.getElementById('openfile_vbx_imp').addEventListener("change", (ev) => {
    if (ev.target.files.length > 0)
        fileHandlerNoDrop(ev.target.files[0]);
}, false);

document.getElementById('openfile_vox').addEventListener("change", (ev) => {
    if (ev.target.files.length > 0)
        fileHandler(ev.target.files[0]);
}, false);

document.getElementById('openfile_objglb').addEventListener("change", (ev) => {
    if (ev.target.files.length > 0)
        fileHandler(ev.target.files[0]);
}, false);

document.getElementById('openfile_img').addEventListener("change", (ev) => {
    if (ev.target.files.length > 0)
        fileHandler(ev.target.files[0]);
}, false);

document.getElementById('openfile_tex').addEventListener("change", (ev) => {
    if (ev.target.files.length > 0)
        fileHandler(ev.target.files[0]);
}, false);

document.getElementById('openfile_hdr').addEventListener("change", (ev) => {
    if (ev.target.files.length > 0)
        fileHandler(ev.target.files[0]);
}, false);

window.addEventListener("resize", (ev) => { 
    engine.resize(true);
    updateAxisViewViewport();
    if (scene.activeCamera.mode == BABYLON.Camera.ORTHOGRAPHIC_CAMERA)
        camera.setOrthoZoom();
    palette.create();
}, false);


// -------------------------------------------------------
// Utils


function CustomLoadingScreen() {
    CustomLoadingScreen.prototype.displayLoadingUI = () => {
        document.getElementById('loadingscreen').style.display = 'unset';
    }
    CustomLoadingScreen.prototype.hideLoadingUI = () => {
        document.getElementById('loadingscreen').style.display = 'none';
    }
}

const easingFunction = new BABYLON.CubicEase();
easingFunction.setEasingMode(BABYLON.EasingFunction.EASINGMODE_EASEINOUT);
function animator(target, property, from, to, fps=10, frames=10, callback=null) {
    BABYLON.Animation.CreateAndStartAnimation('animator',
        target, property, fps, frames, from, to, 0, easingFunction, callback);
}

function updateShadowMap() {
    scene.lights[1].getShadowGenerator().getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
}

function updateViewport(w, h, bottom, right) {
    return new BABYLON.Viewport(1 - (w + right) / canvas.width, 1 - (bottom + canvas.height) / canvas.height,   w / canvas.width, h / canvas.height);
}

function updateAxisViewViewport() {
    sceneAxisView.activeCamera.viewport = updateViewport(100, 100, 5, -5);
}

function setLightPositionByAngle(light, angle, distance, height) {
    light.position = new BABYLON.Vector3(
        Math.cos(angle * Math.PI / 180) * distance,
        height,
        Math.sin(angle * Math.PI / 180) * distance);
    light.setDirectionToTarget(BABYLON.Vector3.Zero());
}

function updateLightAngles(value) {
    setLightPositionByAngle(scene.lights[1], parseInt(value), 50, 100);
    updateShadowMap();
}

function updateLightIntensity(value) {
    scene.lights[1].intensity = parseFloat(value);
}

function updateLightColor(hex) {
    scene.lights[1].diffuse = BABYLON.Color3.FromHexString(hex);
}

function enableShadows(isEnabled) {
    scene.getNodeByName("shadowcatcher").isVisible = isEnabled;
    scene.lights[1].shadowEnabled = isEnabled;
    if (MODE == 0) builder.createSPS();
}

function getMeshSize(bounds) {
    return new BABYLON.Vector3(
        Math.abs(bounds.minimum.x - bounds.maximum.x),
        Math.abs(bounds.minimum.y - bounds.maximum.y),
        Math.abs(bounds.minimum.z - bounds.maximum.z)
    );
}

function normalizeMesh(mesh, scale) {
    const bounds = mesh.getBoundingInfo();
    const size = getMeshSize(bounds);
    // normalize scale
    const scaleFactor = Math.min(scale / size.x, scale / size.y, scale / size.z);
    let scaleMatrix = BABYLON.Matrix.Scaling(scaleFactor, scaleFactor, scaleFactor);
    // center mesh and drop to floor
    const nX = -bounds.maximum.x + (size.x / 2);
    const nY = (size.y / 2) - bounds.boundingBox.center.y;
    const nZ = -bounds.maximum.z + (size.z / 2);
    let transMatrix = BABYLON.Matrix.Translation(nX, nY, nZ);
    // bake matrices
    let matrix = transMatrix.multiply(scaleMatrix);
    mesh.bakeTransformIntoVertices(matrix);
    scaleMatrix = null;
    transMatrix = null;
    matrix = null;
}

function resetPivot(mesh) {
    const center = mesh.getBoundingInfo().boundingBox.centerWorld;
    mesh.setPivotMatrix(BABYLON.Matrix.Translation(-center.x, -center.y, -center.z), false);
    mesh.bakeCurrentTransformIntoVertices();
    mesh.setPivotMatrix(BABYLON.Matrix.Identity());
    mesh.position = center;
    mesh.refreshBoundingInfo();
}

function createScreenshot(scale = 3) {
    if (isMobileDevice()) scale = 2;
    const canvasWidth = canvas.width;   // take shot twice larger
    const canvasHeight = canvas.height; // to improve pixel density
    engine.setSize(canvasWidth * scale, canvasHeight * scale);
    isRenderAxisView = false;
    helper.gridPlane.isVisible = false;
    uix.colorPicker0.isVisible = false;
    uix.colorPicker1.isVisible = false;
    BABYLON.ScreenshotTools.CreateScreenshotWithResizeAsync(engine,
        scene.activeCamera, canvasWidth * scale, canvasHeight * scale).then((data) => {
            isRenderAxisView = true;
            if (MODE !== 2) {
                helper.gridPlane.isVisible = true;
                if (MODE == 0) uix.colorPicker0.isVisible = true;
                if (MODE == 1) uix.colorPicker1.isVisible = true;
            }
            engine.setSize(canvasWidth, canvasHeight);
    });
}

function createScreenshotBasic(width, height, callback) {
    isRenderAxisView = false;
    helper.gridPlane.isVisible = false;
    uix.colorPicker0.isVisible = false;
    uix.colorPicker1.isVisible = false;
    BABYLON.ScreenshotTools.CreateScreenshot(engine,
        scene.activeCamera, { width: width, height: height }, (data) => {
            isRenderAxisView = true;
            if (MODE !== 2) {
                helper.gridPlane.isVisible = true;
                if (MODE == 0) uix.colorPicker0.isVisible = true;
                if (MODE == 1) uix.colorPicker1.isVisible = true;
            }
            callback(data);
    });
}

function clearCache() {
    engine.clearInternalTexturesCache();
    scene.cleanCachedTextureBuffer();
    BABYLON.Tools.ClearLogCache();
    memory.clear();
    ui.notification('cache cleared');
}

function downloadFile(txt, filename) {
    const blob = new Blob([ txt ], { type: "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.click();
    URL.revokeObjectURL(url);
}

function forceDownload(href) {
    const anchor = document.createElement('a');
    anchor.href = href;
    anchor.download = href;
    document.body.appendChild(anchor);
    anchor.click();
}

async function saveFile(txt, filename) { // to show a file dialog in Chrome
    if (isChrome() && !isElectron() && !isMobileDevice()) {
        try {
            const blob = new Blob([ txt ], { type: "text/plain" });
            const fileHandle = await self.showSaveFilePicker({
                suggestedName: filename,
                types: [ { description: "File" } ]
            });
            const writeFile = async (fileHandle, contents) => {
                const writable = await fileHandle.createWritable();
                await writable.write(contents);
                await writable.close();
            };
            writeFile(fileHandle, blob).then(() => {
                //
            });
        } catch (err) {
            // canceled
        }
    } else { // showSaveFilePicker browser compatibility
        downloadFile(txt, filename);
    }
}

function toggleFullscreen() {
    (document.fullscreenElement) ? document.exitFullscreen() : document.body.requestFullscreen();
}

function isMobileDevice() {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) 
        || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) { 
        return true;
    }
    return false;
}

function isElectron() {
    if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') return true;
    if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) return true;
    if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) return true;
    return false;
}

function isChrome() {
    return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
}

function aspectRatioFit(srcW, srcH, maxW, maxH) {
    const ratio = Math.min(maxW / srcW, maxH / srcH);
    return { width: srcW * ratio, height: srcH * ratio };
}

function rgbIntToHex(r, g, b) {
    return '#' + (0x1000000 + b | (g << 8) | (r << 16)).toString(16).slice(1).toUpperCase();
}

function rgbFloatToHex(r, g, b) { // thanks to @labris
    const hr = Math.max(0, Math.min(255, Math.round(r * 255))).toString(16);
    const hg = Math.max(0, Math.min(255, Math.round(g * 255))).toString(16);
    const hb = Math.max(0, Math.min(255, Math.round(b * 255))).toString(16);
    return ("#" +
        (hr.length<2?"0":"") + hr +
        (hg.length<2?"0":"") + hg +
        (hb.length<2?"0":"") + hb).toUpperCase();
}

function hexToRgbFloat(hex, gamma = 1 / 0.5) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: Math.pow((parseInt(result[1], 16) / 255), gamma),
        g: Math.pow((parseInt(result[2], 16) / 255), gamma),
        b: Math.pow((parseInt(result[3], 16) / 255), gamma)
    } : null;
}

function randomHexColor() {
    return "#000000".replace(/0/g, () => {
        return (~~(Math.random()*16)).toString(16).toUpperCase();
    });
}

function gradientHexArray(hexStart, hexEnd, count) {
    const start = hexToRgbFloat(hexStart);    
    const end = hexToRgbFloat(hexEnd);    
    const arr = [];
    let a = 0;
    for (let i = 0; i < count; i++) {
        a += (1 / count);
        arr.push(rgbFloatToHex(
            start.r * a + (1 - a) * end.r,
            start.g * a + (1 - a) * end.g,
            start.b * a + (1 - a) * end.b
        ));
    }
    return arr;
}

function getCanvasColor(context, x, y) {
    const data = context.getImageData(x, y, 1, 1).data;
    return rgbIntToHex(data[0], data[1], data[2]);
}

function parseBool(val) {
    return val === true || val === "true";
}

function parseINI(data) {
    const regex = {
        section: /^\s*\[\s*([^\]]*)\s*\]\s*$/,
        param: /^\s*([^=]+?)\s*=\s*(.*?)\s*$/,
        comment: /^\s*;.*$/
    };
    const value = {};
    let lines = data.split(/[\r\n]+/);
    let section = null;
    lines.forEach((line) => {
        if (regex.comment.test(line)) {
            return;
        } else if (regex.param.test(line)) {
            const match = line.match(regex.param);
            if (section) {
                value[section][match[1]] = match[2];
            } else{
                value[match[1]] = match[2];
            }
        } else if (regex.section.test(line)) {
            const match = line.match(regex.section);
            value[match[1]] = {};
            section = match[1];
        } else if (line.length == 0 && section) {
            section = null;
        }
    });
    lines = null;
    return value;
}

// source: https://doc.babylonjs.com/toolsAndResources/utilities/SurfaceMeshPoints
function getRandomPointsOnMeshSurface(mesh, pointDensity) {
    let positions = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
    let indices = mesh.getIndices();
    const vertex0 = BABYLON.Vector3.Zero();
    const vertex1 = BABYLON.Vector3.Zero();
    const vertex2 = BABYLON.Vector3.Zero();
    const vec0 = BABYLON.Vector3.Zero();
    const vec1 = BABYLON.Vector3.Zero();
    const vec2 = BABYLON.Vector3.Zero();
    let id0, id1, id2;
    let v0X, v0Y, v0Z;
    let v1X, v1Y, v1Z;
    let v2X, v2Y, v2Z;
    let a, b, c, p;
    let area = 0;
    let nbPoints = 0;
    let lamda = 0;  
    let mu = 0;
    let facetPoint = null;
    let points = [];
    for (let index = 0; index < indices.length / 3; index++) {                
        id0 = indices[3 * index];
        id1 = indices[3 * index + 1]; 
        id2 = indices[3 * index + 2];        
        v0X = positions[3 * id0];
        v0Y = positions[3 * id0 + 1];
        v0Z = positions[3 * id0 + 2];
        v1X = positions[3 * id1];
        v1Y = positions[3 * id1 + 1];
        v1Z = positions[3 * id1 + 2];
        v2X = positions[3 * id2];
        v2Y = positions[3 * id2 + 1];
        v2Z = positions[3 * id2 + 2];
        vertex0.set(v0X, v0Y, v0Z);
        vertex1.set(v1X, v1Y, v1Z);
        vertex2.set(v2X, v2Y, v2Z);
        vertex1.subtractToRef(vertex0, vec0);
        vertex2.subtractToRef(vertex1, vec1);
        vertex2.subtractToRef(vertex0, vec2);
        a = vec0.length();
        b = vec1.length();
        c = vec2.length();
        p = (a + b + c) / 2;        
        area = Math.sqrt(p * (p - a) * (p - b) * (p - c));
        nbPoints = Math.round(pointDensity * area);
        for (let i = 0; i < nbPoints; i++) {
            lamda = BABYLON.Scalar.RandomRange(0, 1);
            mu = BABYLON.Scalar.RandomRange(0, 1);
            facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu)).floor();
            if (points.findIndex(i =>
                i.x == facetPoint.x &&
                i.y == facetPoint.y &&
                i.z == facetPoint.z) == -1) {
                    points.push(facetPoint);
                }
        }   
    }
    positions = null;
    indices = null;
    return points;
}

// source: https://gist.github.com/banksean/304522
function ClassicalNoise() {
    let grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0], 
                [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1], 
                [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
    let p = [];
    for (let i = 0; i < 256; i++) {
        p[i] = Math.floor(Math.random()*256);
    }
    let perm = [];
    for (let i = 0; i < 512; i++) {
        perm[i] = p[i & 255];
    }
    const dot = function(g, x, y, z) {
        return g[0]*x + g[1]*y + g[2]*z;
    }
    const mix = function(a, b, t) {
        return (1.0-t)*a + t*b;
    }
    const fade = function(t) {
        return t*t*t*(t*(t*6.0-15.0)+10.0);
    }
    this.noise = function(x, y, z) { // noise3D
        let X = Math.floor(x);
        let Y = Math.floor(y);
        let Z = Math.floor(z);
        x = x - X;
        y = y - Y;
        z = z - Z;
        X = X & 255;
        Y = Y & 255;
        Z = Z & 255;
        const n000 = dot(grad3[ perm[X+perm[Y+perm[Z]]] % 12        ], x, y, z);
        const n100 = dot(grad3[ perm[X+1+perm[Y+perm[Z]]] % 12      ], x-1, y, z);
        const n010 = dot(grad3[ perm[X+perm[Y+1+perm[Z]]] % 12      ], x, y-1, z);
        const n110 = dot(grad3[ perm[X+1+perm[Y+1+perm[Z]]] % 12    ], x-1, y-1, z);
        const n001 = dot(grad3[ perm[X+perm[Y+perm[Z+1]]] % 12      ], x, y, z-1);
        const n101 = dot(grad3[ perm[X+1+perm[Y+perm[Z+1]]] % 12    ], x-1, y, z-1);
        const n011 = dot(grad3[ perm[X+perm[Y+1+perm[Z+1]]] % 12    ], x, y-1, z-1);
        const n111 = dot(grad3[ perm[X+1+perm[Y+1+perm[Z+1]]] % 12  ], x-1, y-1, z-1);
        const u = fade(x);
        const v = fade(y);
        const w = fade(z);
        const nx00 = mix(n000, n100, u);
        const nx01 = mix(n001, n101, u);
        const nx10 = mix(n010, n110, u);
        const nx11 = mix(n011, n111, u);
        const nxy0 = mix(nx00, nx10, v);
        const nxy1 = mix(nx01, nx11, v);
        return mix(nxy0, nxy1, w); // nxyz
    }
    this.dispose = function() {
        grad3 = null;
        p = null;
        perm = null;
    }
}

// source: https://playground.babylonjs.com/#2SA7J8#7
const isTargetIn = (startPosition, endPosition, target, camera) => {
    const targetScreenPosition = BABYLON.Vector3.Project(
        target,
        BABYLON.Matrix.IdentityReadOnly,
        scene.getTransformMatrix(),
        camera.viewport.toGlobal(
            scene.getEngine().getRenderWidth(),
            scene.getEngine().getRenderHeight()
        )
    );
    if (targetScreenPosition.x >= Math.min(startPosition.x, endPosition.x) &&
        targetScreenPosition.x <= Math.max(startPosition.x, endPosition.x) &&
        targetScreenPosition.y >= Math.min(startPosition.y, endPosition.y) &&
        targetScreenPosition.y <= Math.max(startPosition.y, endPosition.y)) {
        return true;
    }
    return false;
}

// source: https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/VOXLoader.js
function parseMagicaVoxel(buffer) {
    let data = new DataView(buffer);
    
    const id = data.getUint32(0, true);
    const version = data.getUint32(4, true);
    if (id !== 542658390 || version !== 150) {
        ui.notification( 'not a valid MagicaVoxel file');
        return;
    }

    let DEFAULT_PALETTE = [
        0x00000000, 0xffffffff, 0xffccffff, 0xff99ffff, 0xff66ffff, 0xff33ffff, 0xff00ffff, 0xffffccff,
        0xffccccff, 0xff99ccff, 0xff66ccff, 0xff33ccff, 0xff00ccff, 0xffff99ff, 0xffcc99ff, 0xff9999ff,
        0xff6699ff, 0xff3399ff, 0xff0099ff, 0xffff66ff, 0xffcc66ff, 0xff9966ff, 0xff6666ff, 0xff3366ff,
        0xff0066ff, 0xffff33ff, 0xffcc33ff, 0xff9933ff, 0xff6633ff, 0xff3333ff, 0xff0033ff, 0xffff00ff,
        0xffcc00ff, 0xff9900ff, 0xff6600ff, 0xff3300ff, 0xff0000ff, 0xffffffcc, 0xffccffcc, 0xff99ffcc,
        0xff66ffcc, 0xff33ffcc, 0xff00ffcc, 0xffffcccc, 0xffcccccc, 0xff99cccc, 0xff66cccc, 0xff33cccc,
        0xff00cccc, 0xffff99cc, 0xffcc99cc, 0xff9999cc, 0xff6699cc, 0xff3399cc, 0xff0099cc, 0xffff66cc,
        0xffcc66cc, 0xff9966cc, 0xff6666cc, 0xff3366cc, 0xff0066cc, 0xffff33cc, 0xffcc33cc, 0xff9933cc,
        0xff6633cc, 0xff3333cc, 0xff0033cc, 0xffff00cc, 0xffcc00cc, 0xff9900cc, 0xff6600cc, 0xff3300cc,
        0xff0000cc, 0xffffff99, 0xffccff99, 0xff99ff99, 0xff66ff99, 0xff33ff99, 0xff00ff99, 0xffffcc99,
        0xffcccc99, 0xff99cc99, 0xff66cc99, 0xff33cc99, 0xff00cc99, 0xffff9999, 0xffcc9999, 0xff999999,
        0xff669999, 0xff339999, 0xff009999, 0xffff6699, 0xffcc6699, 0xff996699, 0xff666699, 0xff336699,
        0xff006699, 0xffff3399, 0xffcc3399, 0xff993399, 0xff663399, 0xff333399, 0xff003399, 0xffff0099,
        0xffcc0099, 0xff990099, 0xff660099, 0xff330099, 0xff000099, 0xffffff66, 0xffccff66, 0xff99ff66,
        0xff66ff66, 0xff33ff66, 0xff00ff66, 0xffffcc66, 0xffcccc66, 0xff99cc66, 0xff66cc66, 0xff33cc66,
        0xff00cc66, 0xffff9966, 0xffcc9966, 0xff999966, 0xff669966, 0xff339966, 0xff009966, 0xffff6666,
        0xffcc6666, 0xff996666, 0xff666666, 0xff336666, 0xff006666, 0xffff3366, 0xffcc3366, 0xff993366,
        0xff663366, 0xff333366, 0xff003366, 0xffff0066, 0xffcc0066, 0xff990066, 0xff660066, 0xff330066,
        0xff000066, 0xffffff33, 0xffccff33, 0xff99ff33, 0xff66ff33, 0xff33ff33, 0xff00ff33, 0xffffcc33,
        0xffcccc33, 0xff99cc33, 0xff66cc33, 0xff33cc33, 0xff00cc33, 0xffff9933, 0xffcc9933, 0xff999933,
        0xff669933, 0xff339933, 0xff009933, 0xffff6633, 0xffcc6633, 0xff996633, 0xff666633, 0xff336633,
        0xff006633, 0xffff3333, 0xffcc3333, 0xff993333, 0xff663333, 0xff333333, 0xff003333, 0xffff0033,
        0xffcc0033, 0xff990033, 0xff660033, 0xff330033, 0xff000033, 0xffffff00, 0xffccff00, 0xff99ff00,
        0xff66ff00, 0xff33ff00, 0xff00ff00, 0xffffcc00, 0xffcccc00, 0xff99cc00, 0xff66cc00, 0xff33cc00,
        0xff00cc00, 0xffff9900, 0xffcc9900, 0xff999900, 0xff669900, 0xff339900, 0xff009900, 0xffff6600,
        0xffcc6600, 0xff996600, 0xff666600, 0xff336600, 0xff006600, 0xffff3300, 0xffcc3300, 0xff993300,
        0xff663300, 0xff333300, 0xff003300, 0xffff0000, 0xffcc0000, 0xff990000, 0xff660000, 0xff330000,
        0xff0000ee, 0xff0000dd, 0xff0000bb, 0xff0000aa, 0xff000088, 0xff000077, 0xff000055, 0xff000044,
        0xff000022, 0xff000011, 0xff00ee00, 0xff00dd00, 0xff00bb00, 0xff00aa00, 0xff008800, 0xff007700,
        0xff005500, 0xff004400, 0xff002200, 0xff001100, 0xffee0000, 0xffdd0000, 0xffbb0000, 0xffaa0000,
        0xff880000, 0xff770000, 0xff550000, 0xff440000, 0xff220000, 0xff110000, 0xffeeeeee, 0xffdddddd,
        0xffbbbbbb, 0xffaaaaaa, 0xff888888, 0xff777777, 0xff555555, 0xff444444, 0xff222222, 0xff111111];

    let i = 8;
    let chunk;
    const chunks = [];

    while (i < data.byteLength) {
        let id = '';
        for (let j = 0; j < 4; j++) {
            id += String.fromCharCode(data.getUint8(i++));
        }

        const chunkSize = data.getUint32(i, true);
        i += 4;
        i += 4; // childChunks

        if (id === 'SIZE') {
            const x = data.getUint32(i, true);
            i += 4;
            const y = data.getUint32(i, true);
            i += 4;
            const z = data.getUint32(i, true);
            i += 4;
            chunk = {
                palette: DEFAULT_PALETTE,
                size: { x: x, y: y, z: z }
            };
            chunks.push(chunk);
            i += chunkSize - (3 * 4);
        } else if (id === 'XYZI') {
            const numVoxels = data.getUint32(i, true);
            i += 4;
            chunk.data = new Uint8Array(buffer, i, numVoxels * 4);
            i += numVoxels * 4;
        } else if (id === 'RGBA') {
            const palette = [0];
            for (let j = 0; j < 256; j++) {
                palette[j + 1] = data.getUint32(i, true);
                i += 4;
            }
            chunk.palette = palette;
        } else {
            i += chunkSize;
        }
    }

    DEFAULT_PALETTE = null;
    data = null;
    buffer = null;
    return chunks;
}


// -------------------------------------------------------
// Documentation


ui.domHelp.innerHTML = `
    <img width="100%" src="media/banner.jpg">
    <br><h1>Voxel-based 3D modeling application</h1>
    <br>A 3D modeling web-application to quickly create and explore ideas, from learning 3D modeling to voxel-art and 3D printing, creating game assets, logo design, arch-viz and more. It is written with JavaScript using the Babylon.js engine and is available for desktop and mobile browsers
    <br>
    <br><b>MODEL</b> - Create, draw and paint voxel particles
    <br><b>BAKERY</b> - Bake voxels into mesh, transform, replicate and setup materials/textures
    <br><b>RENDER</b> - Take screenshot, or export to GLB for more advanced use cases
    <br><i>&#8627; it is recommended to bake voxels before render or export</i>
    <br><i>&#8627; but you can sacrificing quality, to render or export unbaked</i>
    <br>
    <br>* Visit <a href="https://github.com/nimadez/voxel-builder/"><b>GitHub Repository</b></a> for more technical informations
    <br>
    <br><h1>GENERAL</h1>
    <br>
    <br><b>File I/O</b>
    <br>- Save and load project, to/from VBX file <i>(support both voxels and bakes)</i>
    <br>- Load from MagicaVoxel <i>(it only supports one object)</i>
    <br>- Export Voxels to GLB <i>(no grid texture, triangulated volume grid)</i>
    <br>- Export Bakes to GLB <i>(PBR materials and textures included, the mesh is clean)</i>
    <br>- Take pixel perfect screenshot to PNG <i>(render x3 larger, x2 on mobile)</i>
    <br><i>&#8627; screenshot is transparent when "background" is unchecked</i>
    <br>- Import baked meshes from VBX file <i>(to import bakes from multiple files)</i>
    <br><i>&#8627; baked meshes stored as GLB in VBX file</i>
    <br>- Set "project name" to save, export and screenshot easier
    <br>- Startup project disable by checking "no intro" from preferences
    <br>- Try "Blender importer script" to export exact copy <i>(useful in physics simulations)</i>
    <br>- Support file drag-and-drop <i>(VBX, VOX, OBJ, GLB, HDR, PNG, JPG, SVG)</i>
    <br>
    <br><b>Storage and Memory</b>
    <br>- Quick save and quick load voxels and bakes <i>(topbar buttons)</i>
    <br><i>&#8627; remember to save both voxels and bakes, they stored in different storages</i>
    <br>- Undo/redo supported by voxels, not bakes <i>(may change)</i>
    <br>- Data stored in the browser's history
    <br>- Memory support drawing, painting, symmetry, and respect hidden voxels
    <br>- Memory is cleared after loading a new model, or "clear cache"
    <br>
    <br><h1>MODEL</h1>
    <br>
    <br><b>CREATE (generator)</b>
    <br>- Create grid, plane, sphere, oval, random
    <br>- Create isometric room
    <br>- Create random terrain <i>(hit again to randomize)</i>
    <br>- Generator resets voxels but does not clear baked meshes, you can bake multiple voxel objects</i>
    <br>- Number of voxels limited to 64K or 64000 or 40x40x40 <i>(see repository for more info)</i>
    <br><i>&#8627; it is not recommended to create a grid larger than 30x30x30 on mid-range PC</i>
    <br><i>&#8627; sphere/oval is not filled</i>
    <br>
    <br><b>VOXELIZE: 3D voxelization</b>
    <br>- Import OBJ and GLB from file or URL, import OBJ from base64
    <br>- Merge and voxelize all meshes
    <br>- Increase "scale" amount for more details <i>(higher scale = more voxels)</i>
    <br>- Use "dense" to define the number of points per triangle faces <i>(density per area)</i>
    <br>- Increase density to voxelize low-poly meshes
    <br>- Voxelized model is not filled
    <br>- Paste url: direct https links with ".obj" or ".glb" ending (https://address/example.obj)
    <br>- Drag and drop supported for OBJ and GLB
    <br>- GLB NOTICE: multiple meshes need to have the same properties, or they won't merge
    <br>
    <br><b>VOXELIZE: 2D voxelization</b>
    <br>- Import JPG, PNG, SVG, or base64 image data
    <br>- Higher "ratio" for more details <i>(higher ratio = more voxels)</i>
    <br>- Use a pixel editor software to draw 2D shapes for voxelization
    <br><i>&#8627; use lower "ratio" for better result</i>
    <br>- Do not "bake all colors", you don't want a mesh per pixel color!
    <br><br><img src="media/voxelization.jpg">
    <br><img src="media/pixelmonk.jpg">
    <br>
    <br><b>SYMMETRY (SYMM.)</b>
    <br>- Symmetry supported by "add", "remove", "paint" and "pull" tools
    <br>- Symmetry supported by "box add", "box remove" and "box paint" tools
    <br>- Select [ X Y Z ] axis before start drawing and painting
    <br>- The pivot is optional, default local center or world center
    <br>- Symmetry respect hidden voxels
    <br><i>&#8627; open "symm." menu to symmetrize or mirror/flip voxels</i>
    <br><i>&#8627; axis-view contain a symmetry-axis indicator plane</i>
    <br><i>&#8627; scene contain a symmetry-pivot indicator point</i>
    <br><br><img src="media/symmetry.jpg">
    <br><br><img src="media/axisview.jpg">
    <br>
    <br><b>MODEL</b>
    <br>- Add: add new voxels <i>(symmetry supported)</i>
    <br>- Remove: delete voxels <i>(symmetry supported)</i>
    <br>- Box Add: add voxels by drawing a box shape <i>(symmetry supported)</i>
    <br><i>&#8627; set "height" to larger than 0 (zero) to draw walls</i>
    <br><i>&#8627; draw line and connect two voxels at far distance as well</i>
    <br><i>&#8627; ignores existing voxels, never duplicates</i>
    <br>- Box Remove: remove voxels by drawing a box <i>(symmetry supported)</i>
    <br>- Fill (slow): add a cluster of voxels to fill by rectangle area
    <br><i>&#8627; selection based on camera view, set camera angle carefully</i>
    <br><i>&#8627; use orthographic views to improve accuracy</i>
    <br><i>&#8627; slows down when filling large areas</i>
    <br><i>&#8627; use "workplane" to expand the selection area, make it easier to fill corners</i>
    <br>- Pull Voxel: pull a voxel <i>(symmetry supported)</i>
    <br>- Pull Color Group: pull voxels by color group <i>(remember to set a unique color to each part)</i>
    <br><i>&#8627; this tool overlap voxels in most cases, use "kill duplicates"</i>
    <br>- Workplane: draw anywhere in the space with a transformable workplane!
    <br><i>&#8627; support "add", "box add" and "fill" tool (support symmetry)</i>
    <br><i>&#8627; hit blue gizmo to rotate workplane to selected direction</i>
    <br><i>&#8627; reset the workplane from "model" menu</i>
    <br><i>&#8627; workplane resets on loading a new model</i>
    <br><br><img src="media/workplane.jpg">
    <br>
    <br><b>PAINT</b>
    <br>- Paint: paint color <i>(symmetry supported)</i>
    <br>- Box Paint: paint color by drawing a box <i>(symmetry supported)</i>
    <br>- Bucket: replace all similar colors
    <br>- Eyedropper: pick a voxel color, not a pixel color!
    <br>
    <br><b>VOXELS</b>
    <br>- Onion Skin: display transparent voxels
    <br>- Normalize Voxel Positions: transform model to center and drop the base to the floor
    <br>- Reduce Voxels: remove all the voxels between the voxels <i>(1 voxel deleted in a 3x3x3 cube)</i>
    <br>- Kill Duplicates: remove all the duplicated voxels <i>(not supposed to happen by code)</i>
    <br>
    <br><b>STORAGE</b>
    <br>- 4 persistent local storages with image preview
    <br>- Click image to load data
    <br>- Data is not undoable after clear
    <br>
    <br><b>GROUPS (color groups)</b>
    <br>- Isolate Color: isolate color group by picking a color
    <br>- Box Hide: hide voxels by drawing a box
    <br>- Hide Color: hide color group by picking a color
    <br>- Delete Hidden: delete all hidden voxels
    <br>- Unhide All: unhide all hidden voxels
    <br><i>&#8627; use visibility options to access underlying voxels</i>
    <br><i>&#8627; visibility is persistent, not break by drawing and painting</i>
    <br><i>&#8627; symmetry respect hidden voxels</i>
    <br><i>&#8627; bakery ignore hidden voxels (performance limit)</i>
    <br><i>&#8627; hidden voxels store and restore on save/load and undo/redo</i>
    <br>
    <br><b>Color Palette</b>
    <br>- Each color is a group (layer/part) in "model" mode
    <br>- Remember to set a unique color to each group
    <br>- Color palette generated on-the-fly as you draw, paint or delete voxels
    <br>- Color palette contain unique colors (no duplicates)
    <br><i>&#8627; double-click or double-tap on colors to show or hide color groups</i>
    <br><i>&#8627; combine colors and visibility options to create complex shapes</i>
    <br>
    <br><h1>BAKERY</h1>
    <br>
    <br><b>BAKERY</b>
    <br>- New Bake: add new bake <i>(bake a part)</i>
    <br>- Bake Color: bake by picking a color group <i>(bake a part)</i>
    <br>- Bake All Colors: clear and bake all voxels grouped by colors <i>(bake all parts)</i>
    <br>- Per-Face UVs: define texture coordinates, default 1:3 UVs, or per-face UVs
    <br><i>&#8627; unable to use the patterns and texture presets when checked</i>
    <br>- The mesh is clean and ready for 3D printing, no holes and watertight
    <br><br><img src="media/bakery_faces.jpg">
    <br>
    <br><b>BAKES</b>
    <br>- Clone: clone selected bake, not sharing material and texture
    <br>- Instance: instance selected bake, sharing material and texture
    <br><i>&#8627; they removed by deleting the source (unless reloading the file)</i>
    <br>- Merge Tool: click on pick button, select/deselect bakes, then hit merge button
    <br><i>&#8627; unable to merge instances, multi-material is not supported</i>
    <br>- Set Vertex Colors: set all vertex colors to current albedo color
    <br>
    <br><b>MATERIAL</b>
    <br>- Albedo, roughness, metallic, emissive and alpha properties
    <br>- Use replicate section to apply material/color to multiple bakes
    <br>- Use color pickers to update albedo color
    <br>
    <br><b>TEXTURE</b>
    <br>- Imported texture is not persistent, but attached to material and restored
    <br>- Default UV Texture: PNG 8-bit 16x48 or larger <i>(1:3 ratio, bottom:bottom|sides:center|top:top)</i>
    <br>- Per-Face UV Texture: All square images <i>(power of two)</i>
    <br><br><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAwCAMAAAAvgQplAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3FpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTZCMzVFRUU4MzEwMTFFRDlBNzFFMTE4QzM2RUY4NUMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTZCMzVFRUQ4MzEwMTFFRDlBNzFFMTE4QzM2RUY4NUMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmE2MjNhNDkzLTgxYTMtZTY0NS1hNjkzLWIxMGJlN2ZkYTZiNyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo0MjU4MTcxNi1mMzRjLWFlNDctYjBlOS00NzY4MDA2OThhMmUiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6Pyqi/AAAAKlBMVEX54OL2+/1trUjx+Pz9/v/N6Pbd7/nY7fiKvHG31Kn///8bq+BiqDffACRQL3/wAAAAaklEQVR42syQSxKAMAhD8a+h3v+6dqgzYnRa3JkdrxBIZSdJDOCU7xDQyG9BJVwixYH9xwVWKxwoj24E5IHvYGPwsoXvSD1dWg2npCiwHYsHneqE8Q5yWwOU2ptCWx7KYH6YDmQaDXcIMADj0yJr4nQMSAAAAABJRU5ErkJggg==">
    <br>
    <br><h1>RENDER</h1>
    <br>
    <br>- Drone camera view and controls
    <br>- Use HDR images to achieve realistic PBR rendering
    <br>- WASD controls on desktop, joystick controls on touchscreen
    <br>- Take pixel perfect screenshot to PNG <i>(render x3 larger, x2 on mobile)</i>
    <br><i>&#8627; voxels render slower than bakes, voxels not support PBR material</i>
    <br><br><img src="media/render.jpg">
    <br>
    <br><h1>Hover Toolbox</h1>
    <br>- Free Camera: disable drawing, make camera navigation easier and faster
    <br><i>&#8627; do not stay in drawing mode, switch to free camera after finish drawing</i>
    <br>- Hover is draggable in "free camera" mode
    <br>- Disable hover toolbox from preferences to use model/paint menu
    <br><br><img src="media/hover.jpg">
    <br><i class="material-icons">control_camera</i> Free Camera
    <br><i class="material-icons">create</i> Add Voxels
    <br><i class="material-icons">clear</i> Remove Voxels
    <br><i class="material-icons">add</i> Box Add
    <br><i class="material-icons">remove</i> Box Remove
    <br><i class="material-icons">brush</i> Paint
    <br><i class="material-icons">imagesearch_roller</i> Box Paint
    <br><i class="material-icons">format_color_fill</i> Bucket
    <br><i class="material-icons">colorize</i> Eyedropper
    <br>
    <br><h1>Axis View</h1>
    <br><b>Viewpoint</b>
    <br>- Tap on each axis to switch camera viewpoint (for perspective and orthographic views)
    <br><b>Frame camera</b>
    <br>- Tap the cube to frame camera (for perspective and orthographic views)
    <br><i>&#8627; model mode => frame all the voxels</i>
    <br><i>&#8627; bakery mode => frame selected bake, or return to "model camera" if nothing selected</i>
    <br><i>&#8627; render mode => return to "bakery camera" to render bakes, or return to "model camera" to render voxels</i>
    <br><i>&#8627; match all three cameras in turn (model camera > bakery camera > render camera)</i>
    <br><b>Symmetry axis indicator</b>
    <br>- Axis view contain a symmetry-axis indicator plane
    <br><br><img src="media/axisview.jpg">
    <br>
    <br><h1>Asset Viewer</h1>
    <br>- A 3D model and hdri viewer
    <br>- Load OBJ, GLB, STL, FBX, VOX, HDR, EXR
    <br>- Export OBJ, GLB, STL
    <br>- GLB and FBX animations
    <br>- PBR rendering and HDR lighting
    <br>- Support file drag and drop
    <br><i>&#8627; use base64 to paste model for 3D voxelization</i>
    <br><br><img src="media/assetviewer.jpg">
    <br>
    <br><h1>Statusbar Informations</h1>
    <br>FPS = measuring performance
    <br>VOX = total voxels
    <br>MSH = total baked meshes
    <br>VTX = total scene vertices <i>(include voxels)</i>
    <br>COL = total colors
    <br>FOV = camera field of view
    <br>VOXELS/BAKES = current render mode
    <br>
    <br><h1>Keyboard Shortcuts</h1>
    <table><tbody>
        <tr><td>Space</td> <td>Free Camera</td></tr>
        <tr><td>A</td> <td>Add Tool</td></tr>
        <tr><td>B</td> <td>Box Add</td></tr>
        <tr><td>R</td> <td>Remove Tool</td></tr>
        <tr><td>T</td> <td>Transform Tool</td></tr>
        <tr><td>P</td> <td>Paint Tool</td></tr>
        <tr><td>B</td> <td>Bucket Tool</td></tr>
        <tr><td>E</td> <td>Eyedropper Tool</td></tr>
        <tr><td>S</td> <td>Switch Symmetry Axis</td></tr>
        <tr><td>W</td> <td>Toggle Workplane</td></tr>
        <tr><td>F</td> <td>Frame Camera</td></tr>
        <tr><td>O</td> <td>Debug Layer</td></tr>
        <tr><td>C</td> <td>Clone selected bake</td></tr>
        <tr><td>Delete</td> <td>Delete selected bake</td></tr>
        <tr><td>Ctrl+Z</td> <td>Undo</td></tr>
        <tr><td>Ctrl+X</td> <td>Redo</td></tr>
    </tbody></table>
    <br><table><tbody>
        <tr><td>W</td> <td>Move Forward</td></tr>
        <tr><td>A</td> <td>Move Left</td></tr>
        <tr><td>S</td> <td>Move Backward</td></tr>
        <tr><td>D</td> <td>Move Right</td></tr>
        <tr><td>E</td> <td>Move Upward</td></tr>
        <tr><td>Q</td> <td>Move Downward</td></tr>
        <tr><td>Shift</td> <td>Speed Up</td></tr>
    </tbody></table>`;
</script>
</body>
</html>
